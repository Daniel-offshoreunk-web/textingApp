<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shape Battles</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
    :root { --ui-font: 'Orbitron', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; }
    /* Apply futuristic font across the HUD and UI components */
    body, button, input, select, textarea, .class-card, .widget, .class-level, .upgrade-tier h3, .ability-list li { font-family: var(--ui-font); }
    .class-card h2 { font-family: var(--ui-font); font-size: 14px; letter-spacing: 1.5px; text-transform: uppercase; }
    #homeScreen h1 { font-family: var(--ui-font); letter-spacing: 10px; text-transform: uppercase; }
    #widgetContainer, .widget { font-size: 13px; }
    .ability .ability-icon, .class-card .ability-list li strong { letter-spacing: 1px; text-transform: uppercase; }
    /* Improve contrast for thin display weights */
    body, .class-card .ability-list li { font-weight: 400; }
    </style>
    <script>
    // Inlined from classCardAutoSize.js â€” restructures `.class-card` into left/right columns
    window.addEventListener('DOMContentLoaded', function () {
        function ensureCardLayout() {
            document.querySelectorAll('.class-card').forEach(card => {
                if (card.dataset.restructured) return; // already done

                // create containers
                const left = document.createElement('div');
                left.className = 'card-left';
                const right = document.createElement('div');
                right.className = 'card-right';

                // find primary nodes: .class-icon, h2, first p, .ability-list, .class-exp-container
                const icon = card.querySelector('.class-icon');
                const title = card.querySelector('h2');
                const desc = card.querySelector('p');
                const abilities = card.querySelector('.ability-list');
                const exp = card.querySelector('.class-exp-container');

                // left: title + abilities (static)
                if (title) left.appendChild(title);
                if (abilities) left.appendChild(abilities);

                // right: description + exp/buttons (tangible)
                if (desc) right.appendChild(desc);
                if (exp) right.appendChild(exp);

                // move any remaining children not moved into right
                Array.from(card.childNodes).forEach(node => {
                    if (node === left || node === right) return;
                    // skip nodes we already moved
                    if (node.nodeType === 1 && (node.classList.contains('card-left') || node.classList.contains('card-right'))) return;
                    // append remaining interactive/content nodes to right
                    if (node.nodeType === 1) right.appendChild(node);
                });

                // clear card and append left + right
                card.innerHTML = '';
                card.appendChild(left);
                card.appendChild(right);
                card.dataset.restructured = '1';

                // ensure consistent sizing
                card.style.boxSizing = 'border-box';
                card.style.flex = '0 0 420px';
                card.style.width = '420px';
            });
        }

        ensureCardLayout();
        // make all cards equal height (match tallest) and recalc on resize
        function equalizeCardHeights() {
            const cards = Array.from(document.querySelectorAll('.class-card'));
            if (!cards.length) return;
            // reset heights to natural
            cards.forEach(c => { c.style.height = 'auto'; });
            // allow layout to settle then measure
            requestAnimationFrame(() => {
                let maxH = 0;
                cards.forEach(c => {
                    const h = c.getBoundingClientRect().height;
                    if (h > maxH) maxH = h;
                });
                if (maxH > 0) cards.forEach(c => { c.style.height = Math.ceil(maxH) + 'px'; });
            });
        }

        equalizeCardHeights();
        window.addEventListener('resize', () => { ensureCardLayout(); equalizeCardHeights(); });
        window.addEventListener('load', () => { ensureCardLayout(); equalizeCardHeights(); });
    });
    </script>
    <!-- fullscreen removed -->
    </style>
</head>
<body>
    <script>
    // Console capture for viewer
    (function() {
        window._consoleLogs = [];
        const maxLogs = 500;
        const origLog = console.log;
        const origWarn = console.warn;
        const origError = console.error;
        const origInfo = console.info;
        
        function captureLog(type, args) {
            const time = new Date().toLocaleTimeString('en-US', { hour12: false });
            const msg = Array.from(args).map(a => {
                if (typeof a === 'object') {
                    try { return JSON.stringify(a); } catch(e) { return String(a); }
                }
                return String(a);
            }).join(' ');
            window._consoleLogs.push({ type, time, msg });
            if (window._consoleLogs.length > maxLogs) window._consoleLogs.shift();
        }
        
        console.log = function() { captureLog('log', arguments); origLog.apply(console, arguments); };
        console.warn = function() { captureLog('warn', arguments); origWarn.apply(console, arguments); };
        console.error = function() { captureLog('error', arguments); origError.apply(console, arguments); };
        console.info = function() { captureLog('info', arguments); origInfo.apply(console, arguments); };
    })();
    
    function openConsoleViewer() {
        const modal = document.getElementById('consoleViewerModal');
        const logsDiv = document.getElementById('consoleViewerLogs');
        if (!modal || !logsDiv) return;
        
        logsDiv.innerHTML = '';
        window._consoleLogs.forEach(entry => {
            const div = document.createElement('div');
            div.className = 'console-log-entry ' + entry.type;
            div.innerHTML = '<span class="console-log-time">' + entry.time + '</span>' + 
                entry.msg.replace(/</g, '&lt;').replace(/>/g, '&gt;');
            logsDiv.appendChild(div);
        });
        logsDiv.scrollTop = logsDiv.scrollHeight;
        modal.classList.add('show');
    }
    
    function closeConsoleViewer() {
        const modal = document.getElementById('consoleViewerModal');
        if (modal) modal.classList.remove('show');
    }
    
    document.addEventListener('DOMContentLoaded', function() {
        const btn = document.getElementById('consoleViewerBtn');
        if (btn) btn.addEventListener('click', openConsoleViewer);
        
        const modal = document.getElementById('consoleViewerModal');
        if (modal) {
            modal.addEventListener('click', function(e) {
                if (e.target === modal) closeConsoleViewer();
            });
        }
    });
    </script>
    <!-- Global corner logout removed; logout is available in the auth/user area when logged in -->

    <!--
        CODE MAP / QUICK NAV
        ----------------------
        This file is large. Use this quick map to find major sections by approximate line.
        (Line numbers may change as code is edited; grep for the section title if needed.)

        - EffectsManager class ....................................... ~L2510
        - `gameState` initial object ................................ ~L3487
        - effectsManager instance creation .......................... ~L5150
        - Helper utilities (safety, map clamp) ...................... ~L5696 (findNearestSafePoint)
        - Dash / teleport helpers .................................. ~L5748 (performDashTo)
        - Class definitions (`const classes = { ... }`) .............. ~L6020
        - Abilities (per-class execute functions) ................... various (see class blocks)
        - Summoner abilities (E/R) .................................. ~L7120
        - Progression parser: `applyClassLevelBonuses` .............. ~L8576
        - Minion handling: `updateMinions` .......................... ~L10172
        - Enemy AI loop: `updateEnemies` ............................ ~L10377
        - Main game loop & effects update ........................... ~L11479
        - UI, HUD and modal code ................................... near top and bottom sections

        Suggested next steps for deeper refactor:
        1) Extract `EffectsManager` into `js/effects.js`
        2) Extract `classes` and abilities into `js/classes.js`
        3) Move helpers into `js/helpers.js` and import in-order
        4) Keep `game_standalone.html` for wiring and minimal bootstrap
    -->
    <!-- Wake / loading screen -->
        
        <style>
        /* Make the document iframe-friendly: allow scrolling and full-size percent-based containers */
        html, body { height: 100%; width: 100%; overflow: auto !important; position: relative; -webkit-overflow-scrolling: touch; }

        /* ========== HOLLOW NEON THEME - CORE VARIABLES ========== */
        :root {
            --neon-cyan: #00f5ff;
            --neon-magenta: #ff00ff;
            --neon-green: #00ff88;
            --neon-yellow: #ffff00;
            --neon-red: #ff3366;
            --bg-dark: #0a0a12;
            --bg-darker: #050508;
            --bg-card: rgba(10, 10, 18, 0.85);
            --border-glow: 0 0 10px currentColor, 0 0 20px currentColor;
            --text-glow: 0 0 8px currentColor;
        }

        /* Z-index layering map to ensure important UI is on top */
        :root {
            --z-base: 0;
            --z-enemy-hp: 5;
            --z-hud: 200;
            --z-coin: 300;
            --z-mobile-controls: 1000;
            --z-modal: 3000;
            --z-top: 10000;
        }
        #enemyHpLayer, #allyHpLayer { z-index: var(--z-enemy-hp) !important; }
        #hud { z-index: var(--z-hud) !important; position: absolute; }
        #coinDisplay { z-index: var(--z-coin) !important; }
        #mobileControls { z-index: var(--z-mobile-controls) !important; pointer-events: auto; }
        #skinsModal, #skinsScreen, #consoleViewerModal { z-index: var(--z-modal) !important; }
        #skinsModal .modal-backdrop, #consoleViewerModal .modal-backdrop { z-index: calc(var(--z-modal) - 10) !important; }

        /* ========== GAME TITLE STYLING ========== */
        .game-title {
            font-size: 52px;
            font-weight: 800;
            letter-spacing: 4px;
            margin-bottom: 30px;
            display: flex;
            gap: 14px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }
        .title-shape {
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan), 0 0 25px var(--neon-cyan), 0 0 50px rgba(0,245,255,0.4);
            animation: titlePulse 2.5s ease-in-out infinite;
        }
        .title-battles {
            color: var(--neon-magenta);
            text-shadow: 0 0 10px var(--neon-magenta), 0 0 25px var(--neon-magenta), 0 0 50px rgba(255,0,255,0.4);
            animation: titlePulse 2.5s ease-in-out infinite 0.3s;
        }
        @keyframes titlePulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.85; transform: scale(1.02); }
        }
        @media (max-width: 600px) {
            .game-title { font-size: 32px; gap: 10px; letter-spacing: 2px; }
        }

        /* Loading Screen */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-dark);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 99999;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }
        #loadingScreen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        #loadingScreen h1 {
            color: var(--neon-cyan);
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: var(--text-glow);
            letter-spacing: 8px;
            font-weight: 300;
        }
        #loadingBarContainer {
            width: 300px;
            height: 4px;
            background: transparent;
            border-radius: 2px;
            overflow: hidden;
            border: 1px solid var(--neon-cyan);
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.3);
        }
        #loadingBar {
            width: 0%;
            height: 100%;
            background: var(--neon-cyan);
            border-radius: 2px;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px var(--neon-cyan);
        }
        #loadingText {
            color: rgba(255, 255, 255, 0.5);
            margin-top: 15px;
            font-size: 12px;
            letter-spacing: 3px;
            text-transform: uppercase;
        }
        
        /* Custom Scrollbar Styling - Neon */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        
        ::-webkit-scrollbar-thumb {
            background: transparent;
            border: 1px solid var(--neon-cyan);
            border-radius: 4px;
            box-shadow: 0 0 5px var(--neon-cyan);
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 245, 255, 0.1);
            box-shadow: 0 0 10px var(--neon-cyan);
        }
        
        ::-webkit-scrollbar-corner {
            background: transparent;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-dark);
            color: #fff;
        }
        
        canvas {
            display: block;
        }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: transparent;
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            border-radius: 8px;
            border: 1px solid var(--neon-red);
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.3), inset 0 0 20px rgba(255, 51, 102, 0.05);
            z-index: 1100;
        }
        
        .hp-bar-container {
            width: 200px;
            height: 20px;
            background: transparent;
            border: 1px solid var(--neon-red);
            border-radius: 4px;
            overflow: hidden;
            margin-top: 8px;
            position: relative;
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.2);
        }
        
        .hp-bar {
            height: 100%;
            background: var(--neon-red);
            transition: width 0.3s ease;
            box-shadow: 0 0 15px var(--neon-red);
        }
        
        .hp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            font-size: 11px;
            text-shadow: 0 0 5px #000;
            letter-spacing: 1px;
        }
        
        /* Desktop ability bar */
        #abilities {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            visibility: hidden !important;
            pointer-events: none !important;
        }
        
        .ability {
            width: 70px;
            height: 70px;
            background: transparent;
            backdrop-filter: blur(10px);
            border: 1px solid var(--neon-green);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.2), inset 0 0 20px rgba(0, 255, 136, 0.03);
        }
        
        .ability::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.2), transparent);
            transition: left 0.5s;
        }
        
        .ability:hover:not(.disabled)::before {
            left: 100%;
        }
        
        .ability:hover:not(.disabled) {
            border-color: var(--neon-green);
            box-shadow: 0 0 25px var(--neon-green), inset 0 0 20px rgba(0, 255, 136, 0.1);
        }
        
        .ability:active:not(.disabled) {
            transform: scale(0.98);
        }
        
        .ability.disabled {
            opacity: 0.3;
            cursor: not-allowed;
            border-color: rgba(100, 100, 100, 0.3);
        }
        
        .ability-icon {
            font-size: 16px;
            margin-bottom: 5px;
            font-weight: bold;
            color: var(--neon-green);
            text-shadow: 0 0 10px var(--neon-green);
        }

        /* Enemy HP UI (screen-space DOM) */
        #enemyHpLayer { position: absolute; left: 0; top: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        .enemy-hp { position: absolute; transform: translate(-50%, -100%); pointer-events: none; font-family: inherit; }
        .enemy-hp .bar-bg { width: 100%; height: 8px; background: transparent; border-radius: 4px; border: 1px solid var(--neon-green); overflow: hidden; }
        .enemy-hp .bar-fg { height: 100%; width: 100%; background: var(--neon-green); transform-origin: left center; transition: width 120ms linear; box-shadow: 0 0 8px var(--neon-green); }
        
        /* Ally HP UI */
        #allyHpLayer { position: absolute; left: 0; top: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        .ally-hp { position: absolute; transform: translate(-50%, -100%); pointer-events: none; font-family: inherit; }
        .ally-hp .bar-bg { width: 100%; height: 6px; background: transparent; border-radius: 3px; border: 1px solid var(--neon-cyan); overflow: hidden; }
        .ally-hp .bar-fg { height: 100%; width: 100%; background: var(--neon-cyan); transform-origin: left center; transition: width 120ms linear; box-shadow: 0 0 8px var(--neon-cyan); }
        
        .ability-key {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-weight: bold;
            letter-spacing: 1px;
        }
        
        .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.8);
            transition: height 0.1s linear;
            height: 0;
        }
        
        .cooldown-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 10px #000;
        }
        
        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: transparent;
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            border-radius: 8px;
            border: 1px solid var(--neon-cyan);
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.2), inset 0 0 20px rgba(0, 245, 255, 0.03);
            font-size: 16px;
            font-weight: 300;
            letter-spacing: 2px;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: var(--bg-card);
            backdrop-filter: blur(20px);
            padding: 40px 60px;
            border-radius: 12px;
            border: 1px solid var(--neon-red);
            box-shadow: 0 0 40px rgba(255, 51, 102, 0.3);
            text-align: center;
            display: none;
            z-index: 100;
        }
        
        #gameOver h1 {
            margin: 0 0 20px 0;
            font-size: 42px;
            color: var(--neon-red);
            text-shadow: 0 0 20px var(--neon-red);
            font-weight: 300;
            letter-spacing: 8px;
        }
        
        #gameOver button {
            margin-top: 20px;
            padding: 12px 30px;
            font-size: 16px;
            background: transparent;
            border: 1px solid var(--neon-cyan);
            color: var(--neon-cyan);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        
        #gameOver button:hover {
            background: rgba(0, 245, 255, 0.1);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.3);
        }
        
        #homeScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-dark);
            backdrop-filter: blur(20px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }

        #homeScreen h1 {
            color: var(--neon-cyan);
            font-size: 64px;
            margin-bottom: 60px;
            text-shadow: 0 0 30px var(--neon-cyan), 0 0 60px rgba(0, 245, 255, 0.3);
            font-weight: 200;
            letter-spacing: 12px;
        }

        /* ========== UNIFIED HOLLOW NEON BUTTONS ========== */
        /* Base unified button sizing */
        button, .home-action, .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            height: 56px;
            min-width: 220px;
            padding: 0 28px;
            font-size: 16px;
            font-weight: 400;
            border-radius: 6px;
            background: transparent;
            cursor: pointer;
            transition: all 0.18s ease;
            letter-spacing: 2px;
            text-transform: uppercase;
            box-sizing: border-box;
        }

        /* Home buttons grid (keeps full-width buttons in the grid) */
        .home-buttons {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 14px;
            max-width: 640px;
            margin: 0 auto;
            align-items: center;
            justify-items: center;
            width: 100%;
            padding: 0 12px;
        }
        .home-buttons button, .home-buttons .home-action { width: 100%; min-width: 0; }
        @media (max-width: 720px) { .home-buttons { grid-template-columns: 1fr; max-width: 360px; } }

        /* Color variants (use classes or keep existing id selectors) */
        #playButton { color: var(--neon-cyan); border: 1px solid var(--neon-cyan); box-shadow: 0 0 20px rgba(0,245,255,0.12); }
        #playButton:hover { background: rgba(0,245,255,0.06); box-shadow: 0 0 28px var(--neon-cyan); }

        .home-action { color: var(--neon-magenta); border: 1px solid var(--neon-magenta); box-shadow: 0 0 12px rgba(255,0,255,0.08); }
        .home-action:hover { background: rgba(255,0,255,0.06); box-shadow: 0 0 22px var(--neon-magenta); }

        /* Summon & Events overrides */
        #summonHomeButton.home-action { color: var(--neon-green) !important; border-color: var(--neon-green); box-shadow: 0 0 14px rgba(0,255,136,0.08); }
        #summonHomeButton.home-action:hover { background: rgba(0,255,136,0.06); box-shadow: 0 0 26px var(--neon-green); }
        #eventsHomeButton { color: var(--neon-yellow); border-color: var(--neon-yellow); }

        /* Skins modal */
        #skinsModal { position: fixed; inset: 0; display:none; align-items:center; justify-content:center; z-index:800; }
        #skinsModal .modal-backdrop { position:absolute; inset:0; background:rgba(3,6,10,0.6); backdrop-filter: blur(6px); }
        #skinsModal .modal-card { position:relative; padding:18px; background:var(--bg-card); border-radius:10px; border:1px solid rgba(255,255,255,0.04); box-shadow:0 0 30px rgba(0,0,0,0.6); z-index:2; width:360px; max-width:90%; }
        .skin-swatches { display:flex; gap:10px; flex-wrap:wrap; margin:12px 0; }
        .skin-swatch { width:56px; height:56px; border-radius:8px; border:2px solid rgba(255,255,255,0.06); cursor:pointer; box-shadow:0 0 12px rgba(0,0,0,0.4); display:flex; align-items:center; justify-content:center; }
        .skin-swatch.selected { outline:3px solid rgba(255,255,255,0.08); transform:scale(1.04); }
        .skin-swatch span { width:100%; height:100%; border-radius:6px; display:block; }
        /* Locked overlay */
        .skin-swatch.locked { position:relative; opacity:0.65; }
        .skin-swatch .lock-overlay { position:absolute; right:4px; bottom:4px; width:18px; height:18px; display:flex; align-items:center; justify-content:center; background:rgba(0,0,0,0.45); border-radius:4px; border:1px solid rgba(255,255,255,0.04); }
        /* rarity styling */
        .skin-swatch.rare span { box-shadow: 0 0 14px rgba(255,200,50,0.08), inset 0 0 6px rgba(255,200,50,0.03); }
        .skin-swatch.shiny span { box-shadow: 0 0 22px rgba(255,255,255,0.12), 0 0 40px rgba(255,255,255,0.06); transform: rotate(-6deg); }
        .skin-swatch.shiny { animation: subtleShine 3.8s linear infinite; }
        @keyframes subtleShine { 0% { transform: scale(1) rotate(-6deg); } 50% { transform: scale(1.02) rotate(-6deg); } 100% { transform: scale(1) rotate(-6deg); } }
        
        /* Aura effect styles */
        .skin-swatch.aura-glow span { animation: auraGlow 1.5s ease-in-out infinite; }
        .skin-swatch.aura-sparks span { animation: auraSparks 0.8s steps(3) infinite; }
        .skin-swatch.aura-glitchy span { animation: auraGlitchy 0.15s steps(2) infinite; }
        .skin-swatch.aura-pulse span { animation: auraPulse 1.2s ease-in-out infinite; }
        @keyframes auraGlow { 0%, 100% { box-shadow: 0 0 8px currentColor, 0 0 16px currentColor; } 50% { box-shadow: 0 0 20px currentColor, 0 0 40px currentColor; } }
        @keyframes auraSparks { 0% { filter: brightness(1); } 33% { filter: brightness(1.4); } 66% { filter: brightness(0.9); } 100% { filter: brightness(1.2); } }
        @keyframes auraGlitchy { 0% { transform: translate(0, 0) skewX(0deg); } 25% { transform: translate(-2px, 1px) skewX(2deg); } 50% { transform: translate(2px, -1px) skewX(-1deg); } 75% { transform: translate(-1px, 2px) skewX(1deg); } 100% { transform: translate(1px, -2px) skewX(-2deg); } }
        @keyframes auraPulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.1); opacity: 0.85; } }
        .aura-indicator { position: absolute; bottom: 2px; left: 2px; font-size: 10px; text-shadow: 0 0 4px currentColor; }

        #classSelection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-dark);
            backdrop-filter: blur(20px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            padding-top: 40px;
            z-index: 200;
        }
        
        #classSelection h1 {
            color: var(--neon-cyan);
            font-size: 32px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px var(--neon-cyan);
            font-weight: 300;
            letter-spacing: 6px;
            text-transform: uppercase;
        }
        
        /* Thin scrollbars for page and containers */
        html, body, .class-container {
            scrollbar-width: thin;
            scrollbar-color: rgba(0, 245, 255, 0.3) transparent;
        }

        /* WebKit browsers */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        ::-webkit-scrollbar-thumb {
            background-color: rgba(255,255,255,0.08);
            border-radius: 8px;
            border: 2px solid transparent;
            background-clip: padding-box;
        }
        ::-webkit-scrollbar-thumb:hover {
            background-color: rgba(255,255,255,0.14);
        }

        .class-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            max-width: 96vw;
            height: calc(80vh - 120px);
            overflow-x: auto;
            overflow-y: hidden;
            align-items: stretch;
            padding: 12px 20px 20px 20px;
            -webkit-overflow-scrolling: touch;
            /* removed scroll-snap to prevent auto-landing on class cards */
        }
        
        /* ========== CLASS CARDS - HOLLOW NEON ========== */
        .class-card {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 16px;
            flex: 0 0 360px;
            width: 360px;
            min-width: 300px;
            height: 100%;
            min-height: 300px;
            /* no scroll-snap-align to keep natural scrolling */
            padding: 16px;
            position: relative;
            background: transparent;
            backdrop-filter: blur(10px);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            overflow: hidden;
            border: 1px solid var(--neon-cyan);
            box-shadow: 0 0 20px rgba(0, 245, 255, 0.15), inset 0 0 30px rgba(0, 245, 255, 0.02);
            z-index: 0;
        }

        .card-right {
            overflow-y: auto;
            padding-right: 6px;
        }

        .card-right::-webkit-scrollbar { width: 6px; }
        .card-right::-webkit-scrollbar-track { background: transparent; }
        .card-right::-webkit-scrollbar-thumb { background: rgba(0, 245, 255, 0.2); border-radius: 3px; }
        
        .class-card::before {
            content: none;
        }
        .class-card:hover {
            border-color: var(--neon-magenta);
            box-shadow: 0 0 30px rgba(255, 0, 255, 0.3), inset 0 0 30px rgba(255, 0, 255, 0.03);
            z-index: 1;
        }
        
        .class-card h2 {
            font-size: 20px;
            margin: 0 0 10px 0;
            text-align: left;
            color: var(--neon-cyan);
            text-shadow: 0 0 10px var(--neon-cyan);
            font-weight: 400;
            letter-spacing: 2px;
        }
        
        .class-card .class-icon {
            display: none;
        }
        
        .class-card p {
            font-size: 11px;
            margin: 10px 0;
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.5;
        }
        
        .class-card .ability-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
        }
        .class-card .ability-list li {
            white-space: normal;
            overflow-wrap: anywhere;
            max-width: 100%;
            box-sizing: border-box;
        }

        .card-left {
            flex: 0 0 140px;
            max-width: 140px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
        }
        .card-right {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .card-left h2 { font-size: 16px; margin: 0; color: var(--neon-cyan); text-shadow: 0 0 8px var(--neon-cyan); }
        .card-left .class-icon { display:none; }
        
        .class-card .ability-list li {
            padding: 8px;
            background: transparent;
            margin-bottom: 6px;
            border-radius: 4px;
            border-left: 2px solid var(--neon-magenta);
            font-size: 10px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            line-height: 1.4;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .class-card .ability-list li strong {
            color: var(--neon-magenta);
            text-shadow: 0 0 8px var(--neon-magenta);
        }
        
        .class-exp-container {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(0, 245, 255, 0.2);
        }
        
        .class-exp-bar {
            width: 100%;
            height: 16px;
            background: transparent;
            border: 1px solid var(--neon-green);
            border-radius: 4px;
            overflow: hidden;
            position: relative;
            margin-top: 5px;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.15);
        }
        
        .class-exp-fill {
            height: 100%;
            background: var(--neon-green);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px var(--neon-green);
        }
        
        .class-exp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 9px;
            font-weight: 400;
            color: white;
            text-shadow: 0 0 5px #000;
            letter-spacing: 1px;
        }
        
        .class-level {
            font-size: 13px;
            color: var(--neon-green);
            font-weight: 400;
            text-align: center;
            text-shadow: 0 0 10px var(--neon-green);
            letter-spacing: 2px;
        }
        
        #progressionWindow {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 550px;
            max-height: 80vh;
            background: var(--bg-card);
            backdrop-filter: blur(20px);
            border: 1px solid var(--neon-cyan);
            border-radius: 8px;
            padding: 30px;
            z-index: 300;
            display: none;
            box-shadow: 0 0 40px rgba(0, 245, 255, 0.2);
        }
        
        #progressionContent {
            max-height: calc(80vh - 120px);
            overflow-y: auto;
            padding-right: 10px;
        }
        
        .progression-header {
            color: var(--neon-cyan);
            font-size: 24px;
            font-weight: 400;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 20px var(--neon-cyan);
            letter-spacing: 3px;
            text-transform: uppercase;
        }
        
        .upgrade-tier {
            background: transparent;
            border: 1px solid rgba(0, 245, 255, 0.3);
            border-radius: 6px;
            padding: 15px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }
        
        .upgrade-tier.unlocked {
            border-color: var(--neon-green);
            background: rgba(0, 255, 136, 0.05);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.2);
        }
        
        .upgrade-tier.locked {
            opacity: 0.4;
            border-color: rgba(255, 255, 255, 0.1);
        }
        
        .upgrade-tier h3 {
            color: var(--neon-cyan);
            margin: 0 0 10px 0;
            font-size: 16px;
            font-weight: 400;
            text-shadow: 0 0 8px var(--neon-cyan);
            letter-spacing: 1px;
        }
        
        .upgrade-tier p {
            color: rgba(255, 255, 255, 0.7);
            margin: 5px 0;
            font-size: 13px;
        }
        
        .close-progression {
            position: absolute;
            top: 22px;
            right: 22px;
            height: 44px;
            padding: 4px 22px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: 1px solid var(--neon-red);
            color: var(--neon-red);
            border-radius: 14px;
            cursor: pointer;
            font-weight: 700;
            font-size: 20px;
            letter-spacing: 0px;
            line-height: 1;
            transition: all 0.12s ease;
            box-sizing: border-box;
            min-width: 60px;
            text-shadow: 0 0 10px rgba(255, 51, 102, 0.9);
        }
        
        .close-progression:hover {
            background: rgba(255, 51, 102, 0.15);
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.4);
            text-shadow: 0 0 8px var(--neon-red);
        }

        /* progression-screen purchase button removed; use .buy-exp-btn on class cards */
        
        .class-card-btn-row {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }
        
        .view-progression-btn, .buy-exp-btn {
            width: 50%;
            padding: 10px 14px;
            font-size: 12px;
            font-weight: 400;
            border-radius: 4px;
            box-sizing: border-box;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s ease;
            min-width: 0;
            line-height: 1.1;
            display: inline-block;
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        
        .view-progression-btn {
            background: transparent;
            border: 1px solid var(--neon-cyan);
            color: var(--neon-cyan);
        }
        
        .view-progression-btn:hover {
            background: rgba(0, 245, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 245, 255, 0.3);
            text-shadow: 0 0 8px var(--neon-cyan);
        }
        
        .buy-exp-btn {
            background: transparent;
            border: 1px solid var(--neon-yellow);
            color: var(--neon-yellow);
        }
        
        .buy-exp-btn:hover {
            background: rgba(255, 255, 0, 0.1);
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.3);
            text-shadow: 0 0 8px var(--neon-yellow);
        }
        
        /* Class cards size variants */
        .class-card.wide-card {
            min-width: 340px;
            max-width: 520px;
        }
        .class-card.skinny-card {
            min-width: 120px;
            max-width: 220px;
        }

        .class-card:hover {
            border-color: var(--neon-magenta);
            box-shadow: 0 0 25px rgba(255, 0, 255, 0.3);
        }

        /* Locked class styling */
        .class-card.locked {
            opacity: 0.4;
            filter: grayscale(0.8);
            pointer-events: auto;
            position: relative;
        }
        
        .class-card.locked::after {
            content: 'LOCKED';
            position: absolute;
            top: 12px;
            right: 12px;
            transform: none;
            font-size: 11px;
            font-weight: 400;
            color: var(--neon-red);
            text-shadow: 0 0 8px var(--neon-red);
            background: transparent;
            border: 1px solid var(--neon-red);
            padding: 4px 8px;
            border-radius: 4px;
            z-index: 12;
            letter-spacing: 2px;
        }
        
        .class-card.locked.unlockable {
            opacity: 0.6;
            filter: grayscale(0.5);
            pointer-events: auto;
        }
        .class-card.locked.unlockable .class-card-btn-row { display: block; }
        
        .class-card.locked .class-exp-container,
        .class-card.locked.unlockable .class-exp-container { display: none !important; }

        .class-card.unlockable .class-card-btn-row { display:flex; flex-direction: column; gap:12px; align-items: stretch; }
        .class-card.unlockable .view-progression-btn,
        .class-card.unlockable .buy-exp-btn { width: 100%; }

        .unlock-class-btn {
            background: transparent;
            border: 1px solid var(--neon-green);
            color: var(--neon-green);
            border-radius: 4px;
            padding: 10px 14px;
            font-weight: 400;
            cursor: pointer;
            width: 100%;
            text-align: center;
            letter-spacing: 1px;
            text-transform: uppercase;
            transition: all 0.2s ease;
        }
        
        .unlock-class-btn:hover {
            background: rgba(0, 255, 136, 0.1);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
            text-shadow: 0 0 8px var(--neon-green);
        }
        
        .unlock-class-btn.disabled { 
            opacity: 0.4; 
            cursor: not-allowed; 
            border-color: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.4);
        }

        .card-shard-progress { width: 100%; display:block; font-family: inherit; }
        .card-shard-progress > div:first-child { display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; color: rgba(255, 255, 255, 0.6); }
        .card-shard-progress .bar-bg { height:6px; background:rgba(255,255,255,0.05); border-radius:4px; overflow:hidden; border: 1px solid rgba(255, 0, 255, 0.3); }
        .card-shard-progress .bar-fg { height:100%; width:0%; background: var(--neon-magenta); transition: width 0.25s ease; box-shadow: 0 0 8px var(--neon-magenta); }

        .class-card.locked .card-left,
        .class-card.locked.unlockable .card-left {
            flex: 1 1 100% !important;
            max-width: none !important;
            align-items: flex-start;
            padding-right: 18px;
        }

        .class-card.locked .card-left h2,
        .class-card.locked.unlockable .card-left h2 { text-align: left; }
        
        #buyNextClassBtn {
            margin-top: 18px;
            padding: 12px 28px;
            font-size: 14px;
            font-weight: 400;
            border-radius: 4px;
            background: transparent;
            border: 1px solid var(--neon-green);
            color: var(--neon-green);
            cursor: pointer;
            letter-spacing: 1px;
            text-transform: uppercase;
            transition: all 0.2s ease;
        }
        #buyNextClassBtn:hover {
            background: rgba(0, 255, 136, 0.1);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
            text-shadow: 0 0 8px var(--neon-green);
        }
        #buyNextClassBtn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            border-color: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.4);
        }

        .class-icon {
            font-weight: 400;
            background: transparent;
            border: 1px solid var(--neon-cyan);
            padding: 6px 10px;
            border-radius: 4px;
            display: inline-block;
            margin-bottom: 8px;
            color: var(--neon-cyan);
            text-shadow: 0 0 8px var(--neon-cyan);
            letter-spacing: 1px;
        }

        /* Select button */
        #selectButton {
            background: transparent;
            border: 1px solid var(--neon-magenta);
            color: var(--neon-magenta);
            padding: 12px 28px;
            border-radius: 4px;
            font-weight: 400;
            letter-spacing: 2px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        #selectButton:hover { 
            background: rgba(255, 0, 255, 0.1);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.3);
            text-shadow: 0 0 10px var(--neon-magenta);
        }

        /* HUD Home button */
        #homeButton {
            display: none;
            position: absolute;
            top: 18px;
            right: 18px;
            left: auto;
            z-index: 1200;
            padding: 8px 14px;
            background: transparent;
            border: 1px solid var(--neon-red);
            color: var(--neon-red);
            border-radius: 4px;
            font-weight: 400;
            letter-spacing: 1px;
            min-width: unset !important;
            transition: all 0.2s ease;
        }
        #homeButton:hover { 
            background: rgba(255, 51, 102, 0.1);
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.3);
            text-shadow: 0 0 8px var(--neon-red);
        }

        /* Abilities color variants */
        .ability .ability-icon { color: var(--neon-cyan); }
        #ability1 { border-color: var(--neon-red); }
        #ability2 { border-color: var(--neon-magenta); }
        #ability3 { border-color: var(--neon-green); }

        /* Top-right widget container */
        #widgetContainer {
            position: fixed;
            top: 18px;
            right: 18px;
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 2200;
            pointer-events: auto;
        }

        .widget {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            border-radius: 4px;
            min-width: 64px;
            font-weight: 400;
            letter-spacing: 1px;
        }

        .widget-coins {
            background: transparent;
            border: 1px solid var(--neon-yellow);
            color: var(--neon-yellow);
            flex-direction: column;
            align-items: flex-start;
            padding: 8px 12px;
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.15);
        }

        .widget-coins .coin-main {
            font-size: 14px;
            line-height: 1;
            color: var(--neon-yellow);
            text-shadow: 0 0 8px var(--neon-yellow);
        }
        .widget-coins .coin-label {
            font-size: 10px;
            color: rgba(255, 255, 0, 0.7);
            opacity: 0.9;
            margin-top: 2px;
            letter-spacing: 1px;
        }

        .widget-home {
            background: transparent;
            border: 1px solid var(--neon-red);
            color: var(--neon-red);
            padding: 8px 10px;
            font-size: 12px;
            border-radius: 4px;
            min-width: 0;
            letter-spacing: 1px;
            transition: all 0.2s ease;
        }
        
        .widget-home:hover {
            background: rgba(255, 51, 102, 0.1);
            box-shadow: 0 0 15px rgba(255, 51, 102, 0.3);
            text-shadow: 0 0 8px var(--neon-red);
        }

        /* Ensure existing absolute styles don't conflict once moved into container */
        #coinDisplay, #homeButton { position: static !important; right: auto !important; left: auto !important; top: auto !important; }
        
        /* Auth Screen Styles */
        #authScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--bg-darker);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 99998;
        }
        #authScreen.hidden { display: none; }
        #authScreen h1 {
            color: var(--neon-cyan);
            font-size: 36px;
            margin-bottom: 30px;
            text-shadow: 0 0 30px var(--neon-cyan);
            letter-spacing: 8px;
            font-weight: 300;
            text-transform: uppercase;
        }
        .auth-container {
            background: var(--bg-card);
            border: 1px solid var(--neon-cyan);
            border-radius: 10px;
            padding: 2.5rem;
            width: 420px;
            max-width: 94%;
            box-shadow: 0 0 40px rgba(0, 245, 255, 0.12);
        }
        .auth-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 1.5rem;
        }
        .auth-tab {
            flex: 1;
            padding: 0.85rem 1rem;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 8px;
            color: rgba(255, 255, 255, 0.6);
            cursor: pointer;
            font-size: 13px;
            transition: all 0.16s;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        .auth-tab:hover {
            border-color: rgba(255, 255, 255, 0.4);
            color: rgba(255, 255, 255, 0.8);
        }
        .auth-tab.active {
            background: rgba(0,245,255,0.06);
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
            font-weight: 600;
            box-shadow: 0 0 18px rgba(0, 245, 255, 0.12);
            text-shadow: 0 0 10px var(--neon-cyan);
            transform: translateY(-2px);
        }
        .auth-form { display: none; }
        .auth-form.active { display: block; }
        .auth-input {
            width: 100%;
            padding: 1rem;
            margin-bottom: 1rem;
            background: transparent;
            border: 1px solid rgba(0, 245, 255, 0.2);
            border-radius: 8px;
            color: white;
            font-size: 15px;
            letter-spacing: 1px;
            box-sizing: border-box;
        }
        .auth-input:focus {
            outline: none;
            border-color: var(--neon-cyan);
            box-shadow: 0 0 10px rgba(0, 245, 255, 0.2);
        }
        .auth-btn {
            width: 100%;
            padding: 1.15rem;
            background: transparent;
            border: 1px solid var(--neon-green);
            border-radius: 8px;
            color: var(--neon-green);
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.16s ease;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        .auth-btn:hover { 
            background: rgba(0, 255, 136, 0.1);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
            text-shadow: 0 0 8px var(--neon-green);
        }
        .auth-btn:disabled { 
            opacity: 0.4; 
            cursor: not-allowed;
            border-color: rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.4);
        }
        .auth-error {
            background: rgba(255, 51, 102, 0.1);
            border: 1px solid var(--neon-red);
            color: var(--neon-red);
            padding: 0.75rem;
            border-radius: 4px;
            margin-bottom: 1rem;
            text-align: center;
            display: none;
            font-size: 12px;
        }
        .auth-error.visible { display: block; }
        .auth-user-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: var(--bg-card);
            border: 1px solid var(--neon-cyan);
            padding: 8px 15px;
            border-radius: 4px;
            color: var(--neon-cyan);
            font-size: 12px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 10px;
            letter-spacing: 1px;
        }
        .auth-user-info.hidden { display: none; }
        .auth-logout-btn {
            background: transparent;
            border: 1px solid var(--neon-red);
            color: var(--neon-red);
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            letter-spacing: 1px;
            transition: all 0.2s ease;
        }
        .auth-logout-btn:hover { 
            background: rgba(255, 51, 102, 0.1);
            box-shadow: 0 0 10px rgba(255, 51, 102, 0.3);
        }
        .play-guest-btn {
            width: 100%;
            margin-top: 1rem;
            padding: 1rem;
            background: transparent;
            border: 1px solid rgba(255,255,255,0.18);
            border-radius: 8px;
            color: rgba(255,255,255,0.7);
            cursor: pointer;
            font-size: 13px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            transition: all 0.16s ease;
        }
        .play-guest-btn:hover { 
            border-color: rgba(255,255,255,0.5);
            color: rgba(255,255,255,0.8);
        }
        
        /* Server Wake-up Screen */
        #serverWakeScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: var(--bg-darker);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999999;
        }
        #serverWakeScreen.hidden { display: none; }
        #serverWakeScreen h1 {
            color: var(--neon-cyan);
            font-size: 36px;
            margin-bottom: 30px;
            text-shadow: 0 0 30px var(--neon-cyan);
            letter-spacing: 8px;
            font-weight: 300;
            text-transform: uppercase;
        }
        .wake-status {
            color: rgba(255,255,255,0.7);
            font-size: 14px;
            margin-bottom: 20px;
            letter-spacing: 2px;
        }
        .wake-progress {
            width: 300px;
            height: 4px;
            background: transparent;
            border: 1px solid rgba(0, 245, 255, 0.3);
            border-radius: 2px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        .wake-progress-bar {
            height: 100%;
            background: var(--neon-cyan);
            border-radius: 2px;
            width: 0%;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px var(--neon-cyan);
        }
        .wake-tip {
            color: rgba(255,255,255,0.4);
            font-size: 12px;
            text-align: center;
            max-width: 350px;
            letter-spacing: 1px;
        }
        .wake-retry-btn {
            margin-top: 20px;
            padding: 10px 25px;
            background: transparent;
            border: 1px solid var(--neon-green);
            border-radius: 4px;
            color: var(--neon-green);
            font-size: 12px;
            font-weight: 400;
            cursor: pointer;
            display: none;
            letter-spacing: 1px;
            text-transform: uppercase;
            transition: all 0.2s ease;
        }
        .wake-retry-btn:hover { 
            background: rgba(0, 255, 136, 0.1);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
            text-shadow: 0 0 8px var(--neon-green);
        }
        
        /* Global corner logout removed; use auth-area logout when authenticated */
        
        /* Console Viewer */
        #consoleViewerBtn {
            position: fixed;
            bottom: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(30, 30, 40, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.6);
            font-size: 18px;
            cursor: pointer;
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }
        #consoleViewerBtn:hover {
            background: rgba(50, 50, 70, 0.95);
            border-color: var(--neon-cyan);
            color: var(--neon-cyan);
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
        }
        #consoleViewerModal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            justify-content: center;
            align-items: center;
        }
        #consoleViewerModal.show {
            display: flex;
        }
        #consoleViewerContent {
            width: 90%;
            max-width: 800px;
            height: 70%;
            max-height: 500px;
            background: rgba(15, 15, 25, 0.98);
            border: 1px solid rgba(100, 100, 120, 0.4);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #consoleViewerHeader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(30, 30, 45, 0.9);
            border-bottom: 1px solid rgba(100, 100, 120, 0.3);
        }
        #consoleViewerHeader h3 {
            margin: 0;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            font-weight: 500;
        }
        #consoleViewerClose {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.5);
            font-size: 20px;
            cursor: pointer;
            padding: 0 5px;
        }
        #consoleViewerClose:hover {
            color: #ff6b6b;
        }
        #consoleViewerLogs {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            line-height: 1.5;
            user-select: text;
        }
        .console-log-entry {
            padding: 3px 6px;
            border-radius: 3px;
            margin-bottom: 2px;
            word-break: break-all;
        }
        .console-log-entry.log { color: rgba(255, 255, 255, 0.8); }
        .console-log-entry.warn { color: #ffd93d; background: rgba(255, 217, 61, 0.1); }
        .console-log-entry.error { color: #ff6b6b; background: rgba(255, 107, 107, 0.1); }
        .console-log-entry.info { color: #6bcfff; }
        .console-log-time {
            color: rgba(255, 255, 255, 0.35);
            margin-right: 8px;
            font-size: 10px;
        }
    </style>
</head>
<body>
    <!-- corner logout removed -->
    <!-- Server Wake-up Screen -->
    <div id="serverWakeScreen">
        <h1 class="game-title"><span class="title-shape">Shape</span> <span class="title-battles">Battles</span></h1>
        <div class="wake-status" id="wakeStatus">Connecting to server...</div>
        <div class="wake-progress">
            <div class="wake-progress-bar" id="wakeProgressBar"></div>
        </div>
        <div class="wake-tip" id="wakeTip">Free servers sleep after inactivity. Waking up usually takes 10-30 seconds.</div>
        <button class="wake-retry-btn" id="wakeRetryBtn" onclick="startServerWake()">Retry Connection</button>
        <button class="wake-retry-btn" id="playOfflineBtn" onclick="playOffline()" style="display:block; border-color:var(--neon-magenta); color:var(--neon-magenta); margin-top:10px;">ðŸŽ® Play Offline</button>
        <button class="wake-retry-btn" id="offlineVersionBtn" onclick="downloadOfflineVersion()" style="display:block; border-color:var(--neon-cyan); color:var(--neon-cyan); margin-top:10px;">ðŸ“¥ Download Offline Version</button>
    </div>
    <!-- Skins modal -->
    <div id="skinsModal" aria-hidden="true">
        <div class="modal-backdrop" onclick="closeSkinsModal()"></div>
        <div class="modal-card">
            <h3 style="margin:0 0 8px 0; color:var(--neon-cyan);">Choose Your Skin</h3>
            <div class="skin-swatches">
                <div class="skin-swatch" data-color="#00f5ff" onclick="selectSkinSwatch(this)"><span style="background:#00f5ff"></span></div>
                <div class="skin-swatch" data-color="#ff00ff" onclick="selectSkinSwatch(this)"><span style="background:#ff00ff"></span></div>
                <div class="skin-swatch" data-color="#00ff88" onclick="selectSkinSwatch(this)"><span style="background:#00ff88"></span></div>
                <div class="skin-swatch" data-color="#ffff00" onclick="selectSkinSwatch(this)"><span style="background:#ffff00"></span></div>
                <div class="skin-swatch" data-color="#ff3366" onclick="selectSkinSwatch(this)"><span style="background:#ff3366"></span></div>
            </div>
            <div style="display:flex; gap:10px; justify-content:flex-end; margin-top:8px;">
                <button class="home-action" onclick="closeSkinsModal()">Cancel</button>
                <button id="applySkinBtn" class="home-action" onclick="applySelectedSkin()">Apply</button>
            </div>
        </div>
    </div>

    <!-- Skins full-screen window (like Summon) -->
    <div id="skinsScreen" style="display:none; position:fixed; inset:0; background:rgba(5,5,8,0.96); z-index:9999; align-items:center; justify-content:center; padding:20px; box-sizing:border-box; overflow:auto;">
        <div style="width:820px; max-width:96vw; height:520px; max-height:calc(95vh - 40px); background:var(--bg-card); border-radius:8px; padding:18px; position:relative; box-shadow:0 0 40px rgba(0,245,255,0.12); overflow:auto; border:1px solid var(--neon-cyan); backdrop-filter:blur(18px);">
            <button onclick="closeSkinsScreen()" aria-label="Close skins" style="position:absolute; right:14px; top:14px; background:transparent; border:1px solid var(--neon-red); padding:8px 12px; color:var(--neon-red); border-radius:4px; z-index:20; cursor:pointer; font-size:12px; letter-spacing:1px;">X</button>
            <h3 style="margin-top:4px; color:var(--neon-cyan);">Player Skins</h3>
            <p style="color:rgba(255,255,255,0.7); font-size:13px; margin-top:6px;">Pick a color for your player. You can also create a playable class that uses this color.</p>
            <div style="display:flex; gap:18px; margin-top:12px; height:calc(100% - 86px);">
                <div style="flex:1; display:flex; flex-direction:column; gap:12px; align-items:center; justify-content:flex-start; padding-top:6px;">
                            <div style="width:100%; background:var(--bg-darker); border-radius:8px; padding:12px; box-sizing:border-box; border:1px solid rgba(255,255,255,0.04);">
                                <div id="skinSwatchesContainer" class="skin-swatches" style="justify-content:flex-start;"></div>
                            </div>
                            <div style="display:flex; gap:12px; align-items:center; margin-top:6px;">
                                <button id="applySkinBtnLarge" class="home-action" onclick="applySelectedSkin();" style="min-width:140px;">Apply</button>
                                <button id="buyRandomSkinBtn" class="home-action" onclick="purchaseRandomSkin()" style="min-width:200px;">Buy Random Skin â€” 500</button>
                                <div id="skinMessage" style="color:rgba(255,255,255,0.8); font-size:13px; margin-left:6px;"></div>
                            </div>
                    <div id="skinPreview" style="margin-top:6px; color:rgba(255,255,255,0.6); font-size:13px;">Current: <span id="skinPreviewColor" style="display:inline-block; width:18px; height:18px; margin-left:8px; vertical-align:middle; border-radius:4px; border:1px solid rgba(255,255,255,0.06);"></span></div>
                </div>
                <div style="width:360px; padding:12px; color:rgba(255,255,255,0.7);">
                    <h4 style="color:var(--neon-cyan); margin:0 0 8px 0;">About Skins</h4>
                    <p style="color:rgba(255,255,255,0.6); font-size:13px;">Choosing "Play As Skin" will create a temporary playable class that uses your chosen skin color. This class will appear as your selected class until you change it.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Auth Screen -->
    <div id="authScreen">
        <h1 class="game-title"><span class="title-shape">Shape</span> <span class="title-battles">Battles</span></h1>
        <div class="auth-container">
            <div class="auth-tabs">
                <button class="auth-tab active" onclick="showAuthTab('login')">Login</button>
                <button class="auth-tab" onclick="showAuthTab('register')">Register</button>
            </div>
            <div id="authError" class="auth-error"></div>
            
            <!-- Login Form -->
            <div id="loginForm" class="auth-form active">
                <input type="text" class="auth-input" id="loginUsername" placeholder="Username">
                <input type="password" class="auth-input" id="loginPassword" placeholder="Password">
                <button class="auth-btn" onclick="doLogin()">Login</button>
            </div>
            
            <!-- Register Form -->
            <div id="registerForm" class="auth-form">
                <input type="text" class="auth-input" id="regUsername" placeholder="Username">
                <input type="text" class="auth-input" id="regDisplayName" placeholder="Display Name">
                <input type="password" class="auth-input" id="regPassword" placeholder="Password">
                <button class="auth-btn" onclick="doRegister()">Register</button>
            </div>
            
            <button class="play-guest-btn" onclick="playAsGuest()">Play as Guest (no save)</button>
        </div>
    </div>

    <!-- User Info Display -->
    <div id="userInfo" class="auth-user-info hidden">
        <span id="userDisplayName">Player</span>
        <button class="auth-logout-btn" onclick="doLogout()">Logout</button>
    </div>

    <!-- Loading Screen -->
    <div id="loadingScreen">
        <h1 class="game-title"><span class="title-shape">Shape</span> <span class="title-battles">Battles</span></h1>
        <div id="loadingBarContainer">
            <div id="loadingBar"></div>
        </div>
        <div id="loadingText">Loading...</div>
    </div>
    
    <!-- Console Viewer Button -->
    <button id="consoleViewerBtn" title="View Console">âš™</button>
    <div id="consoleViewerModal">
        <div id="consoleViewerContent">
            <div id="consoleViewerHeader">
                <h3>Console Output</h3>
                <button id="consoleViewerClose" onclick="closeConsoleViewer()">&times;</button>
            </div>
            <div id="consoleViewerLogs"></div>
        </div>
    </div>
    
    <div id="homeScreen">
        <h1 class="game-title"><span class="title-shape">Shape</span> <span class="title-battles">Battles</span></h1>
        <!-- Home buttons: Select Class, Play, Summon, Events -->
        <div class="home-buttons">
            <button id="playButton" class="ui-btn" onclick="startGame()">PLAY</button>
            <button id="selectButton" class="ui-btn" onclick="showClassSelection()">Select Class</button>
            <button id="skinsBtn" class="home-action" onclick="showSkinsScreen()">Skins</button>
            <button id="summonHomeButton" class="home-action" onclick="showSummonScreen()">Summon</button>
            <button id="eventsHomeButton" class="home-action" onclick="showEventsScreen()" style="border-color:var(--neon-yellow); color:var(--neon-yellow);"><span id="eventsFireIcon"></span> Events</button>
        </div>
    </div>
    <div id="classSelection">
        <h1>SELECT YOUR CLASS</h1>
        <div class="class-container">
            <div class="class-card" onclick="selectClass('electric')">
                <div class="class-icon">ELECTRIC</div>
                <h2>Electric</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">Master of lightning and chain attacks</p>
                <ul class="ability-list">
                    <li><strong>Q - Zap:</strong> Chain lightning that bounces to 3 enemies</li>
                    <li><strong>E - Lightning Strike:</strong> Strikes 3 random enemies instantly</li>
                    <li><strong>R - Super Zap:</strong> Long range lightning with unlimited bounces</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="electric-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="electric-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="electric-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('electric')">View Upgrades</button>
                        <button class="buy-exp-btn" data-class="electric" onclick="event.stopPropagation(); buyExp('electric')">Buy EXP</button>
                    </div>
                </div>
            </div>
            <div class="class-card" onclick="selectClass('fire')">
                <div class="class-icon">FIRE</div>
                <h2>Fire</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">Pyromancer with DoT and healing mechanics</p>
                <ul class="ability-list">
                    <li><strong>Q - Singe:</strong> Burn nearby enemies with DoT (instant damage if already burned)</li>
                    <li><strong>E - Healing Fire:</strong> Heal 1 HP per burned enemy, then damage them</li>
                    <li><strong>R - Fireballs:</strong> Launch 3 giant fireballs that burn and damage</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="fire-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="fire-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="fire-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('fire')">View Upgrades</button>
                        <button class="buy-exp-btn" data-class="fire" onclick="event.stopPropagation(); buyExp('fire')">Buy EXP</button>
                    </div>
                </div>
            </div>
            <div class="class-card" onclick="selectClass('pierce')">
                <div class="class-icon">PIERCE</div>
                <h2>Pierce</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">Master of piercing projectiles</p>
                <ul class="ability-list">
                    <li><strong>Q - Pierce Shot:</strong> Arrow that pierces through 5 enemies</li>
                    <li><strong>E - Multi Shot:</strong> Fire 5 auto-aimed arrows</li>
                    <li><strong>R - Arrow Storm:</strong> Rain piercing arrows on all enemies</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="pierce-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="pierce-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="pierce-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('pierce')">View Upgrades</button>
                        <button class="buy-exp-btn" data-class="pierce" onclick="event.stopPropagation(); buyExp('pierce')">Buy EXP</button>
                    </div>
                </div>
            </div>
            <div class="class-card" onclick="selectClass('engineer')">
                <div class="class-icon">ENGINEER</div>
                <h2>Engineer</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">Turret builder with machine gun</p>
                <ul class="ability-list">
                    <li><strong>Q - Deploy Turret:</strong> Place a turret that shoots enemies</li>
                    <li><strong>E - Heal Turret:</strong> Heal and upgrade nearest turret</li>
                    <li><strong>R - Machine Gun:</strong> Pull out machine gun (200 ammo)</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="engineer-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="engineer-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="engineer-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('engineer')">View Upgrades</button>
                        <button class="buy-exp-btn" data-class="engineer" onclick="event.stopPropagation(); buyExp('engineer')">Buy EXP</button>
                    </div>
                </div>
            </div>
            <div class="class-card" onclick="selectClass('life')">
                <div class="class-icon">LIFE</div>
                <h2>Life</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">High risk lifesteal warrior</p>
                <ul class="ability-list">
                    <li><strong>Q - Kill:</strong> 100 dmg, on kill: gain target's HP, teleport + AoE</li>
                    <li><strong>E - Life Burst:</strong> AoE damage with lifesteal</li>
                    <li><strong>R - Blood Frenzy:</strong> Rapid attacks with lifesteal</li>
                    <li><strong>Passive:</strong> Lose 5 HP every second</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="life-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="life-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="life-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('life')">View Upgrades</button>
                        <button class="buy-exp-btn" data-class="life" onclick="event.stopPropagation(); buyExp('life')">Buy EXP</button>
                    </div>
                </div>
            </div>
            <div class="class-card" onclick="selectClass('summoner')">
                <div class="class-icon">SUMMON</div>
                <h2>Summoner</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">Command minions and guardian to fight for you</p>
                <ul class="ability-list">
                    <li><strong>Q - Attack Command (CMD):</strong> All allies attack the nearest enemies to the player, dealing 30 dmg (75 for guardian)</li>
                    <li><strong>E - Summon Squad+:</strong> Summon 4 minions (22s duration, 60 HP, faster attacks)</li>
                    <li><strong>R - Summon Guardian+:</strong> Summon 1 powerful guardian (35s duration, 150 HP, very fast attacks)</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="summoner-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="summoner-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="summoner-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('summoner')">View Upgrades</button>
                        <button class="buy-exp-btn" data-class="summoner" onclick="event.stopPropagation(); buyExp('summoner')">Buy EXP</button>
                    </div>
                </div>
            </div>
            <div class="class-card" onclick="selectClass('water')">
                <div class="class-icon">WATER</div>
                <h2>Water</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">Master of knockback and control</p>
                <ul class="ability-list">
                    <li><strong>Q - Water Blast:</strong> Knockback enemies in front</li>
                    <li><strong>E - Tidal Wave:</strong> Push all enemies away</li>
                    <li><strong>R - Whirlpool:</strong> Pull enemies in then launch away</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="water-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="water-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="water-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('water')">View Upgrades</button>
                        <button class="buy-exp-btn" data-class="water" onclick="event.stopPropagation(); buyExp('water')">Buy EXP</button>
                    </div>
                </div>
            </div>
            <div class="class-card" onclick="selectClass('miner')">
                <div class="class-icon">MINER</div>
                <h2>Miner</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">Digs, buries mines, and passively throws shovels/drills</p>
                <ul class="ability-list">
                    <li><strong>Q - Dig:</strong> Burrow and teleport to mouse position</li>
                    <li><strong>E - Drill:</strong> Upgrade shovel to a powerful drill for a short time</li>
                    <li><strong>R - Mine:</strong> Bury a mine at mouse position that explodes when enemies step on it</li>
                    <li><strong>Passive:</strong> Automatically throws shovels and drills that home in on the nearest enemy</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="miner-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="miner-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="miner-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('miner')">View Upgrades</button>
                        <button class="buy-exp-btn" data-class="miner" onclick="event.stopPropagation(); buyExp('miner')">Buy EXP</button>
                    </div>
                </div>
            </div>
            <div class="class-card" onclick="selectClass('thief')">
                <div class="class-icon">THIEF</div>
                <h2>Thief</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">Swift assassin with stealth and daggers</p>
                <ul class="ability-list">
                    <li><strong>Q - Throw Daggers:</strong> Launch damaging daggers</li>
                    <li><strong>E - Vanish:</strong> Become invisible briefly</li>
                    <li><strong>R - Shadow Strike:</strong> Dash to farthest enemy, execute, leave bomb</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="thief-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="thief-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="thief-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('thief')">View Upgrades</button>
                        <button class="buy-exp-btn" data-class="thief" onclick="event.stopPropagation(); buyExp('thief')">Buy EXP</button>
                    </div>
                </div>
            </div>
            <div class="class-card" onclick="selectClass('trapper')">
                <div class="class-icon">TRAP</div>
                <h2>Trapper</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">Strategic bomber with traps and barriers</p>
                <ul class="ability-list">
                    <li><strong>Q - Place Bomb:</strong> Drop explosives around the map</li>
                    <li><strong>E - Spike Barrier:</strong> Create barriers that slow and damage</li>
                    <li><strong>R - C4 Detonation:</strong> Massive remote explosion</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="trapper-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="trapper-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="trapper-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('trapper')">View Upgrades</button>
                        <button class="buy-exp-btn" onclick="event.stopPropagation(); buyExp('trapper')">Buy EXP</button>
                    </div>
                </div>
            </div>
            <div class="class-card" onclick="selectClass('tycoon')">
                <div class="class-icon">ðŸ’°</div>
                <h2>Tycoon</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">Strategic investor with coin-generating tycoons</p>
                <ul class="ability-list">
                    <li><strong>Q - Dash:</strong> Quick dash that damages enemies in path</li>
                    <li><strong>E - Place Tycoon:</strong> Deploy a tycoon that generates coins</li>
                    <li><strong>R - Stab:</strong> Powerful stab attack for burst damage</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="tycoon-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="tycoon-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="tycoon-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('tycoon')">View Upgrades</button>
                        <button class="buy-exp-btn" onclick="event.stopPropagation(); buyExp('tycoon')">Buy EXP</button>
                    </div>
                </div>
            </div>
            <div class="class-card" onclick="selectClass('fighter')">
                <div class="class-icon">FTR</div>
                <h2>Fighter</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">Aggressive brawler with devastating charges</p>
                <ul class="ability-list">
                    <li><strong>Q - Ram:</strong> Charge into nearest enemy + 1s invulnerable</li>
                    <li><strong>E - Vortex:</strong> Pull enemies together then ram them</li>
                    <li><strong>R - Berserk:</strong> 5s rage mode with 2x speed</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="fighter-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="fighter-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="fighter-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('fighter')">View Upgrades</button>
                        <button class="buy-exp-btn" onclick="event.stopPropagation(); buyExp('fighter')">Buy EXP</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="hud" style="display:none;">
        <div><strong>HP:</strong></div>
        <div class="hp-bar-container">
            <div class="hp-bar" id="hpBar" style="width: 100%;"></div>
            <div class="hp-text" id="hpText">100 / 100</div>
        </div>
        <div style="margin-top: 10px; font-size: 12px;">
            <strong>Wave:</strong> <span id="waveCount">1</span>
        </div>
        <div id="checkpointNote" style="margin-top:8px; font-size:12px; color:#cfc; display:block;">Checkpoint: None</div>
        <div style="margin-top: 10px;">
            <strong style="font-size: 12px;">Wave Progress:</strong>
            <div class="hp-bar-container" style="margin-top: 5px;">
                <div class="hp-bar" id="waveProgress" style="width: 0%; background: var(--neon-green); box-shadow: 0 0 8px var(--neon-green);"></div>
                <div class="hp-text" id="waveProgressText">0 / 10</div>
            </div>
        </div>
        <div id="ammoCounter" style="margin-top: 10px; font-size: 12px; display: none;">
            <strong>Ammo:</strong> <span id="ammoCount">200</span> / 200
        </div>
    </div>
    <div id="coinDisplay" style="position: absolute; top: 18px; right: 18px; left: auto; font-size: 16px; color: #ddd; font-weight: normal; z-index: 80; display:flex; align-items:center; gap:8px;">
        <span id="coinIcon" style="font-size:18px; opacity:0.8;"></span>
        <span id="coinAmount">0</span>
        <span style="font-size:13px; color:#ccc; opacity:0.9; margin-left:4px;">Coins</span>
    </div>
    <button id="homeButton" onclick="restartGame()">Home</button>
    <script>
        // Swap positions: keep Home at far-right and move Coins to its left.
        function positionHomeAndCoins() {
            try {
                const coin = document.getElementById('coinDisplay');
                const home = document.getElementById('homeButton');
                if (!coin || !home) return;
                const gap = 12; // px between home button and coin display
                // place home at right:18px
                home.style.right = '18px';
                home.style.left = 'auto';
                // measure home width after ensuring it's laid out
                const homeW = Math.ceil(home.getBoundingClientRect().width) || 0;
                // place coin to the left of home (home is at right:18px)
                coin.style.right = (18 + homeW + gap) + 'px';
                coin.style.left = 'auto';
            } catch (e) { /* ignore */ }
        }
        window.addEventListener('DOMContentLoaded', positionHomeAndCoins);
        window.addEventListener('resize', positionHomeAndCoins);
        setTimeout(positionHomeAndCoins, 300);
    </script>
    <script>
        // Create a compact widget container and move HUD elements into it
        (function setupWidgets() {
            function createContainerAndMove() {
                if (document.getElementById('widgetContainer')) return;
                const container = document.createElement('div');
                container.id = 'widgetContainer';
                document.body.appendChild(container);

                const coin = document.getElementById('coinDisplay');
                const home = document.getElementById('homeButton');

                if (coin) {
                    // Tidy up inline positioning added earlier and add widget class
                    coin.style.position = 'static';
                    coin.style.right = '';
                    coin.style.left = '';
                    coin.style.top = '';
                    coin.classList.add('widget', 'widget-coins');

                    // Wrap coin amount in a small structure for nicer display
                    const amount = document.getElementById('coinAmount');
                    if (amount) {
                        amount.classList.add('coin-main');
                    }
                    // keep the existing 'Coins' label but style it
                    const label = coin.querySelector('span[style]');
                    if (label) label.classList.add('coin-label');

                    container.appendChild(coin);
                }

                if (home) {
                    home.style.position = 'static';
                    home.style.right = '';
                    home.style.left = '';
                    home.style.top = '';
                    home.classList.add('widget', 'widget-home');
                    container.appendChild(home);
                }
            }

            if (document.readyState === 'loading') {
                window.addEventListener('DOMContentLoaded', () => setTimeout(createContainerAndMove, 40));
            } else {
                setTimeout(createContainerAndMove, 40);
            }

            // In case the old position script runs later, force the container layout after resize
            window.addEventListener('resize', () => setTimeout(() => {
                const container = document.getElementById('widgetContainer');
                if (!container) createContainerAndMove();
            }, 60));
        })();
    </script>
    
    <div id="abilities" style="display:none;">
        <div class="ability" id="ability1" data-key="1">
            <div class="ability-icon">Q</div>
            <div class="ability-key">Q</div>
            <div class="cooldown-overlay"></div>
            <div class="cooldown-text"></div>
        </div>
        <div class="ability" id="ability2" data-key="2">
            <div class="ability-icon">E</div>
            <div class="ability-key">E</div>
            <div class="cooldown-overlay"></div>
            <div class="cooldown-text"></div>
        </div>
        <div class="ability" id="ability3" data-key="3">
            <div class="ability-icon">R</div>
            <div class="ability-key">R</div>
            <div class="cooldown-overlay"></div>
            <div class="cooldown-text"></div>
        </div>
    </div>
    
    <!-- Mobile controls: joystick + ability buttons (bottom-right, touch-first) -->
    <style>
        #mobileControls { position: fixed; right: 18px; bottom: 18px; z-index: 10001; display: flex; gap: 12px; align-items: center; pointer-events: none; }
        #mobileJoystick { width: 120px; height: 120px; border-radius: 999px; background: transparent; border: 1px solid var(--neon-cyan); position: relative; touch-action: none; pointer-events: auto; box-shadow: 0 0 15px rgba(0, 245, 255, 0.2); }
        #mobileStick { width: 56px; height: 56px; border-radius: 999px; background: transparent; border: 2px solid var(--neon-cyan); position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 10px var(--neon-cyan); }
        #mobileAbilities { display: flex; flex-direction: column; gap: 10px; pointer-events: auto; }
        .mobile-ability-btn { width: clamp(64px, 18vw, 110px); height: clamp(64px, 18vw, 110px); border-radius: 8px; background: transparent; display:flex; align-items:center; justify-content:center; color:#fff; font-weight:400; box-shadow: 0 0 15px rgba(255, 51, 102, 0.3); border: 1px solid var(--neon-red); }
        .mobile-ability-btn.secondary { border-color: var(--neon-magenta); box-shadow: 0 0 15px rgba(255, 0, 255, 0.3); }
        .mobile-ability-btn.tertiary { border-color: var(--neon-green); box-shadow: 0 0 15px rgba(0, 255, 136, 0.3); }
        .mobile-ability-btn:active { transform: scale(0.97); }
        .mobile-ability-btn { position: relative; overflow: hidden; }
        .mobile-ability-label { position: absolute; inset: 0; display:flex; align-items:center; justify-content:center; z-index: 4; pointer-events: none; font-size: clamp(12px, 3.5vw, 18px); font-weight:400; color:#fff; text-shadow: 0 0 8px currentColor; white-space: normal; padding:6px; text-align:center; word-break: break-word; text-transform: uppercase; letter-spacing: 1px; }
        .mobile-cooldown-overlay { position: absolute; inset: 0; z-index: 2; transition: height 0.12s linear; }
        .mobile-cooldown-text { position: absolute; inset: 0; display:flex; align-items:center; justify-content:center; z-index: 5; font-weight:400; font-size:18px; pointer-events:none; color:#fff; }
        @media (min-width: 900px) { #mobileControls { display: none; } }
        @media (max-width: 900px) { #abilities { display: none !important; } }
    </style>

    <div id="mobileControls" aria-hidden="false" style="display:none;">
        <div id="mobileJoystick" aria-label="Movement joystick" role="application">
            <div id="mobileStick"></div>
        </div>
        <div id="mobileAbilities">
            <button class="mobile-ability-btn" id="mAbility1">
                <div class="mobile-ability-label">Q</div>
                <div class="mobile-cooldown-overlay" style="background:rgba(0,0,0,0.35); height:0%; border-radius:12px;"></div>
                <div class="mobile-cooldown-text"></div>
            </button>
            <button class="mobile-ability-btn secondary" id="mAbility2">
                <div class="mobile-ability-label">E</div>
                <div class="mobile-cooldown-overlay" style="background:rgba(0,0,0,0.35); height:0%; border-radius:12px;"></div>
                <div class="mobile-cooldown-text"></div>
            </button>
            <button class="mobile-ability-btn tertiary" id="mAbility3">
                <div class="mobile-ability-label">R</div>
                <div class="mobile-cooldown-overlay" style="background:rgba(0,0,0,0.35); height:0%; border-radius:12px;"></div>
                <div class="mobile-cooldown-text"></div>
            </button>
        </div>
    </div>

    <script>
    (function(){
        // Wait for required globals to exist
        function ready(cb) {
            if (typeof movementManager !== 'undefined' && typeof abilities !== 'undefined') return cb();
            setTimeout(() => ready(cb), 80);
        }

        ready(() => {
            const joy = document.getElementById('mobileJoystick');
            const stick = document.getElementById('mobileStick');
            const maxRadius = 40; // pixels
            let activeId = null;

            function setVisual(dx, dy) {
                stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            }

            function updateJoystickFromPoint(clientX, clientY) {
                const rect = joy.getBoundingClientRect();
                const cx = rect.left + rect.width / 2;
                const cy = rect.top + rect.height / 2;
                let dx = clientX - cx;
                let dy = clientY - cy;
                // clamp
                const dist = Math.sqrt(dx*dx + dy*dy);
                const clamped = Math.min(dist, maxRadius);
                if (dist > 0) {
                    dx = dx / dist * clamped;
                    dy = dy / dist * clamped;
                }
                setVisual(dx, dy);
                // convert to normalized -1..1 with up = positive y (invert client Y)
                const nx = dx / maxRadius;
                const ny = -dy / maxRadius;
                // Movement manager expects y up positive
                movementManager.setJoystick(nx, ny);
            }

            function resetJoystick() {
                setVisual(0,0);
                movementManager.clearJoystick();
                activeId = null;
            }

            // Touch handlers
            joy.addEventListener('touchstart', (ev) => {
                const t = ev.changedTouches[0];
                activeId = t.identifier;
                updateJoystickFromPoint(t.clientX, t.clientY);
                ev.preventDefault();
            }, { passive: false });
            joy.addEventListener('touchmove', (ev) => {
                for (const t of ev.changedTouches) {
                    if (t.identifier === activeId) {
                        updateJoystickFromPoint(t.clientX, t.clientY);
                        ev.preventDefault();
                        break;
                    }
                }
            }, { passive: false });
            joy.addEventListener('touchend', (ev) => {
                for (const t of ev.changedTouches) {
                    if (t.identifier === activeId) {
                        resetJoystick();
                        ev.preventDefault();
                        break;
                    }
                }
            }, { passive: false });

            // Mouse fallback for joystick (desktop testing)
            let mouseDown = false;
            joy.addEventListener('mousedown', (ev) => { mouseDown = true; updateJoystickFromPoint(ev.clientX, ev.clientY); ev.preventDefault(); });
            window.addEventListener('mousemove', (ev) => { if (mouseDown) { updateJoystickFromPoint(ev.clientX, ev.clientY); ev.preventDefault(); }});
            window.addEventListener('mouseup', (ev) => { if (mouseDown) { mouseDown = false; resetJoystick(); ev.preventDefault(); }});

            // Ability buttons
            const m1 = document.getElementById('mAbility1');
            const m2 = document.getElementById('mAbility2');
            const m3 = document.getElementById('mAbility3');

            function triggerAbilityIndex(idx, startHold = false, endHold = false) {
                if (gameState.isGameOver) return;
                if (idx === 1 && abilities.q) {
                    if (abilities.q.execute()) {
                        updateAbilityCooldown('ability1', abilities.q.cooldown);
                        const el = document.getElementById('ability1'); if (el) { el.style.transform = 'scale(0.9)'; setTimeout(()=>el.style.transform='scale(1)',100); }
                        try { const mb = document.getElementById('mAbility1'); if (mb) { mb.style.transform='scale(0.9)'; setTimeout(()=>mb.style.transform='scale(1)',100); } } catch(e){}
                    }
                } else if (idx === 2 && abilities.e) {
                    if (abilities.e.execute()) {
                        updateAbilityCooldown('ability2', abilities.e.cooldown);
                        const el = document.getElementById('ability2'); if (el) { el.style.transform = 'scale(0.9)'; setTimeout(()=>el.style.transform='scale(1)',100); }
                        try { const mb = document.getElementById('mAbility2'); if (mb) { mb.style.transform='scale(0.9)'; setTimeout(()=>mb.style.transform='scale(1)',100); } } catch(e){}
                    }
                } else if (idx === 3 && abilities.r) {
                    // Engineer uses hold mechanic
                    if (selectedClass && selectedClass.name === 'Engineer') {
                        if (startHold) {
                            keys.r = true;
                        } else if (endHold) {
                            keys.r = false;
                        }
                    } else {
                        const result = abilities.r.execute();
                        if (result === 'reload') {
                            updateAbilityCooldown('ability3', abilities.r.cooldown);
                        } else if (result || result === true) {
                            updateAbilityCooldown('ability3', abilities.r.cooldown);
                            const el = document.getElementById('ability3'); if (el) { el.style.transform = 'scale(0.9)'; setTimeout(()=>el.style.transform='scale(1)',100); }
                            try { const mb = document.getElementById('mAbility3'); if (mb) { mb.style.transform='scale(0.9)'; setTimeout(()=>mb.style.transform='scale(1)',100); } } catch(e){}
                        }
                    }
                }
            }

            // Touch / pointer handlers for ability buttons
            function attachAbilityHandlers(btn, idx) {
                btn.addEventListener('touchstart', (ev) => { triggerAbilityIndex(idx, true, false); ev.preventDefault(); }, { passive:false });
                btn.addEventListener('touchend', (ev) => { triggerAbilityIndex(idx, false, true); ev.preventDefault(); }, { passive:false });
                btn.addEventListener('mousedown', (ev) => { triggerAbilityIndex(idx, true, false); ev.preventDefault(); });
                btn.addEventListener('mouseup', (ev) => { triggerAbilityIndex(idx, false, true); ev.preventDefault(); });
                btn.addEventListener('click', (ev) => { triggerAbilityIndex(idx, false, false); ev.preventDefault(); });
            }

            attachAbilityHandlers(m1, 1);
            attachAbilityHandlers(m2, 2);
            attachAbilityHandlers(m3, 3);
        });
    })();
    </script>

    <div id="gameOver">
        <h1>DEFEATED</h1>
        <p id="finalScore" style="font-size: 24px;"></p>
        <p id="gameOverGains" style="color:#ddd; margin:6px 0 12px 0;"></p>
        <div style="display:flex; gap:10px; justify-content:center;">
            <button onclick="playAgain()" style="padding:8px 12px; border-radius:8px;">Play Again</button>
            <button onclick="restartGame()" style="padding:8px 12px; border-radius:8px;">Home</button>
        </div>
    </div>
    
    <div id="progressionWindow">
        <button class="close-progression" onclick="closeProgression()">X</button>
        <div class="progression-header" id="progressionTitle">Class Progression</div>
        <div id="progressionContent"></div>
    </div>

    <!-- Events Screen -->
    <div id="eventsScreen" style="display:none; position:fixed; inset:0; background:rgba(5,5,8,0.95); z-index:9998; align-items:center; justify-content:center; padding:20px; box-sizing:border-box; overflow:auto;">
        <div style="width:800px; max-width:95vw; max-height:90vh; background:var(--bg-card); border-radius:8px; padding:24px; position:relative; box-shadow:0 0 40px rgba(255,255,0,0.15); overflow:auto; border:1px solid var(--neon-yellow); backdrop-filter:blur(20px);">
            <button onclick="closeEventsScreen()" aria-label="Close events" style="position:absolute; right:14px; top:14px; background:transparent; border:1px solid var(--neon-red); padding:8px 12px; color:var(--neon-red); border-radius:4px; z-index:20; cursor:pointer; font-size:12px; letter-spacing:1px;"><span id="eventsCloseIcon"></span></button>
            <h2 style="margin:0 0 20px 0; color:var(--neon-yellow); font-size:24px; text-align:center; font-weight:300; letter-spacing:4px; text-transform:uppercase; text-shadow:0 0 15px var(--neon-yellow);"><span id="eventsTitleIcon"></span> Events</h2>
            
            <!-- Main Quest Section -->
            <div style="background:transparent; border-radius:6px; padding:18px; margin-bottom:20px; border:1px solid rgba(255,255,0,0.3);">
                <h3 style="margin:0 0 12px 0; color:var(--neon-yellow); font-size:16px; font-weight:400; letter-spacing:2px; text-shadow:0 0 8px var(--neon-yellow);"><span id="mainQuestIcon"></span> Main Quest: Fire Class</h3>
                <p style="color:rgba(255,255,255,0.7); margin-bottom:16px; font-size:13px;">Complete 5 quests to <span style="color:var(--neon-red); font-weight:400;">unlock Fire</span>. Complete all 10 to earn a <span style="color:var(--neon-yellow); font-weight:400;">FREE Gold Summon!</span></p>
                
                <div id="fireQuestProgress" style="margin-bottom:16px;">
                    <div style="display:flex; justify-content:space-between; margin-bottom:6px;">
                        <span style="color:rgba(255,255,255,0.6); font-weight:400; letter-spacing:1px;">Overall Progress</span>
                        <span id="fireQuestCount" style="color:var(--neon-green); font-weight:400;">0 / 10</span>
                    </div>
                    <div style="background:transparent; border:1px solid rgba(255,255,0,0.3); border-radius:4px; height:8px; overflow:hidden;">
                        <div id="fireQuestBar" style="height:100%; background:var(--neon-yellow); width:0%; transition:width 0.3s ease; box-shadow:0 0 8px var(--neon-yellow);"></div>
                    </div>
                </div>
                
                <div id="fireQuestList" style="display:flex; flex-direction:column; gap:10px;"></div>

                <div id="fireQuestReward" style="display:none; margin-top:16px; padding:14px; background:transparent; border:1px solid var(--neon-green); border-radius:6px; text-align:center; box-shadow:0 0 15px rgba(0,255,136,0.2);">
                    <p style="color:var(--neon-green); font-weight:400; font-size:16px; margin:0; text-shadow:0 0 8px var(--neon-green);"><span id="questCompleteIcon"></span> All Quests Complete!</p>
                    <p style="color:var(--neon-yellow); margin:8px 0 8px 0; font-size:13px;">Fire class ready to unlock â€” claim your reward below.</p>
                    <button onclick="claimFireFinal()" style="padding:10px 16px; border-radius:4px; background:transparent; border:1px solid var(--neon-yellow); color:var(--neon-yellow); font-weight:400; cursor:pointer; letter-spacing:1px; text-transform:uppercase;">Claim Free Gold Summon</button>
                </div>
                <div id="fireQuestHalfReward" style="display:none; margin-top:12px; padding:10px; background:transparent; border:1px solid var(--neon-cyan); border-radius:6px; text-align:center;">
                    <p style="color:var(--neon-cyan); font-weight:400; margin:0; font-size:13px;">Milestone reached â€” Free Basic Summon available!</p>
                    <div style="margin-top:8px;"><button onclick="claimFireHalf()" style="padding:8px 12px; border-radius:4px; background:transparent; border:1px solid var(--neon-cyan); color:var(--neon-cyan); font-weight:400; cursor:pointer; letter-spacing:1px;">Claim Fire Unlock</button></div>
                </div>
            </div>
            
            <!-- Tycoon Event (separate box) -->
            <div style="background:transparent; border-radius:6px; padding:18px; border:1px solid rgba(255,215,0,0.4); margin-bottom:16px;">
                <h3 style="margin:0 0 8px 0; color:#ffd700; font-weight:400; letter-spacing:2px; text-shadow:0 0 8px #ffd700;"><span id="tycoonEventIcon">ðŸ’°</span> Tycoon Event</h3>
                <p style="color:rgba(255,255,255,0.6); margin:0 0 12px 0; font-size:13px;">Complete tasks to unlock the Tycoon class!</p>
                <div id="tycoonQuestList" style="display:flex; flex-direction:column; gap:8px;"></div>
            </div>

            <!-- Future Events Placeholder -->
            <div style="background:transparent; border-radius:6px; padding:18px; border:1px solid rgba(0,245,255,0.2);">
                <h3 style="margin:0 0 8px 0; color:var(--neon-cyan); font-weight:400; letter-spacing:2px; text-shadow:0 0 8px var(--neon-cyan);"><span id="upcomingEventsIcon"></span> Upcoming Events</h3>
                <p style="color:rgba(255,255,255,0.4); margin:0; font-size:13px;">More events coming soon...</p>
            </div>

            <!-- Events Log (hidden; logging moved to console only) -->
            <div id="eventsLogBox" style="display:none; margin-top:14px; background:transparent; border-radius:6px; padding:12px; border:1px solid rgba(0,245,255,0.1); max-height:160px; overflow:hidden;">
                <h4 style="margin:0 0 8px 0; color:var(--neon-cyan); font-size:12px; letter-spacing:1px;">Event Log</h4>
                <div id="eventsLogList" style="max-height:120px; overflow-y:auto; display:flex; flex-direction:column-reverse; gap:6px; padding-right:6px;"></div>
            </div>
        </div>
    </div>

    <!-- Summon screen: 3D podium + summon animation -->
    <div id="summonScreen" style="display:none; position:fixed; inset:0; background:rgba(5,5,8,0.95); z-index:9999; align-items:center; justify-content:center; padding:20px; box-sizing:border-box; overflow:auto;">
        <div style="width:920px; max-width:95vw; height:680px; max-height:calc(95vh - 40px); background:var(--bg-card); border-radius:8px; padding:18px; position:relative; box-shadow:0 0 40px rgba(0,245,255,0.15); overflow:auto; border:1px solid var(--neon-cyan); backdrop-filter:blur(20px);">
            <div id="summonError" style="display:none; color:var(--neon-red); font-weight:400; text-align:center; padding:8px 12px; border-radius:4px; background:transparent; border:1px solid var(--neon-red); position:absolute; left:18px; right:18px; top:18px; z-index:12;"></div>
            <button onclick="closeSummonScreen()" aria-label="Close summon" style="position:absolute; right:14px; top:14px; background:transparent; border:1px solid var(--neon-red); padding:8px 12px; color:var(--neon-red); border-radius:4px; z-index:20; cursor:pointer; font-size:12px; letter-spacing:1px;">X</button>
            <!-- Summon Tabs -->
            <div id="summonTabs" style="display:flex; gap:8px; margin-bottom:12px;">
                <button id="tabGold" onclick="setSummonTab('gold')" style="flex:1; padding:10px 0; border-radius:4px 4px 0 0; border:1px solid var(--neon-yellow); background:transparent; font-weight:400; font-size:12px; cursor:pointer; color:var(--neon-yellow); letter-spacing:1px; text-transform:uppercase;"><span id="tabGoldIcon"></span> Gold Summon</button>
                <button id="tabBasic" onclick="setSummonTab('basic')" style="flex:1; padding:10px 0; border-radius:4px 4px 0 0; border:1px solid rgba(255,255,255,0.2); background:transparent; font-weight:400; font-size:12px; cursor:pointer; color:rgba(255,255,255,0.5); letter-spacing:1px; text-transform:uppercase;">Basic Summon</button>
            </div>
            <div style="display:flex; gap:18px; height:calc(100% - 56px);">
                <div style="flex:1; display:flex; flex-direction:column; gap:12px; align-items:center; justify-content:center;">
                    <div id="summonCanvasContainer" style="width:100%; height:400px; background:var(--bg-darker); border-radius:6px; overflow:hidden; border:1px solid rgba(0,245,255,0.2);"></div>
                    <div style="display:flex; gap:12px; align-items:center;">
                        <button id="doSummonBtn" onclick="doSummon()" style="background:transparent; border:1px solid var(--neon-magenta); color:var(--neon-magenta); padding:10px 18px; min-width:120px; border-radius:4px; font-weight:400; text-align:center; letter-spacing:1px; text-transform:uppercase; cursor:pointer;">Summon</button>
                        <button id="doSummon10Btn" onclick="doSummonMultiple(10)" style="background:transparent; border:1px solid var(--neon-magenta); color:var(--neon-magenta); padding:10px 18px; min-width:120px; border-radius:4px; font-weight:400; text-align:center; letter-spacing:1px; text-transform:uppercase; cursor:pointer;">Summon x10</button>
                        <div id="summonResult" style="color:#fff; font-weight:400; min-width:260px; text-align:left;"></div>
                    </div>
                </div>
                <div style="width:360px; padding:12px; color:rgba(255,255,255,0.7); overflow:visible;">
                    <div id="summonInfoGold">
                        <h3 style="margin-top:8px; color:var(--neon-yellow); font-weight:400; letter-spacing:2px; text-shadow:0 0 8px var(--neon-yellow);"><span id="goldSummonIcon"></span> Gold Summoning</h3>
                        <p style="color:rgba(255,255,255,0.6); font-size:13px;">Each summon costs <span style="color:var(--neon-yellow); font-weight:400;">2,000 coins</span>.</p>
                        <p style="color:rgba(255,255,255,0.6); margin-top:4px; font-size:13px;">Grants <span style="color:var(--neon-yellow); font-weight:400;">50 shards (75%)</span> or <span style="color:var(--neon-green); font-weight:400;">100 shards (25%)</span> for a random class.</p>
                        <p style="color:var(--neon-cyan); margin-top:6px; font-weight:400; font-size:13px;">First Gold summon is FREE!</p>
                    </div>
                    <div id="summonInfoBasic" style="display:none;">
                        <h3 style="margin-top:8px; color:var(--neon-magenta); font-weight:400; letter-spacing:2px; text-shadow:0 0 8px var(--neon-magenta);">Basic Summoning</h3>
                        <p style="color:rgba(255,255,255,0.6); font-size:13px;">Each summon costs <span style="color:var(--neon-yellow); font-weight:400;">500 coins</span> and grants <span style="color:var(--neon-magenta); font-weight:400;">5-30 shards</span> for a random class.</p>
                    </div>
                    <p style="margin-top:10px; color:rgba(255,255,255,0.5); font-size:12px;">Collect <strong style="color:var(--neon-cyan);">100 shards</strong> to unlock a class.</p>
                    <h4 style="margin-top:16px; color:var(--neon-cyan); font-weight:400; letter-spacing:1px;">Shard Progress</h4>
                    <div id="shardProgressList" style="max-height:250px; overflow-y:auto;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // ========== LOADING SCREEN MANAGER ==========
        const LoadingManager = {
            progress: 0,
            steps: 0,
            totalSteps: 5, // Adjust based on initialization steps
            bar: null,
            text: null,
            screen: null,
            
            init() {
                this.bar = document.getElementById('loadingBar');
                this.text = document.getElementById('loadingText');
                this.screen = document.getElementById('loadingScreen');
            },
            
            setStatus(message) {
                if (this.text) this.text.textContent = message;
            },
            
            advance(message) {
                this.steps++;
                this.progress = Math.min(100, Math.round((this.steps / this.totalSteps) * 100));
                if (this.bar) this.bar.style.width = this.progress + '%';
                if (message) this.setStatus(message);
            },
            
            complete() {
                this.progress = 100;
                if (this.bar) this.bar.style.width = '100%';
                this.setStatus('Ready!');
                setTimeout(() => {
                    if (this.screen) this.screen.classList.add('hidden');
                }, 300);
            }
        };
        // In-run Tycoon tiers (applies to spawned tycoons as they level during a run)
        const tycoonTiers = [
            { level: 10, buffs: ['+10% movement speed'] },
            { level: 50, buffs: ['Q Dash: Now deals damage to enemies in path'] },
            { level: 100, buffs: ['Tycoon coins DOUBLED'] },
            { level: 250, buffs: ['Q Dash: +50% range, +50% damage, +50% duration'] },
            { level: 500, buffs: ['+15% movement speed', 'Q Dash: Invincibility after use', 'Q Dash: Inflicts burn'] },
            { level: 1000, buffs: ['Tycoon coins TRIPLED', 'R Stab: Damage scales with enemy HP (boss killer)'] },
            { level: 2500, buffs: ['Tycoon: Gains damage barrier (blocks melee enemies)'] },
            { level: 5000, buffs: ['R & Q: +100% damage', '+50 max HP', '+100% movement speed', 'Tycoon barrier: Upgraded to laser (kills ranged)'] }
        ];
        
        // Initialize loading manager immediately
        LoadingManager.init();
        LoadingManager.setStatus('Loading scripts...');
        
        // Check if Three.js loaded successfully
        if (typeof THREE !== 'undefined') {
            LoadingManager.advance('3D engine loaded...');
        }
        
        // ========== HP MANAGER ==========
        class HPManager {
            constructor(entity, maxHp) {
                this.entity = entity;
                this.maxHp = maxHp;
                this.currentHp = maxHp;
                
                this.hpBar = document.getElementById('hpBar');
                this.hpText = document.getElementById('hpText');
                
                this.updateUI();
            }
            
            damage(amount) {
                this.currentHp = Math.max(0, this.currentHp - amount);
                this.updateUI();
                this.flashRed();
            }
            
            heal(amount) {
                this.currentHp = Math.min(this.maxHp, this.currentHp + amount);
                this.updateUI();
            }
            
            updateUI() {
                const percentage = (this.currentHp / this.maxHp) * 100;
                this.hpBar.style.width = percentage + '%';
                this.hpText.textContent = `${Math.ceil(this.currentHp)} / ${this.maxHp}`;
                
                if (percentage > 60) {
                    this.hpBar.style.background = 'linear-gradient(90deg, #4ade80 0%, #22c55e 100%)';
                } else if (percentage > 30) {
                    this.hpBar.style.background = 'linear-gradient(90deg, #fbbf24 0%, #f59e0b 100%)';
                } else {
                    this.hpBar.style.background = 'linear-gradient(90deg, #ff3b3b 0%, #dc2626 100%)';
                }
            }
            
            flashRed() {
                const originalColor = this.entity.material.color.getHex();
                this.entity.material.color.setHex(0xff0000);
                
                setTimeout(() => {
                    this.entity.material.color.setHex(originalColor);
                }, 100);
            }
            
            isDead() {
                return this.currentHp <= 0;
            }
            
            reset() {
                this.currentHp = this.maxHp;
                this.updateUI();
            }

            // Accessors for dev utilities
            getHP() { return this.currentHp; }
            getMaxHP() { return this.maxHp; }
        }

        // ========== EFFECTS MANAGER ==========
        class EffectsManager {
            constructor(scene) {
                this.scene = scene;
                this.effects = [];
            }
            
            createLightningBolt(start, end) {
                const points = [];
                const segments = 8;
                
                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const x = start.x + (end.x - start.x) * t + (Math.random() - 0.5) * 0.3;
                    const y = start.y + (end.y - start.y) * t + (Math.random() - 0.5) * 0.3;
                    const z = start.z + (end.z - start.z) * t;
                    points.push(new THREE.Vector3(x, y, z));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x00f5ff, linewidth: 3 });
                const lightning = new THREE.Line(geometry, material);
                
                this.scene.add(lightning);
                setTimeout(() => this.scene.remove(lightning), 150);
            }
            
            createFireball(position, direction, speed) {
                const geometry = new THREE.SphereGeometry(0.3, 16, 16);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0x0a0a12, emissive: 0xff6600, emissiveIntensity: 0.8 
                });
                const fireball = new THREE.Mesh(geometry, material);
                
                fireball.position.copy(position);
                fireball.userData.direction = direction;
                fireball.userData.speed = speed;
                fireball.userData.trail = [];
                
                const glowGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.2 });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                fireball.add(glow);
                
                this.scene.add(fireball);
                return fireball;
            }
            
            createProjectileTrail(position, color) {
                const geometry = new THREE.SphereGeometry(0.15, 8, 8);
                const material = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.5 });
                const trail = new THREE.Mesh(geometry, material);
                trail.position.copy(position);
                trail.userData = { lifetime: 300, created: Date.now() };
                
                this.scene.add(trail);
                this.effects.push({ type: 'trail', trail });
            }
            
            createWave(position, radius) {
                const geometry = new THREE.RingGeometry(0.5, radius, 32);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x00f5ff, transparent: true, opacity: 0.6, side: THREE.DoubleSide 
                });
                const wave = new THREE.Mesh(geometry, material);
                wave.position.copy(position);
                this.scene.add(wave);
                
                const startTime = Date.now();
                const duration = 500;
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = elapsed / duration;
                    if (progress < 1) {
                        wave.scale.set(1 + progress * 2, 1 + progress * 2, 1);
                        wave.material.opacity = 0.7 * (1 - progress);
                        requestAnimationFrame(animate);
                    } else {
                        this.scene.remove(wave);
                    }
                };
                animate();
            }
            
            createReverseWave(position, radius) {
                const geometry = new THREE.RingGeometry(0.5, radius, 32);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x00bfff, transparent: true, opacity: 0.7, side: THREE.DoubleSide 
                });
                const wave = new THREE.Mesh(geometry, material);
                wave.position.copy(position);
                wave.scale.set(3, 3, 1);
                this.scene.add(wave);
                
                const startTime = Date.now();
                const duration = 500;
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = elapsed / duration;
                    if (progress < 1) {
                        wave.scale.set(3 - progress * 2, 3 - progress * 2, 1);
                        wave.material.opacity = 0.7 * (1 - progress);
                        requestAnimationFrame(animate);
                    } else {
                        this.scene.remove(wave);
                    }
                };
                animate();
            }
            
            createExplosion(position, color) {
                const particles = [];
                for (let i = 0; i < 12; i++) {
                    const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                    const material = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.copy(position);
                    
                    const angle = (i / 12) * Math.PI * 2;
                    const speed = 0.1 + Math.random() * 0.1;
                    particle.userData = {
                        velocity: new THREE.Vector3(Math.cos(angle) * speed, Math.sin(angle) * speed, 0),
                        lifetime: 500,
                        created: Date.now()
                    };
                    
                    this.scene.add(particle);
                    particles.push(particle);
                }
                this.effects.push({ type: 'particles', particles });
            }
            
            createDeathExplosion(position, color) {
                const particles = [];
                const ringGeometry = new THREE.RingGeometry(0.1, 2, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(position);
                this.scene.add(ring);
                
                const ringStart = Date.now();
                const animateRing = () => {
                    const elapsed = Date.now() - ringStart;
                    const progress = elapsed / 400;
                    if (progress < 1) {
                        ring.scale.set(1 + progress * 2, 1 + progress * 2, 1);
                        ring.material.opacity = 0.8 * (1 - progress);
                        requestAnimationFrame(animateRing);
                    } else {
                        this.scene.remove(ring);
                    }
                };
                animateRing();
                
                for (let i = 0; i < 24; i++) {
                    const size = 0.15 + Math.random() * 0.15;
                    const geometry = new THREE.SphereGeometry(size, 8, 8);
                    const material = new THREE.MeshStandardMaterial({ 
                        color: color, emissive: color, emissiveIntensity: 0.8, transparent: true, opacity: 1 
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.copy(position);
                    
                    const angle = (i / 24) * Math.PI * 2;
                    const speed = 0.15 + Math.random() * 0.15;
                    particle.userData = {
                        velocity: new THREE.Vector3(Math.cos(angle) * speed, Math.sin(angle) * speed, (Math.random() - 0.5) * 0.1),
                        rotationSpeed: (Math.random() - 0.5) * 0.3,
                        lifetime: 600,
                        created: Date.now()
                    };
                    
                    this.scene.add(particle);
                    particles.push(particle);
                }
                this.effects.push({ type: 'particles', particles });
            }
            
            createClassEffect(position, className) {
                const effects = {
                    electric: { color: 0xffff00 }, fire: { color: 0xff6600 }, pierce: { color: 0x8b4513 },
                    engineer: { color: 0xffa500 }, life: { color: 0xff0000 }, summoner: { color: 0x9333ea },
                    water: { color: 0x00bfff }
                };
                const effect = effects[className];
                if (!effect) return;
                
                const auraGeometry = new THREE.RingGeometry(1, 1.5, 32);
                const auraMaterial = new THREE.MeshBasicMaterial({ color: effect.color, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
                const aura = new THREE.Mesh(auraGeometry, auraMaterial);
                aura.position.copy(position);
                this.scene.add(aura);
                
                const startTime = Date.now();
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = elapsed / 800;
                    if (progress < 1) {
                        aura.scale.set(1 + progress, 1 + progress, 1);
                        aura.material.opacity = 0.5 * (1 - progress);
                        aura.rotation.z += 0.05;
                        requestAnimationFrame(animate);
                    } else {
                        this.scene.remove(aura);
                    }
                };
                animate();
            }
            
            createDamageNumber(position, damage) {
                const canvas = document.createElement('canvas');
                canvas.width = 128; canvas.height = 64;
                const context = canvas.getContext('2d');
                context.font = 'Bold 40px Arial';
                context.fillStyle = 'white';
                context.strokeStyle = 'black';
                context.lineWidth = 3;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                const text = Math.floor(damage).toString();
                context.strokeText(text, 64, 32);
                context.fillText(text, 64, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(material);
                sprite.position.copy(position);
                sprite.position.y += 0.5;
                sprite.scale.set(1, 0.5, 1);
                sprite.userData = { lifetime: 1000, created: Date.now(), velocity: new THREE.Vector3(0, 0.02, 0) };
                
                this.scene.add(sprite);
                this.effects.push({ type: 'sprite', sprite });
            }
            
            update() {
                const now = Date.now();
                for (let i = this.effects.length - 1; i >= 0; i--) {
                    const effect = this.effects[i];
                    if (effect.type === 'particles') {
                        let allExpired = true;
                        effect.particles.forEach(particle => {
                            if (now - particle.userData.created < particle.userData.lifetime) {
                                allExpired = false;
                                particle.position.add(particle.userData.velocity);
                                particle.userData.velocity.multiplyScalar(0.95);
                                if (particle.userData.rotationSpeed) {
                                    particle.rotation.x += particle.userData.rotationSpeed;
                                    particle.rotation.y += particle.userData.rotationSpeed * 0.7;
                                }
                                const progress = (now - particle.userData.created) / particle.userData.lifetime;
                                particle.material.opacity = 1 - progress;
                            }
                        });
                        if (allExpired) {
                            effect.particles.forEach(p => this.scene.remove(p));
                            this.effects.splice(i, 1);
                        }
                    } else if (effect.type === 'sprite') {
                        const sprite = effect.sprite;
                        const elapsed = now - sprite.userData.created;
                        if (elapsed < sprite.userData.lifetime) {
                            sprite.position.add(sprite.userData.velocity);
                            sprite.material.opacity = 1 - (elapsed / sprite.userData.lifetime);
                        } else {
                            this.scene.remove(sprite);
                            this.effects.splice(i, 1);
                        }
                    } else if (effect.type === 'trail') {
                        const trail = effect.trail;
                        const elapsed = now - trail.userData.created;
                        if (elapsed < trail.userData.lifetime) {
                            const progress = elapsed / trail.userData.lifetime;
                            trail.material.opacity = 0.6 * (1 - progress);
                            trail.scale.setScalar(1 - progress * 0.5);
                        } else {
                            this.scene.remove(trail);
                            this.effects.splice(i, 1);
                        }
                    }
                }
            }
        }

        // ========== MOVEMENT MANAGER ==========
        class MovementManager {
            constructor(entity, speed) {
                this.entity = entity;
                this.speed = speed;
                this.keys = { w: false, a: false, s: false, d: false, ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
                this.lastMovement = { x: 0, y: 1 }; // Default facing up (normalized direction)
                this.joystick = { x: 0, y: 0 };
                this.joystickActive = false;
                
                const viewHeight = window.innerHeight / 40;
                const viewWidth = window.innerWidth / 40;
                this.bounds = { minX: -viewWidth + 1, maxX: viewWidth - 1, minY: -viewHeight + 1, maxY: viewHeight - 1 };
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                window.addEventListener('keydown', (e) => {
                    const key = (e.key || '').toLowerCase();
                    if (this.keys.hasOwnProperty(key)) this.keys[key] = true;
                    if (e.key && this.keys.hasOwnProperty(e.key)) this.keys[e.key] = true;
                });
                window.addEventListener('keyup', (e) => {
                    const key = (e.key || '').toLowerCase();
                    if (this.keys.hasOwnProperty(key)) this.keys[key] = false;
                    if (e.key && this.keys.hasOwnProperty(e.key)) this.keys[e.key] = false;
                });
            }

            setJoystick(x, y) {
                this.joystick.x = x;
                this.joystick.y = y;
                this.joystickActive = (Math.abs(x) > 0.001 || Math.abs(y) > 0.001);
            }

            clearJoystick() {
                this.joystick.x = 0; this.joystick.y = 0; this.joystickActive = false;
            }
            
            update() {
                let moveX = 0, moveY = 0;

                // Respect any temporary movement speed multiplier on the entity
                const speedMultiplier = (this.entity && this.entity.userData && this.entity.userData.moveSpeedMultiplier) ? this.entity.userData.moveSpeedMultiplier : 1;
                const effectiveSpeed = this.speed * speedMultiplier;

                // If joystick active, prefer it over keyboard keys
                if (this.joystickActive) {
                    moveX = this.joystick.x * effectiveSpeed;
                    moveY = this.joystick.y * effectiveSpeed;
                } else {
                    if (this.keys.w || this.keys.ArrowUp) moveY += effectiveSpeed;
                    if (this.keys.s || this.keys.ArrowDown) moveY -= effectiveSpeed;
                    if (this.keys.a || this.keys.ArrowLeft) moveX -= effectiveSpeed;
                    if (this.keys.d || this.keys.ArrowRight) moveX += effectiveSpeed;
                }

                // Store normalized direction before applying speed
                let dirX = 0, dirY = 0;
                if (this.joystickActive) {
                    dirX = this.joystick.x; dirY = this.joystick.y;
                } else {
                    if (this.keys.w || this.keys.ArrowUp) dirY += 1;
                    if (this.keys.s || this.keys.ArrowDown) dirY -= 1;
                    if (this.keys.a || this.keys.ArrowLeft) dirX -= 1;
                    if (this.keys.d || this.keys.ArrowRight) dirX += 1;
                }

                // Normalize direction
                if (dirX !== 0 || dirY !== 0) {
                    const length = Math.sqrt(dirX * dirX + dirY * dirY);
                    dirX /= length;
                    dirY /= length;
                    this.lastMovement = { x: dirX, y: dirY };
                }

                if (moveX !== 0 && moveY !== 0) {
                    const length = Math.sqrt(moveX * moveX + moveY * moveY);
                    moveX /= length; moveY /= length;
                    moveX *= effectiveSpeed; moveY *= effectiveSpeed;
                }

                let newX = this.entity.position.x + moveX;
                let newY = this.entity.position.y + moveY;
                try {
                    const cur = this.entity.position.clone();
                    const nxt = new THREE.Vector3(newX, newY, 0);
                    preventFurtherIntoBorder(cur, nxt);
                    newX = nxt.x; newY = nxt.y;
                } catch (e) { /* ignore */ }

                // Helper: check whether moving to (x,y) would put player within any enemy's damaging range
                const wouldBeInDanger = (x, y) => {
                    try {
                        const pr = (this.entity.userData && this.entity.userData.collisionRadius) ? this.entity.userData.collisionRadius : 0.9;
                        if (!window.gameState || !Array.isArray(window.gameState.enemies)) return false;
                        for (const enemy of window.gameState.enemies) {
                            if (!enemy || !enemy.userData) continue;
                            const er = (enemy.userData.attackRange != null) ? enemy.userData.attackRange : 1.5;
                            const ec = (enemy.userData.collisionRadius != null) ? enemy.userData.collisionRadius : 0.8;
                            const dx = enemy.position.x - x;
                            const dy = enemy.position.y - y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist <= (er + ec + pr)) return true;
                        }
                    } catch (e) { /* ignore errors */ }
                    return false;
                };

                // Apply axis-limited movement if safe
                if (newX >= this.bounds.minX && newX <= this.bounds.maxX) {
                    if (!wouldBeInDanger(newX, this.entity.position.y)) this.entity.position.x = newX;
                }
                if (newY >= this.bounds.minY && newY <= this.bounds.maxY) {
                    if (!wouldBeInDanger(this.entity.position.x, newY)) this.entity.position.y = newY;
                }

                if (moveX !== 0 || moveY !== 0) {
                    const targetRotation = Math.atan2(moveY, moveX) - Math.PI / 2;
                    let rotDiff = targetRotation - this.entity.rotation.z;
                    while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                    while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                    this.entity.rotation.z += rotDiff * 0.15;
                }
            }
            
            getLastMovement() {
                return this.lastMovement;
            }
            
            updateBounds() {
                const viewHeight = window.innerHeight / 40;
                const viewWidth = window.innerWidth / 40;
                this.bounds = { minX: -viewWidth + 1, maxX: viewWidth - 1, minY: -viewHeight + 1, maxY: viewHeight - 1 };
            }
        }
        // ==================== SERVER WAKE-UP ====================
        const API_BASE = 'https://twilight-lake-7d12.offshore-unk.workers.dev';
        let serverReady = false;
        
        async function startServerWake() {
            const statusEl = document.getElementById('wakeStatus');
            const progressBar = document.getElementById('wakeProgressBar');
            const tipEl = document.getElementById('wakeTip');
            const retryBtn = document.getElementById('wakeRetryBtn');
            
            retryBtn.style.display = 'none';
            statusEl.textContent = 'Connecting to server...';
            tipEl.textContent = 'Free servers sleep after inactivity. Waking up usually takes 10-30 seconds.';
            
            let progress = 0;
            const progressInterval = setInterval(() => {
                progress = Math.min(progress + 2, 90);
                progressBar.style.width = progress + '%';
            }, 500);
            
            const maxAttempts = 20;
            let attempts = 0;
            
            while (attempts < maxAttempts && !serverReady) {
                attempts++;
                statusEl.textContent = `Waking up server... (attempt ${attempts}/${maxAttempts})`;
                
                try {
                    const controller = new AbortController();
                    const timeout = setTimeout(() => controller.abort(), 8000);
                    
                    // Use no-cors mode to avoid CORS blocks from null/blob origins
                    // We can't read the response, but a successful fetch means server is up
                    const res = await fetch(`${API_BASE}/api/health`, {
                        signal: controller.signal,
                        mode: 'no-cors'
                    });
                    clearTimeout(timeout);
                    
                    // With no-cors, res.type is 'opaque' and res.ok is false, but no exception means success
                    if (res.type === 'opaque' || res.ok) {
                        serverReady = true;
                        clearInterval(progressInterval);
                        progressBar.style.width = '100%';
                        statusEl.textContent = 'Server ready!';
                        
                        setTimeout(() => {
                            document.getElementById('serverWakeScreen').classList.add('hidden');
                        }, 500);
                        return;
                    }
                } catch (e) {
                    // Server still waking up
                }
                
                await new Promise(r => setTimeout(r, 2000));
            }
            
            clearInterval(progressInterval);
            statusEl.textContent = 'Server is taking longer than usual...';
            tipEl.textContent = 'The server might be under heavy load. Click retry to try again.';
            retryBtn.style.display = 'block';
        }
        
        // Start wake-up on page load
        startServerWake();

        // Global corner logout removed; server logout handled via auth-area when needed

        // ==================== API & AUTH CONFIGURATION ====================
        let currentUser = null;
        let isGuest = false;
        // When true, run in offline mode (don't attempt cloud saves/loads)
        let offlineMode = false;
        
        // Auth tab switching
        function showAuthTab(tab) {
            document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.auth-form').forEach(f => f.classList.remove('active'));
            document.querySelector(`.auth-tab:nth-child(${tab === 'login' ? 1 : 2})`).classList.add('active');
            document.getElementById(tab === 'login' ? 'loginForm' : 'registerForm').classList.add('active');
            document.getElementById('authError').classList.remove('visible');
        }
        
        function showAuthError(msg) {
            const el = document.getElementById('authError');
            el.textContent = msg;
            el.classList.add('visible');
        }
        
        async function doLogin() {
            const username = document.getElementById('loginUsername').value.trim();
            const password = document.getElementById('loginPassword').value;
            
            if (!username || !password) {
                showAuthError('Please fill in all fields');
                return;
            }
            
            try {
                const res = await fetch(`${API_BASE}/api/game/auth/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ username, password })
                });
                const data = await res.json();
                
                if (data.success) {
                    currentUser = {
                        id: data.user_id,
                        username: data.username,
                        display_name: data.display_name
                    };
                    isGuest = false;
                    onAuthSuccess();
                } else {
                    showAuthError(data.error || 'Login failed');
                }
            } catch (err) {
                showAuthError('Connection error. Please try again.');
            }
        }
        
        async function doRegister() {
            const username = (document.getElementById('regUsername') && document.getElementById('regUsername').value) ? document.getElementById('regUsername').value.trim() : '';
            const displayName = (document.getElementById('regDisplayName') && document.getElementById('regDisplayName').value) ? document.getElementById('regDisplayName').value.trim() : '';
            const emailEl = document.getElementById('regEmail');
            const email = emailEl ? (emailEl.value || '').trim() : '';
            const password = (document.getElementById('regPassword') && document.getElementById('regPassword').value) ? document.getElementById('regPassword').value : '';
            
            if (!username || !displayName || !password) {
                showAuthError('Please fill in username, display name, and password');
                return;
            }
            
            try {
                const res = await fetch(`${API_BASE}/api/game/auth/register`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ username, display_name: displayName, password })
                });
                const data = await res.json();
                
                if (data.success) {
                    currentUser = {
                        id: data.user_id,
                        username: data.username,
                        display_name: data.display_name
                    };
                    isGuest = false;
                    onAuthSuccess();
                } else {
                    showAuthError(data.error || 'Registration failed');
                }
            } catch (err) {
                showAuthError('Connection error. Please try again.');
            }
        }
        
        function playAsGuest() {
            currentUser = null;
            isGuest = true;
            onAuthSuccess();
        }
        
        // Play offline - skip wake-up and auth, use localStorage only
        function playOffline() {
            document.getElementById('serverWakeScreen').classList.add('hidden');
            document.getElementById('authScreen').classList.add('hidden');
            document.getElementById('userInfo').classList.add('hidden');
            currentUser = null;
            isGuest = true;
            offlineMode = true;
            // Load from localStorage if available
            try {
                const USE_LOCAL_SAVE = false; // set false to honor user's preference to avoid local saves
                const saved = localStorage.getItem('shapebattles_save');
                if (USE_LOCAL_SAVE) {
                    if (saved) {
                        const data = JSON.parse(saved);
                        if (data.coins !== undefined) gameState.coins = data.coins;
                        if (data.highestWaveReached !== undefined) gameState.highestWaveReached = data.highestWaveReached;
                        if (data.unlockedClasses) unlockedClasses = Array.isArray(data.unlockedClasses) ? data.unlockedClasses : Array.from(data.unlockedClasses || []);
                        if (data.classShards) classShards = data.classShards;
                        if (data.classLevels) classLevels = data.classLevels;
                        console.log('Loaded offline save from localStorage');
                    }
                } else {
                    console.log('Skipping local save load because USE_LOCAL_SAVE=false');
                }
            } catch (e) { console.warn('Could not load offline save:', e); }
            // Show home screen
            document.getElementById('homeScreen').style.display = 'flex';
        }
        
        function doLogout() {
            currentUser = null;
            isGuest = false;
            offlineMode = false;
            document.getElementById('authScreen').classList.remove('hidden');
            document.getElementById('userInfo').classList.add('hidden');
            document.getElementById('homeScreen').style.display = 'none';
            // hide global logout button
            try{ const lb = document.getElementById('logoutBtn'); if(lb) lb.style.display = 'none'; }catch(e){}
        }
        
        function onAuthSuccess() {
            document.getElementById('authScreen').classList.add('hidden');
            if (currentUser) {
                document.getElementById('userDisplayName').textContent = currentUser.display_name;
                document.getElementById('userInfo').classList.remove('hidden');
                // show global logout button when authenticated
                try{ const lb = document.getElementById('logoutBtn'); if(lb) lb.style.display = 'inline-block'; }catch(e){}
                // Ensure miner login quest is recorded for authenticated users (avoid double-award)
                try {
                    const key = 'minerLoginClaimed';
                    if (!localStorage.getItem(key)) {
                        localStorage.setItem(key, '1');
                        try { if (typeof trackQuestProgress === 'function') trackQuestProgress('loggedIn', 1); } catch(e){}
                    } else {
                        // ensure UI shows the login stat as available
                        try { questStats.loggedIn = Math.max(questStats.loggedIn || 0, 1); } catch(e){}
                        try { if (typeof tycoonQuests !== 'undefined' && tycoonQuests[0]) tycoonQuests[0].claimable = true; } catch(e){}
                    }
                    try { if (typeof updateTycoonQuestUI === 'function') updateTycoonQuestUI(); } catch(e){}
                    try { saveQuestState(); } catch(e){}
                } catch (e) {}
            } else {
                document.getElementById('userInfo').classList.add('hidden');
                try{ const lb = document.getElementById('logoutBtn'); if(lb) lb.style.display = 'none'; }catch(e){}
            }
            // Load game save if logged in
            if (currentUser && !isGuest) {
                loadGameFromServer();
            }
        }
        
        // ==================== CLOUD SAVE FUNCTIONS ====================
        function buildSaveData() {
            return {
                coins: gameState.coins,
                highestWaveReached: gameState.highestWaveReached,
                totalKills: questStats.totalKills || 0,
                unlockedClasses: Array.isArray(unlockedClasses) ? unlockedClasses : Array.from(unlockedClasses || []),
                classShards: classShards,
                classLevels: classLevels,
                classExp: classExp,
                questStats: questStats,
                freeBasicSummons: gameState.freeBasicSummons || 0,
                freeGoldSummons: gameState.freeGoldSummons || 0,
                firstSummonDone: firstSummonDone
            };
        }
        
        // Save to localStorage (always, for offline backup)
        function saveToLocalStorage() {
            try {
                localStorage.setItem('shapebattles_save', JSON.stringify(buildSaveData()));
            } catch (e) { console.warn('Could not save to localStorage:', e); }
        }
        
        async function saveGameToServer() {
            // Always save to localStorage as backup
            saveToLocalStorage();
            // If running explicitly in offline mode, skip cloud save entirely
            if (offlineMode) { console.log('[Save] Offline mode active - skipping cloud save'); return; }

            if (!currentUser || isGuest) return;
            
            try {
                await fetch(`${API_BASE}/api/game/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        user_id: currentUser.id,
                        game_data: buildSaveData()
                    })
                });
                console.log('Game saved to cloud');
            } catch (err) {
                console.error('Failed to save game:', err);
            }
        }
        
        async function loadGameFromServer() {
            if (!currentUser || isGuest) return;
            
            try {
                const res = await fetch(`${API_BASE}/api/game/load?user_id=${currentUser.id}`, {
                    credentials: 'include'
                });
                const data = await res.json();
                
                if (data.success && data.game_data) {
                    const save = data.game_data;
                    
                    // Restore game state
                    if (save.coins !== undefined) gameState.coins = save.coins;
                    if (save.highestWaveReached !== undefined) gameState.highestWaveReached = save.highestWaveReached;
                    if (save.unlockedClasses) unlockedClasses = save.unlockedClasses;
                    if (save.classShards) classShards = Object.assign(classShards, save.classShards);
                    if (save.classLevels) classLevels = Object.assign(classLevels, save.classLevels);
                    if (save.classExp) classExp = Object.assign(classExp, save.classExp);
                    if (save.questStats) questStats = Object.assign(questStats, save.questStats);
                    if (save.freeBasicSummons !== undefined) gameState.freeBasicSummons = save.freeBasicSummons;
                    if (save.freeGoldSummons !== undefined) gameState.freeGoldSummons = save.freeGoldSummons;
                    if (save.firstSummonDone !== undefined) firstSummonDone = save.firstSummonDone;
                    
                    // Update UI
                    updateCoinDisplay();
                    updateClassCardLockState();
                    updateAllExpBars();
                    console.log('Game loaded from cloud');
                }
            } catch (err) {
                console.error('Failed to load game:', err);
            }
        }
        
        // Debounced save - triggers save after data changes with 2 second delay
        let saveTimeout = null;
        function triggerSave() {
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                if (offlineMode) {
                    // In offline mode, only persist locally
                    saveToLocalStorage();
                    console.log('[Save] OfflineMode: saved to localStorage only');
                } else {
                    saveGameToServer(); // This saves to localStorage, and to cloud if logged in
                }
            }, 2000); // 2 second debounce
        }
        
        // Immediate save for critical changes (class unlocks, purchases)
        function triggerImmediateSave() {
            if (saveTimeout) clearTimeout(saveTimeout);
            if (offlineMode) {
                saveToLocalStorage();
                console.log('[Save] OfflineMode: immediate save to localStorage only');
            } else {
                saveGameToServer(); // This saves to localStorage, and to cloud if logged in
            }
        }
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050508);
        
        const camera = new THREE.OrthographicCamera(
            window.innerWidth / -40,
            window.innerWidth / 40,
            window.innerHeight / 40,
            window.innerHeight / -40,
            0.1,
            1000
        );
        camera.position.set(0, 0, 20);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Ensure correct color space for canvas textures
        try { renderer.outputEncoding = THREE.sRGBEncoding; } catch (e) {}
        document.body.appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 5, 10);
        scene.add(directionalLight);
        
        // Class unlock order (start with electric unlocked)
        const classOrder = ['electric', 'fire', 'pierce', 'engineer', 'life', 'summoner', 'water', 'miner', 'thief', 'tycoon', 'trapper', 'fighter'];
        const CLASS_UNLOCK_COST = 10000; // 10K coins per class (legacy, still used for direct unlock button)
        const SHARD_SUMMON_COST = 500; // Much cheaper shard summon
        const SHARDS_TO_UNLOCK = 100; // Need 100 shards to unlock a class

        // Shard tracking per class (0-100) - session only, no persistence
        let classShards = {};
        let firstSummonDone = false;
        let currentSummonTab = 'gold'; // 'gold' or 'basic'
        const GOLD_SUMMON_COST = 2000;
        // Initialize shards for all classes
        classOrder.forEach(c => { classShards[c] = 0; });

        // ========== FIRE QUEST SYSTEM ==========
        // Fire is excluded from normal summons and unlocked via quests only
        const fireQuests = [
            { id: 1, title: 'First Steps', description: 'Kill 10 enemies', target: 10, stat: 'totalKills', completed: false },
            { id: 2, title: 'Survivor', description: 'Reach Wave 3', target: 3, stat: 'highestWave', completed: false },
            { id: 3, title: 'Coin Collector', description: 'Earn 500 coins total', target: 500, stat: 'totalCoinsEarned', completed: false },
            { id: 4, title: 'Wave Crusher', description: 'Reach Wave 5', target: 5, stat: 'highestWave', completed: false },
            { id: 5, title: 'Slayer', description: 'Kill 50 enemies', target: 50, stat: 'totalKills', completed: false },
            { id: 6, title: 'Boss Hunter', description: 'Kill 3 bosses', target: 3, stat: 'bossKills', completed: false },
            { id: 7, title: 'Wealthy', description: 'Earn 2000 coins total', target: 2000, stat: 'totalCoinsEarned', completed: false },
            { id: 8, title: 'Veteran', description: 'Reach Wave 10', target: 10, stat: 'highestWave', completed: false },
            { id: 9, title: 'Exterminator', description: 'Kill 200 enemies', target: 200, stat: 'totalKills', completed: false },
            { id: 10, title: 'Champion', description: 'Reach Wave 15', target: 15, stat: 'highestWave', completed: false }
        ];
        // Tycoon event quests
        const tycoonQuests = [
            { id: 1, title: 'Welcome Back', description: 'Login to the game', target: 1, stat: 'loggedIn', completed: false, reward: 50 },
            { id: 2, title: 'First Run', description: 'Play a game', target: 1, stat: 'gamesPlayed', completed: false, reward: 25 },
            { id: 3, title: 'Coin Collector', description: 'Earn 500 coins total', target: 500, stat: 'totalCoinsEarned', completed: false, reward: 25 }
        ];
        // Quest stats tracking
        let questStats = {
            totalKills: 0,
            highestWave: 0,
            gamesPlayed: 0,
            loggedIn: 0,
            totalCoinsEarned: 0,
            bossKills: 0
        };
        let fireQuestRewardClaimed = false;
        let freeGoldSummonAwarded = false;
        let fireQuestHalfRewardClaimed = false; // awarded at 5 quests: free basic summon

        // ========== SVG ICON HELPERS ==========
        function getFireSVG(color = '#ef4444', size = 18) {
            return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" style="vertical-align:middle; display:inline-block;"><path d="M12 23c-4.97 0-9-3.58-9-8 0-3.19 2.13-6.08 4-8 .35 2.5 2 4 4 4-.5-3 1-6 3-8 1 2 2.5 4 2.5 7 2-1 3-3 3-5 2.5 2.5 4.5 5.5 4.5 10 0 4.42-4.03 8-9 8h-3z" fill="${color}"/><ellipse cx="12" cy="17" rx="3" ry="4" fill="#fbbf24"/></svg>`;
        }
        function getStarSVG(color = '#ffd700', size = 18) {
            return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="${color}" style="vertical-align:middle; display:inline-block;"><polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"/></svg>`;
        }
        function getTargetSVG(color = '#f97316', size = 18) {
            return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="${color}" stroke-width="2" style="vertical-align:middle; display:inline-block;"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2" fill="${color}"/></svg>`;
        }
        function getPartySVG(color = '#4ade80', size = 18) {
            return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="${color}" style="vertical-align:middle; display:inline-block;"><path d="M4.5 21.5l3-9 6 6-9 3zm6.5-12.5a3 3 0 1 1 6 0 3 3 0 0 1-6 0zm6.5 1.5l2.5-5 1 4-4 1z"/><circle cx="6" cy="6" r="1.5"/><circle cx="18" cy="18" r="1"/></svg>`;
        }
        function getCalendarSVG(color = '#a78bfa', size = 18) {
            return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="${color}" stroke-width="2" style="vertical-align:middle; display:inline-block;"><rect x="3" y="4" width="18" height="18" rx="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>`;
        }
        function getCheckSVG(color = '#4ade80', size = 16) {
            return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="${color}" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:middle; display:inline-block;"><polyline points="20 6 9 17 4 12"/></svg>`;
        }
        function getCloseSVG(color = '#fff', size = 14) {
            return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="${color}" stroke-width="3" stroke-linecap="round" style="vertical-align:middle; display:inline-block;"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>`;
        }

        function setSummonTab(tab) {
            currentSummonTab = tab;
            const tabGold = document.getElementById('tabGold');
            const tabBasic = document.getElementById('tabBasic');
            const infoGold = document.getElementById('summonInfoGold');
            const infoBasic = document.getElementById('summonInfoBasic');
            if (tab === 'gold') {
                tabGold.style.background = 'rgba(255,255,0,0.1)';
                tabGold.style.borderColor = 'var(--neon-yellow)';
                tabGold.style.color = 'var(--neon-yellow)';
                tabGold.style.boxShadow = '0 0 10px rgba(255,255,0,0.2)';
                tabBasic.style.background = 'transparent';
                tabBasic.style.borderColor = 'rgba(255,255,255,0.2)';
                tabBasic.style.color = 'rgba(255,255,255,0.5)';
                tabBasic.style.boxShadow = 'none';
                if (infoGold) infoGold.style.display = 'block';
                if (infoBasic) infoBasic.style.display = 'none';
            } else {
                tabBasic.style.background = 'rgba(255,0,255,0.1)';
                tabBasic.style.borderColor = 'var(--neon-magenta)';
                tabBasic.style.color = 'var(--neon-magenta)';
                tabBasic.style.boxShadow = '0 0 10px rgba(255,0,255,0.2)';
                tabGold.style.background = 'transparent';
                tabGold.style.borderColor = 'rgba(255,255,255,0.2)';
                tabGold.style.color = 'rgba(255,255,255,0.5)';
                tabGold.style.boxShadow = 'none';
                if (infoGold) infoGold.style.display = 'none';
                if (infoBasic) infoBasic.style.display = 'block';
            }
            updateSummonButtons();
        }

        function saveClassShards() {
            triggerSave(); // Save to cloud on shard changes
        }

        // Save and load quest state (questStats, quest progress, claimable/completed/reward flags)
        function saveQuestState() {
            try {
                const payload = {
                    questStats: questStats,
                    fireQuests: fireQuests.map(q => ({ id: q.id, completed: !!q.completed, claimable: !!q.claimable, rewardGiven: q.rewardGiven || null })),
                    tycoonQuests: tycoonQuests.map(q => ({ id: q.id, completed: !!q.completed, claimable: !!q.claimable, rewardGiven: q.rewardGiven || null })),
                    fireQuestHalfRewardClaimed: !!fireQuestHalfRewardClaimed,
                    fireQuestRewardClaimed: !!fireQuestRewardClaimed,
                    freeGoldSummonAwarded: !!freeGoldSummonAwarded,
                    gameState: {
                        freeBasicSummons: gameState.freeBasicSummons || 0,
                        freeGoldSummons: gameState.freeGoldSummons || 0
                    }
                };
                localStorage.setItem('gg_questState_v1', JSON.stringify(payload));
                triggerSave(); // Also save to cloud
            } catch (e) { console.warn('saveQuestState failed', e); }
        }

        function loadQuestState() {
            try {
                const raw = localStorage.getItem('gg_questState_v1');
                if (!raw) return;
                const data = JSON.parse(raw);
                if (data.questStats) {
                    questStats = Object.assign(questStats || {}, data.questStats);
                }
                if (Array.isArray(data.fireQuests)) {
                    data.fireQuests.forEach(sq => {
                        const q = fireQuests.find(x => x.id === sq.id);
                        if (q) {
                            q.completed = !!sq.completed;
                            q.claimable = !!sq.claimable;
                            q.rewardGiven = sq.rewardGiven || null;
                        }
                    });
                }
                if (Array.isArray(data.tycoonQuests)) {
                    data.tycoonQuests.forEach(sq => {
                        const q = tycoonQuests.find(x => x.id === sq.id);
                        if (q) {
                            q.completed = !!sq.completed;
                            q.claimable = !!sq.claimable;
                            q.rewardGiven = sq.rewardGiven || null;
                        }
                    });
                }
                fireQuestHalfRewardClaimed = !!data.fireQuestHalfRewardClaimed;
                fireQuestRewardClaimed = !!data.fireQuestRewardClaimed;
                freeGoldSummonAwarded = !!data.freeGoldSummonAwarded;
                if (data.gameState) {
                    gameState.freeBasicSummons = data.gameState.freeBasicSummons || 0;
                    gameState.freeGoldSummons = data.gameState.freeGoldSummons || 0;
                }
            } catch (e) { console.warn('loadQuestState failed', e); }
        }

        function saveFirstSummonDone() {
            // No-op: persistence disabled for now
        }

        // SVG shard icon (inline, reusable)
        function getShardSVG(color = '#a78bfa', size = 18) {
            return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;">
                <polygon points="12,2 20,9 16,22 8,22 4,9" fill="${color}" stroke="#fff" stroke-width="1"/>
                <polygon points="12,2 12,22 8,22 4,9" fill="${color}" opacity="0.7"/>
                <polygon points="12,6 16,10 14,18 10,18 8,10" fill="#fff" opacity="0.25"/>
            </svg>`;
        }

        // Unlocked classes - session only, no persistence for now
        let unlockedClasses = ['electric'];

        // Game state (declare early so it can be referenced by unlock UI)
        const gameState = {
            enemies: [],
            projectiles: [],
            allies: [],
            turrets: [],
            minions: [],
            mines: [],
            killCount: 0,
            isGameOver: false,
            spawnTimer: 0,
            spawnInterval: 2000,
            lastTime: Date.now(),
            player: null,
            hp: 100,
            maxHp: 100,
            isInvulnerable: false,
            isInvisible: false,
            machineGunAmmo: 0,
            maxMachineGunAmmo: 200,
            machineGunLastFired: 0,
            machineGunFireRate: 100,
            currentWave: 1,
            enemiesThisWave: 0,
            enemiesPerWave: 10,
            waveInProgress: false,
            classSelected: false,
            enemiesKilledThisWave: 0,
            highestWaveReached: 1,
            globalCheckpoint: 1,
            lastDamageTime: 0,
            lastHealTime: 0,
            coins: 0,
            summonTokens: 1, // start player with one free summon
            debugAI: false
        };

        // Global flag: disable localStorage usage when false
        const USE_LOCAL_STORAGE = false;
        const _inMemoryLS = {};
        // Safe localStorage wrappers (fall back to in-memory store when disabled)
        function lsGet(key) {
            try {
                if (USE_LOCAL_STORAGE && window.localStorage) return localStorage.getItem(key);
            } catch (e) {}
            return (key in _inMemoryLS) ? _inMemoryLS[key] : null;
        }
        function lsSet(key, value) {
            try {
                if (USE_LOCAL_STORAGE && window.localStorage) { localStorage.setItem(key, String(value)); return; }
            } catch (e) {}
            _inMemoryLS[key] = String(value);
        }
        function lsRemove(key) {
            try {
                if (USE_LOCAL_STORAGE && window.localStorage) { localStorage.removeItem(key); return; }
            } catch (e) {}
            delete _inMemoryLS[key];
        }

        // Monkeypatch localStorage methods when persistence is disabled so existing code using localStorage still works
        try {
            if (!USE_LOCAL_STORAGE && typeof window !== 'undefined' && window.localStorage) {
                try { window.localStorage.getItem = (k) => (k in _inMemoryLS) ? _inMemoryLS[k] : null; } catch(e) {}
                try { window.localStorage.setItem = (k, v) => { _inMemoryLS[k] = String(v); }; } catch(e) {}
                try { window.localStorage.removeItem = (k) => { delete _inMemoryLS[k]; }; } catch(e) {}
            }
        } catch (e) { /* ignore */ }

        // Initialize global checkpoint from localStorage (persisted across classes)
        try {
            const gp = parseInt(localStorage.getItem('globalCheckpoint'), 10);
            gameState.globalCheckpoint = (!isNaN(gp) && gp >= 1) ? gp : 1;
        } catch (e) { gameState.globalCheckpoint = 1; }

        function saveUnlockedClasses() {
            triggerImmediateSave(); // Immediately save to cloud on class unlock
        }

        function resetUnlocks() {
            if (!confirm('Reset unlocked classes to default (Electric only)?')) return;
            unlockedClasses = ['electric'];
            saveUnlockedClasses();
            updateClassCardLockState();
            updateBuyNextClassBtn();
            updateCoinDisplay();
            alert('Unlocks reset.');
        }

        function isClassUnlocked(className) {
            return unlockedClasses.includes(className);
        }

        function getNextLockedClass() {
            for (const cn of classOrder) {
                if (!unlockedClasses.includes(cn)) return cn;
            }
            return null; // all unlocked
        }

        // Unlock the next class. If `targetClass` is provided, ensure it is the next locked class.
        function buyNextClass(targetClass) {
            const nextClass = getNextLockedClass();
            const classToBuy = targetClass || nextClass;
            if (!classToBuy) {
                alert('All classes are already unlocked!');
                return;
            }
            // Enforce unlock order
            if (classToBuy !== nextClass) {
                alert('You must unlock classes in order. Next to unlock: ' + (nextClass ? nextClass.charAt(0).toUpperCase() + nextClass.slice(1) : 'none'));
                return;
            }
            if (gameState.coins < CLASS_UNLOCK_COST) {
                alert('Not enough coins! Need ' + CLASS_UNLOCK_COST.toLocaleString() + ' coins.');
                return;
            }
            gameState.coins -= CLASS_UNLOCK_COST;
            unlockedClasses.push(classToBuy);
            saveUnlockedClasses();
            updateCoinDisplay();
            updateClassCardLockState();
            updateBuyNextClassBtn();
            alert('Unlocked ' + classToBuy.charAt(0).toUpperCase() + classToBuy.slice(1) + '!');
        }

        function updateClassCardLockState() {
            const nextClass = getNextLockedClass();
            classOrder.forEach(cn => {
                const card = document.querySelector(`.class-card[onclick*="selectClass('${cn}')"]`);
                if (!card) return;

                // Remove any previous inline unlock button or shard progress
                const prevBtn = card.querySelector('.unlock-class-btn');
                if (prevBtn) prevBtn.remove();
                const prevShardBar = card.querySelector('.card-shard-progress');
                if (prevShardBar) prevShardBar.remove();

                if (isClassUnlocked(cn)) {
                    card.classList.remove('locked', 'unlockable');
                    card.style.pointerEvents = '';
                } else {
                    card.classList.add('locked');

                    // Show shard progress on locked cards
                    const shards = classShards[cn] || 0;
                    const pct = Math.min(100, Math.round((shards / SHARDS_TO_UNLOCK) * 100));
                    const color = summonColors[cn] ? '#' + summonColors[cn].toString(16).padStart(6, '0') : '#a78bfa';
                    
                    // Find or create a place for the shard bar. Prefer the right column so progress appears near the description/buttons.
                    let btnRow = card.querySelector('.class-card-btn-row');
                    const rightCol = card.querySelector('.card-right') || card.querySelector('.class-exp-container');
                    if (!btnRow) {
                        btnRow = document.createElement('div');
                        btnRow.className = 'class-card-btn-row';
                        if (rightCol) rightCol.appendChild(btnRow);
                        else {
                            const leftCol = card.querySelector('.card-left');
                            if (leftCol) leftCol.appendChild(btnRow);
                            else card.appendChild(btnRow);
                        }
                    }

                    // Add shard progress bar (use same visual style as summon screen)
                    const shardDiv = document.createElement('div');
                    shardDiv.className = 'card-shard-progress';
                    shardDiv.style.cssText = 'margin-top:8px; pointer-events:auto;';
                    const displayName = cn.charAt(0).toUpperCase() + cn.slice(1);
                    // Use the existing `.class-exp-bar` visual so it matches other bars and remains visible
                    shardDiv.innerHTML = `
                        <div class="class-level" style="font-size:13px; margin-bottom:6px; color:${color}; font-weight:700;">${displayName}</div>
                        <div class="class-exp-bar" style="height:12px; border-radius:8px; border-color:${color}; margin-top:4px;">
                            <div class="class-exp-fill" style="width:${pct}%; background:${color}; height:100%; box-shadow: none;"></div>
                            <div class="class-exp-text" style="font-size:11px;">${shards}/${SHARDS_TO_UNLOCK}</div>
                        </div>
                    `;

                    // Prefer to insert the shard bar under the description in the right column
                    const insertTarget = card.querySelector('.card-right') || card.querySelector('.class-exp-container');
                    if (insertTarget) {
                        const desc = insertTarget.querySelector('p');
                        if (desc && desc.parentNode === insertTarget) desc.insertAdjacentElement('afterend', shardDiv);
                        else insertTarget.appendChild(shardDiv);
                    } else {
                        btnRow.appendChild(shardDiv);
                    }

                    // If this is the next locked class, also show the direct buy button
                    // NOTE: skip showing the direct-buy unlock on the 'fire' card per UX request
                    if (cn === nextClass && cn !== 'fire') {
                        card.classList.add('unlockable');

                        const unlockBtn = document.createElement('button');
                        unlockBtn.className = 'unlock-class-btn';
                        unlockBtn.textContent = `Buy Unlock (${CLASS_UNLOCK_COST.toLocaleString()} coins)`;
                        unlockBtn.onclick = (e) => { e.stopPropagation(); buyNextClass(cn); };
                        unlockBtn.style.pointerEvents = 'auto';
                        unlockBtn.style.marginTop = '6px';
                        unlockBtn.tabIndex = 0;
                        if (typeof gameState !== 'undefined' && gameState.coins < CLASS_UNLOCK_COST) {
                            unlockBtn.disabled = true;
                            unlockBtn.classList.add('disabled');
                            unlockBtn.title = 'Need ' + CLASS_UNLOCK_COST.toLocaleString() + ' coins';
                        } else {
                            unlockBtn.disabled = false;
                            unlockBtn.classList.remove('disabled');
                            unlockBtn.title = '';
                        }
                        btnRow.appendChild(unlockBtn);
                    } else {
                        card.classList.remove('unlockable');
                    }
                }
            });
            // After updating visuals, reorder class cards so unlocked appear first,
            // then locked classes ordered by shards remaining (fewest shards remaining first).
            try { reorderClassCards(); } catch (e) { /* ignore */ }
        }

        function reorderClassCards() {
            const container = document.querySelector('.class-container');
            if (!container) return;
            const unlocked = classOrder.filter(c => unlockedClasses.includes(c));
            let locked = classOrder.filter(c => !unlockedClasses.includes(c));
            locked.sort((a, b) => {
                const remA = SHARDS_TO_UNLOCK - (classShards[a] || 0);
                const remB = SHARDS_TO_UNLOCK - (classShards[b] || 0);
                if (remA !== remB) return remA - remB;
                return classOrder.indexOf(a) - classOrder.indexOf(b);
            });
            const ordered = unlocked.concat(locked);
            ordered.forEach(cn => {
                const card = container.querySelector(`.class-card[onclick*="selectClass('${cn}')"]`);
                if (card) container.appendChild(card);
            });
        }

        // Check and unlock any class that has reached 100 shards
        function checkShardUnlocks() {
            classOrder.forEach(cn => {
                if (!unlockedClasses.includes(cn) && (classShards[cn] || 0) >= SHARDS_TO_UNLOCK) {
                    unlockedClasses.push(cn);
                    saveUnlockedClasses();
                    console.log('[Shards] Auto-unlocked', cn, 'from shards');
                }
            });
        }

        // Ensure shard UI and ordering are applied once the DOM/layout is ready.
        window.addEventListener('DOMContentLoaded', () => {
            // Advance loading
            LoadingManager.advance('Initializing game state...');
            // Load saved quest state (if any)
            try { loadQuestState(); } catch (e) {}

            // Check for any classes that should be unlocked from shards
            checkShardUnlocks();

            // Miner login quest: award one loggedIn stat on first page load (persisted)
            try {
                const key = 'minerLoginClaimed';
                const rewardedKey = 'tycoonLoginRewarded';
                if (!localStorage.getItem(key)) {
                    // First-time visit: mark claimed and grant the loggedIn stat (UI will show it completed and player may claim)
                    localStorage.setItem(key, '1');
                    trackQuestProgress('loggedIn', 1);
                    // mark tycoon login quest as claimable so player can press Claim
                    try { if (typeof tycoonQuests !== 'undefined' && tycoonQuests[0]) tycoonQuests[0].claimable = true; } catch (e) {}
                } else {
                    // Returning visitor: ensure the stat is visible in the UI (do not auto-award shards)
                    questStats.loggedIn = Math.max(questStats.loggedIn || 0, 1);
                    try { if (typeof tycoonQuests !== 'undefined' && tycoonQuests[0]) tycoonQuests[0].claimable = true; } catch (e) {}
                }
            } catch (e) {}

            // ensure quest UIs reflect loaded state
            try { updateFireQuestUI(); } catch (e) {}
            try { updateTycoonQuestUI(); } catch (e) {}

            // small delay to allow class-card restructuring to complete
            setTimeout(() => {
                LoadingManager.advance('Setting up classes...');
                try { updateClassCardLockState(); } catch (e) {}
                try { updateShardProgressList(); } catch (e) {}
                try { reorderClassCards(); } catch (e) {}
                // Populate SVG icons
                try { populateSVGIcons(); } catch (e) {}

                LoadingManager.advance('Loading UI...');

                // Final loading complete after small delay for UI to settle
                setTimeout(() => {
                    LoadingManager.advance('Preparing combat arena...');
                    setTimeout(() => {
                        LoadingManager.complete();
                    }, 200);
                }, 100);
            }, 80);
        });

        // Populate all SVG icon placeholders
        function populateSVGIcons() {
            const iconMap = {
                'eventsFireIcon': getFireSVG('#fff', 18),
                'eventsCloseIcon': getCloseSVG('#fff', 14),
                'eventsTitleIcon': getFireSVG('#ef4444', 28),
                'mainQuestIcon': getTargetSVG('#f97316', 20),
                'questCompleteIcon': getPartySVG('#4ade80', 22),
                'upcomingEventsIcon': getCalendarSVG('#a78bfa', 18),
                'minerEventIcon': getTargetSVG('#8b5cf6', 18),
                'tabGoldIcon': getStarSVG('#1a1a2e', 16),
                'goldSummonIcon': getStarSVG('#ffd700', 18)
            };
            for (const [id, svg] of Object.entries(iconMap)) {
                const el = document.getElementById(id);
                if (el) el.innerHTML = svg;
            }
        }

        // Simple event logging helper (shows messages in Events -> Event Log)
        function addEventLog(msg) {
            try {
                // Keep an in-memory event log, but do NOT render to DOM. Only write to console.
                gameState.eventLog = gameState.eventLog || [];
                const time = (new Date()).toLocaleTimeString();
                const entry = `${time} ${msg}`;
                gameState.eventLog.push(entry);
                if (gameState.eventLog.length > 100) gameState.eventLog.shift();
                // Only log to console (developer-visible). Do not touch DOM.
                try { console.log(entry); } catch (e) {}
            } catch (e) { console.warn('addEventLog error', e); }
        }

        function updateBuyNextClassBtn() {
            const btn = document.getElementById('buyNextClassBtn');
            if (!btn) return;
            const nextClass = getNextLockedClass();
            if (!nextClass) {
                btn.textContent = 'All Classes Unlocked!';
                btn.disabled = true;
                btn.style.display = 'inline-block';
            } else {
                btn.textContent = 'Unlock ' + nextClass.charAt(0).toUpperCase() + nextClass.slice(1) + ' (' + CLASS_UNLOCK_COST.toLocaleString() + ' coins)';
                btn.disabled = gameState.coins < CLASS_UNLOCK_COST;
                btn.style.display = 'inline-block';
            }
        }

        // progression-specific button removed; class card buttons handle buy UI

        // ---------- Summon screen logic ----------
        const summonColors = {
            electric: 0xffff66, fire: 0xff704d, pierce: 0x8b4513, engineer: 0xffb86b,
            life: 0xff3b3b, summoner: 0x9b5cff, water: 0x4fd1ff, miner: 0xc0c6ff, tycoon: 0xffd700,
            thief: 0x94a3b8, trapper: 0xfbbf24
        };

        let summonCtx = null;

        function showSummonScreen() {
            console.log('[Summon] showSummonScreen called');
            // refresh summon buttons when opening
            if(typeof updateSummonButtons === 'function') updateSummonButtons();
            const s = document.getElementById('summonScreen');
            // Ensure overlay is last in the document so it renders above other stacking contexts
            try {
                if (s && s.parentElement !== document.body) document.body.appendChild(s);
                // also re-append to ensure last child
                document.body.appendChild(s);
            } catch (e) { console.warn('[Summon] reappend overlay failed', e); }
            // Force visible
            s.style.display = 'flex';
            s.style.position = 'fixed';
            s.style.inset = '0';
            s.style.zIndex = '2147483647';
            s.style.background = 'rgba(0,0,0,0.6)';
            s.style.backdropFilter = 'none';
            s.style.pointerEvents = 'auto';
            // keep original inner styles (no debug override)
            try {
                const inner = s.firstElementChild;
                if (inner) {
                    inner.style.position = inner.style.position || 'relative';
                    inner.style.pointerEvents = inner.style.pointerEvents || 'auto';
                }
            } catch (e) { console.warn('[Summon] ensure inner defaults failed', e); }
            // Delay init slightly so container has layout size when renderer is created
            updateShardProgressList();
            updateSummonButtons();
            setTimeout(() => {
                try { initSummonScene(); console.log('[Summon] initSummonScene executed'); } catch (e) { console.error('[Summon] init error', e); }
            }, 60);
        }

        function closeSummonScreen() {
            document.getElementById('summonScreen').style.display = 'none';
            disposeSummonScene();
            document.getElementById('summonResult').textContent = '';
        }

        // ========== EVENTS SCREEN ==========
        function showEventsScreen() {
            const s = document.getElementById('eventsScreen');
            if (s) {
                s.style.display = 'flex';
                updateFireQuestUI();
                try { updateTycoonQuestUI(); } catch (e) {}
            }
        }

        function closeEventsScreen() {
            const s = document.getElementById('eventsScreen');
            if (s) s.style.display = 'none';
        }

        function updateFireQuestUI() {
            const listEl = document.getElementById('fireQuestList');
            const countEl = document.getElementById('fireQuestCount');
            const barEl = document.getElementById('fireQuestBar');
            const rewardEl = document.getElementById('fireQuestReward');
            if (!listEl) return;

            const fireAlreadyUnlocked = unlockedClasses.includes('fire');
            let completedCount = 0;
            let html = '';
            fireQuests.forEach(q => {
                const currentVal = questStats[q.stat] || 0;
                const progress = Math.min(currentVal, q.target);
                const pct = Math.min(100, (progress / q.target) * 100);
                const done = progress >= q.target;

                // mark claimable when progress reached, but do not mark completed or award until player claims
                if (done && !q.completed && !q.claimable) {
                    q.claimable = true;
                }
                if (q.completed) completedCount++;

                // Show claim button if completed but not yet rewarded
                html += `<div style="background:rgba(255,255,255,0.05); border-radius:8px; padding:12px; border-left:4px solid ${done ? '#4ade80' : '#ef4444'};">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                        <span style="color:#fff; font-weight:600;">${q.title}</span>
                        <div style="display:flex; align-items:center; gap:8px;">
                            <span style="color:${done ? '#4ade80' : '#f97316'}; font-weight:700; font-size:14px;">${done ? getCheckSVG('#4ade80', 14) + ' Completed' : progress + ' / ' + q.target}</span>
                            ${q.claimable && !q.rewardGiven ? `<button onclick="claimFireQuest(${q.id})" style=\"margin-left:8px; padding:6px 8px; border-radius:8px; background:#8b5cf6; color:#fff; border:0; cursor:pointer;\">Claim</button>` : ''}
                        </div>
                    </div>
                    <p style="color:#aaa; margin:0 0 8px 0; font-size:13px;">${q.description}</p>
                    <div style="background:rgba(0,0,0,0.4); border-radius:6px; height:8px; overflow:hidden;">
                        <div style="height:100%; background:${done ? '#4ade80' : 'linear-gradient(90deg,#ef4444,#f97316)'}; width:${pct}%; transition:width 0.3s ease;"></div>
                    </div>
                </div>`;
            });
            listEl.innerHTML = html;

            if (countEl) countEl.textContent = completedCount + ' / 10';
            if (barEl) barEl.style.width = (completedCount * 10) + '%';

            // Milestone: show milestone claim UI at 5 completed (claimed) quests
            const halfEl = document.getElementById('fireQuestHalfReward');
            if (completedCount >= 5 && !fireQuestHalfRewardClaimed) {
                if (halfEl) halfEl.style.display = 'block';
            }

            // All quests complete â€” show final reward banner so player can claim
            if (completedCount >= 10 && !fireQuestRewardClaimed) {
                if (rewardEl) rewardEl.style.display = 'block';
            }
        }

        // Tycoon quest UI
        function updateTycoonQuestUI() {
            const listEl = document.getElementById('tycoonQuestList');
            if (!listEl) return;
            let html = '';
            let completedCount = 0;
            tycoonQuests.forEach(q => {
                const currentVal = questStats[q.stat] || 0;
                const progress = Math.min(currentVal, q.target);
                const done = progress >= q.target;
                // mark claimable but do not auto-award â€” require player to claim
                if (done && !q.completed && !q.claimable) {
                    q.claimable = true;
                }
                if (q.completed) completedCount++;
                const statusText = q.completed ? 'Completed' : (progress + ' / ' + q.target);
                html += `<div style="background:rgba(255,255,255,0.03); border-radius:8px; padding:10px 10px 10px 14px; display:flex; justify-content:space-between; align-items:center; border-left:4px solid #ffd700;"><div><div style="font-weight:600; color:#fff;">${q.title}</div><div style="color:#aaa; font-size:13px;">${q.description}</div></div><div style="display:flex; align-items:center; gap:8px;"><div style="font-weight:700; color:${q.completed ? '#4ade80' : '#f97316'};">${statusText}</div> ${q.claimable && !q.rewardGiven ? '<button onclick="claimTycoonQuest(' + q.id + ')" style="margin-left:8px; padding:6px 8px; border-radius:8px; background:#ffd700; color:#000; border:0; cursor:pointer;">Claim</button>' : ''}</div></div>`;
            });
            listEl.innerHTML = html;
        }

        // Claim handlers for quests
        function claimFireQuest(id) {
            const q = fireQuests.find(x => x.id === id);
            if (!q || q.rewardGiven) return;

            // Mark quest as claimed/completed (no shard reward by default)
            q.rewardGiven = true;
            q.completed = true;
            q.claimable = false;

            try { addEventLog(`{events} claimed Fire quest: ${q.title}`); } catch(e) {}

            // Update related UIs and persist quest state
            try { if (typeof updateShardProgressList === 'function') updateShardProgressList(); } catch(e) {}
            try { updateFireQuestUI(); } catch(e) {}
            try { saveQuestState(); } catch (e) {}
            try { updateClassCardLockState(); } catch (e) {}

            try { console.log('[Quests] Fire quest claimed:', q.id, q.title); } catch(e) {}
        }
            try { updateFireQuestUI(); } catch(e){}
            try { updateSummonButtons(); } catch(e){}
            try { saveQuestState(); } catch (e) {}
            try { updateClassCardLockState(); } catch (e) {}
        

        function claimFireHalf() {
            if (fireQuestHalfRewardClaimed) return;
            fireQuestHalfRewardClaimed = true;
            // Milestone at 5 quests: unlock Fire class for the player
            if (!unlockedClasses.includes('fire')) {
                unlockedClasses.push('fire');
                saveUnlockedClasses();
            }
            try { addEventLog('{events} unlocked Fire (5-quest milestone)'); } catch(e){}
            try { updateClassCardLockState(); } catch (e) {}
            try { updateFireQuestUI(); } catch(e){}
            try { saveQuestState(); } catch (e) {}
        }

        function claimFireFinal() {
            if (fireQuestRewardClaimed) return;
            fireQuestRewardClaimed = true;
            // Final milestone: award a free gold summon
            if (!freeGoldSummonAwarded) {
                freeGoldSummonAwarded = true;
                gameState.freeGoldSummons = (gameState.freeGoldSummons || 0) + 1;
            }
            try { addEventLog('{events} awarded 1 free Gold Summon (10-quest milestone)'); } catch(e){}
            try { updateSummonButtons(); } catch(e){}
            try { updateFireQuestUI(); } catch(e){}
            try { saveQuestState(); } catch (e) {}
        }

        function claimTycoonQuest(id) {
            const q = tycoonQuests.find(x => x.id === id);
            if (!q || q.rewardGiven) return;
            classShards['tycoon'] = (classShards['tycoon'] || 0) + (q.reward || 0);
            saveClassShards();
            q.rewardGiven = 'shards';
            q.completed = true;
            q.claimable = false;
            try { addEventLog(`{events} added ${q.reward || 0} tycoon shards`); } catch(e){}
            if (classShards['tycoon'] >= SHARDS_TO_UNLOCK && !unlockedClasses.includes('tycoon')) {
                unlockedClasses.push('tycoon');
                saveUnlockedClasses();
                updateClassCardLockState();
            }
            try { if (typeof updateShardProgressList === 'function') updateShardProgressList(); } catch(e) {}
            try { updateTycoonQuestUI(); } catch(e) {}
            try { saveQuestState(); } catch (e) {}
            try { updateClassCardLockState(); } catch (e) {}
        }

        // Track quest progress - call after relevant events
        function trackQuestProgress(stat, value) {
            if (stat === 'highestWave') {
                questStats.highestWave = Math.max(questStats.highestWave || 1, value);
            } else {
                questStats[stat] = (questStats[stat] || 0) + value;
            }
            try { updateFireQuestUI(); } catch (e) {}
            try { updateTycoonQuestUI(); } catch (e) {}
            try { saveQuestState(); } catch (e) {}
        }

        function updateSummonLockedList() {
            const list = document.getElementById('summonLockedList');
            if (!list) return;
            const remaining = classOrder.filter(c => !unlockedClasses.includes(c));
            list.innerHTML = remaining.length ? remaining.map(c => `<li>${c.charAt(0).toUpperCase()+c.slice(1)}</li>`).join('') : '<li>All unlocked</li>';
        }

        function initSummonScene() {
            if (summonCtx) return; // already initialized
            const container = document.getElementById('summonCanvasContainer');
            if (!container) {
                const err = document.getElementById('summonError');
                if (err) { err.style.display = 'block'; err.textContent = 'Summon scene error: missing container'; }
                console.error('[Summon] init failed: missing container');
                return;
            }

            const width = container.clientWidth;
            const height = container.clientHeight;
            console.log('[Summon] initSummonScene container size', width, height);
            if (width < 20 || height < 20) {
                const err = document.getElementById('summonError');
                if (err) {
                    err.style.display = 'block';
                    err.textContent = 'Summon scene error: container too small (' + width + 'x' + height + ')';
                }
                console.error('[Summon] container too small', width, height);
                return;
            }

            const sceneS = new THREE.Scene();
            sceneS.background = new THREE.Color(0x050508);
            const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.set(0, 6, 14);
            camera.lookAt(0, 0, 0);

            const rendererS = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            rendererS.setSize(width, height);
            container.innerHTML = '';
            container.appendChild(rendererS.domElement);
            try {
                console.log('[Summon] canvas size after append', rendererS.domElement.clientWidth, rendererS.domElement.clientHeight);
                rendererS.domElement.style.visibility = 'visible';
                // restore clear color to scene background
                if (typeof rendererS.setClearColor === 'function') rendererS.setClearColor(0x050508, 1);
            } catch (e) { console.warn('[Summon] post-append restore failed', e); }
            // Ensure the canvas fills the container and is visible
            try {
                container.style.position = container.style.position || 'relative';
                rendererS.domElement.style.display = 'block';
                rendererS.domElement.style.width = '100%';
                rendererS.domElement.style.height = '100%';
                rendererS.domElement.style.position = 'absolute';
                rendererS.domElement.style.top = '0';
                rendererS.domElement.style.left = '0';
                rendererS.domElement.style.zIndex = '5';
                console.log('[Summon] appended canvas, set styles');
            } catch (e) { console.warn('[Summon] style set failed', e); }

            // Handle container resize to keep renderer in sync
            let lastW = 0, lastH = 0;
            const resizeObserver = new ResizeObserver(() => {
                try {
                    const w = container.clientWidth || Math.max(1, Math.round(window.innerWidth * 0.5));
                    const h = container.clientHeight || Math.max(1, Math.round(window.innerHeight * 0.4));
                    // Only resize if dimensions actually changed to prevent feedback loop
                    if (w !== lastW || h !== lastH) {
                        lastW = w;
                        lastH = h;
                        rendererS.setSize(w, h, false); // false = don't update canvas style
                        if (summonCtx && summonCtx.camera) summonCtx.camera.aspect = w / h;
                        if (summonCtx && summonCtx.camera) summonCtx.camera.updateProjectionMatrix();
                    }
                } catch (err) { console.warn('[Summon] resizeObserver failed', err); }
            });
            try { resizeObserver.observe(container); } catch (e) { /* ignore */ }

            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            sceneS.add(ambient);
            const dir = new THREE.DirectionalLight(0xffffff, 0.6);
            dir.position.set(5, 10, 7);
            sceneS.add(dir);

            // podium - neon bordered platform
            const podiumGeo = new THREE.BoxGeometry(4, 1, 2.6);
            const podiumMat = new THREE.MeshStandardMaterial({ 
                color: 0x0a0a12, 
                metalness: 0.6, 
                roughness: 0.3,
                emissive: 0x00f5ff,
                emissiveIntensity: 0.05
            });
            const podium = new THREE.Mesh(podiumGeo, podiumMat);
            podium.position.set(0, -0.5, 0);
            
            // Add wireframe edge to podium for neon outline effect
            const podiumEdges = new THREE.EdgesGeometry(podiumGeo);
            const podiumLine = new THREE.LineSegments(
                podiumEdges,
                new THREE.LineBasicMaterial({ color: 0x00f5ff, transparent: true, opacity: 0.6 })
            );
            podium.add(podiumLine);
            sceneS.add(podium);

            // floor reflection plane - dark with subtle glow
            const planeGeo = new THREE.CircleGeometry(20, 32);
            const planeMat = new THREE.MeshBasicMaterial({ color: 0x050508 });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -1;
            sceneS.add(plane);

            const clock = { prev: performance.now() };

            summonCtx = { scene: sceneS, camera, renderer: rendererS, podium, animating: false, fallingMesh: null, raf: null, clock };

            // no debug test mesh added in production

            function renderLoop() {
                const now = performance.now();
                const dt = (now - summonCtx.clock.prev) / 1000;
                summonCtx.clock.prev = now;

                // simple physics update for falling mesh
                if (summonCtx.animating && summonCtx.fallingMesh) {
                    const fm = summonCtx.fallingMesh;
                    if (!fm.userData.v) fm.userData.v = 0;
                    fm.userData.v -= 9.8 * dt * 4; // gravity multiplier
                    fm.position.y += fm.userData.v * dt;
                    if (fm.position.y <= 0.5) {
                        fm.position.y = 0.5;
                        summonCtx.animating = false;
                        // settle and pop text
                        showSummonNameOverlay(fm.userData.className, fm.userData.shardAmount);
                        // small bounce
                        fm.userData.v = -fm.userData.v * 0.15;
                    }
                }

                summonCtx.renderer.render(summonCtx.scene, summonCtx.camera);
                summonCtx.raf = requestAnimationFrame(renderLoop);
            }
            summonCtx.raf = requestAnimationFrame(renderLoop);
        }

        function disposeSummonScene() {
            if (!summonCtx) return;
            try {
                cancelAnimationFrame(summonCtx.raf);
            } catch (e) {}
            try { summonCtx.renderer.domElement.remove(); } catch (e) {}
            summonCtx = null;
        }

        function showSummonNameOverlay(className, shardAmount) {
            const result = document.getElementById('summonResult');
            if (!result) return;
            const title = className.charAt(0).toUpperCase() + className.slice(1);
            if (typeof shardAmount === 'number') {
                result.innerHTML = getShardSVG(summonColors[className] ? '#' + summonColors[className].toString(16).padStart(6,'0') : '#a78bfa', 20) + ' <strong>+' + shardAmount + '</strong> ' + title + ' Shards!';
            } else {
                result.textContent = title + ' summoned!';
            }
        }

        function doSummon() {
            console.log('[Summon] doSummon called', { coins: gameState && gameState.coins, firstSummonDone, tab: currentSummonTab });
            // Ensure scene exists if possible
            if (!summonCtx) {
                try { initSummonScene(); } catch (e) { console.warn('[Summon] init before summon failed', e); }
            }

            // Check if all classes already unlocked
            const allUnlocked = classOrder.every(c => unlockedClasses.includes(c));
            if (allUnlocked) { alert('All classes unlocked!'); return; }

            let shardAmount = 0;
            let isFree = false;
            const isGold = currentSummonTab === 'gold';

            if (isGold) {
                // Gold summon: first one free, otherwise costs GOLD_SUMMON_COST
                if (!firstSummonDone) {
                    // Free first Gold summon: 75% 50 shards, 25% 100 shards
                    shardAmount = Math.random() < 0.75 ? 50 : 100;
                    isFree = true;
                    firstSummonDone = true;
                    saveFirstSummonDone();
                } else {
                    if (gameState.coins < GOLD_SUMMON_COST) { alert('Not enough coins! Need ' + GOLD_SUMMON_COST.toLocaleString() + ' coins.'); return; }
                    gameState.coins -= GOLD_SUMMON_COST;
                    shardAmount = Math.random() < 0.75 ? 50 : 100;
                }
            } else {
                // Basic summon: costs SHARD_SUMMON_COST, 5-30 shards
                // Check for free basic summons from quest rewards
                if (gameState.freeBasicSummons && gameState.freeBasicSummons > 0) {
                    gameState.freeBasicSummons--;
                    isFree = true;
                } else {
                    if (gameState.coins < SHARD_SUMMON_COST) { alert('Not enough coins! Need ' + SHARD_SUMMON_COST + ' coins.'); return; }
                    gameState.coins -= SHARD_SUMMON_COST;
                }
                shardAmount = Math.floor(Math.random() * 26) + 5;
            }
            updateCoinDisplay();

            // Pick a random class (including locked ones) to receive shards
            const eligibleClasses = classOrder.filter(c => !unlockedClasses.includes(c));
            // If all unlocked, can still summon but shards go to a random class (overflow/bonus)
            const targetClasses = eligibleClasses.length > 0 ? eligibleClasses : classOrder;
            const picked = targetClasses[Math.floor(Math.random() * targetClasses.length)];
            console.log('[Summon] picked', picked, 'shards', shardAmount);

            // Add shards
            classShards[picked] = (classShards[picked] || 0) + shardAmount;
            let didUnlock = false;
            if (classShards[picked] >= SHARDS_TO_UNLOCK && !unlockedClasses.includes(picked)) {
                // Unlock the class!
                unlockedClasses.push(picked);
                saveUnlockedClasses();
                didUnlock = true;
                console.log('[Summon] unlocked via shards', picked);
            }
            saveClassShards();

            // Try to create falling shard mesh if WebGL scene exists
            let usedThree = false;
            try {
                if (summonCtx && summonCtx.scene) {
                    const color = summonColors[picked] || 0xa78bfa;
                    // Create a shard-shaped mesh (octahedron)
                    const geo = new THREE.OctahedronGeometry(1.2, 0);
                    const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.25, flatShading: true });
                    const shard = new THREE.Mesh(geo, mat);
                    shard.position.set(0, 12, 0);
                    shard.userData = { className: picked, v: 0, shardAmount: shardAmount };
                    summonCtx.scene.add(shard);
                    summonCtx.fallingMesh = shard;
                    summonCtx.animating = true;
                    usedThree = true;
                }
            } catch (e) {
                console.warn('[Summon] three falling mesh failed', e);
                usedThree = false;
            }

            // Fallback: create a simple visible HTML animation if Three.js isn't usable
            if (!usedThree) {
                const container = document.getElementById('summonCanvasContainer');
                if (container) {
                    const prev = container.querySelector('.summon-fallback');
                    if (prev) prev.remove();

                    const fb = document.createElement('div');
                    fb.className = 'summon-fallback';
                    fb.style.cssText = 'position:absolute; left:50%; transform:translateX(-50%); top:-120px; width:80%; max-width:420px; padding:18px; background:linear-gradient(90deg,#a78bfa,#7c3aed); color:#fff; font-weight:900; font-size:20px; border-radius:12px; text-align:center; box-shadow:0 10px 40px rgba(0,0,0,0.5);';
                    fb.innerHTML = getShardSVG('#fff', 28) + ' +' + shardAmount + ' ' + picked.charAt(0).toUpperCase() + picked.slice(1) + ' Shards!';
                    container.appendChild(fb);

                    let top = -120;
                    const target = 120;
                    fb._anim = setInterval(() => {
                        top += 18;
                        fb.style.top = top + 'px';
                        if (top >= target) {
                            clearInterval(fb._anim);
                            setTimeout(() => { fb.remove(); }, 1400);
                        }
                    }, 30);
                }
            }

            // Show result text
            const resultEl = document.getElementById('summonResult');
            if (resultEl) {
                let msg = getShardSVG(summonColors[picked] ? '#' + summonColors[picked].toString(16).padStart(6,'0') : '#a78bfa', 22) + ' <strong>+' + shardAmount + '</strong> ' + picked.charAt(0).toUpperCase() + picked.slice(1) + ' Shards';
                if (didUnlock) msg += '<br><span style="color:#4ade80; font-weight:800;">CLASS UNLOCKED!</span>';
                if (isFree) msg = '<span style="color:#ffd47a;">[First Summon Bonus!]</span> ' + msg;
                resultEl.innerHTML = msg;
            }

            // After animation finishes, update UI
            const poll = setInterval(() => {
                const animating = summonCtx ? !!summonCtx.animating : false;
                if (animating) return;
                clearInterval(poll);
                updateClassCardLockState();
                updateBuyNextClassBtn();
                updateShardProgressList();
                if (typeof updateSummonButtons === 'function') updateSummonButtons();
            }, 200);
        }

            // Fast shard summon without animation for bulk summons
            function fastShardSummonOnce(isGold){
                // Exclude 'fire' from summon pool - fire is unlocked via quests only
                const eligibleClasses = classOrder.filter(c => !unlockedClasses.includes(c) && c !== 'fire');
                const targetClasses = eligibleClasses.length > 0 ? eligibleClasses : classOrder.filter(c => c !== 'fire');
                const picked = targetClasses[Math.floor(Math.random() * targetClasses.length)];
                const shardAmount = isGold ? (Math.random() < 0.75 ? 50 : 100) : (Math.floor(Math.random() * 26) + 5);
                classShards[picked] = (classShards[picked] || 0) + shardAmount;
                let didUnlock = false;
                if (classShards[picked] >= SHARDS_TO_UNLOCK && !unlockedClasses.includes(picked)) {
                    unlockedClasses.push(picked);
                    saveUnlockedClasses();
                    didUnlock = true;
                }
                saveClassShards();
                return { className: picked, shards: shardAmount, unlocked: didUnlock };
            }

            // Multi-summon: aggregates results (no animation)
            function doSummonMultiple(count){
                count = Math.max(1, Math.floor(count));
                const isGold = currentSummonTab === 'gold';
                const cost = isGold ? GOLD_SUMMON_COST : SHARD_SUMMON_COST;
                let coins = gameState.coins || 0;
                const results = [];
                for(let i=0;i<count;i++){
                    // First Gold summon bonus applies only once (on Gold tab)
                    if (isGold && !firstSummonDone && i === 0) {
                        // Exclude 'fire' from summon pool - fire is unlocked via quests only
                        const eligibleClasses = classOrder.filter(c => !unlockedClasses.includes(c) && c !== 'fire');
                        const targetClasses = eligibleClasses.length > 0 ? eligibleClasses : classOrder.filter(c => c !== 'fire');
                        const picked = targetClasses[Math.floor(Math.random() * targetClasses.length)];
                        const freeShards = Math.random() < 0.75 ? 50 : 100;
                        classShards[picked] = (classShards[picked] || 0) + freeShards;
                        let didUnlock = false;
                        if (classShards[picked] >= SHARDS_TO_UNLOCK && !unlockedClasses.includes(picked)) {
                            unlockedClasses.push(picked);
                            saveUnlockedClasses();
                            didUnlock = true;
                        }
                        saveClassShards();
                        firstSummonDone = true;
                        saveFirstSummonDone();
                        results.push({ className: picked, shards: freeShards, unlocked: didUnlock, free: true });
                        continue;
                    }
                    if(coins < cost){
                        results.push({ error: 'Not enough coins' });
                        break;
                    }
                    coins -= cost;
                    results.push(fastShardSummonOnce(isGold));
                }
                gameState.coins = coins;
                // aggregate messages
                const shardTotals = {};
                const unlockedList = [];
                results.forEach(r => {
                    if (r.className) {
                        shardTotals[r.className] = (shardTotals[r.className] || 0) + r.shards;
                        if (r.unlocked) unlockedList.push(r.className);
                    }
                });
                let summary = Object.entries(shardTotals).map(([c, s]) => '+' + s + ' ' + c.charAt(0).toUpperCase() + c.slice(1)).join(', ');
                if (unlockedList.length) summary += '<br><span style="color:#4ade80; font-weight:800;">Unlocked: ' + unlockedList.map(u=>u.charAt(0).toUpperCase()+u.slice(1)).join(', ') + '</span>';
                const el = document.getElementById('summonResult');
                if(el) el.innerHTML = summary || 'No results';
                updateCoinDisplay();
                updateClassCardLockState();
                updateBuyNextClassBtn();
                updateShardProgressList();
                if(typeof updateSummonButtons === 'function') updateSummonButtons();
            }

            // Update summon buttons to show shard cost based on current tab
            function updateSummonButtons(){
                const btn = document.getElementById('doSummonBtn');
                const btn10 = document.getElementById('doSummon10Btn');
                if(!btn) return;
                const coins = gameState.coins || 0;
                const isGold = currentSummonTab === 'gold';
                const cost = isGold ? GOLD_SUMMON_COST : SHARD_SUMMON_COST;
                const color = isGold ? '#ffd700' : '#a78bfa';
                const freeBasic = (gameState.freeBasicSummons || 0);

                if(isGold && !firstSummonDone){
                    btn.innerHTML = getStarSVG('#1a1a2e', 16) + 'FREE';
                    btn.style.background = 'linear-gradient(90deg,#ffd700,#ffb347)';
                    btn.disabled = false;
                } else if(!isGold && freeBasic > 0){
                    // Free basic summon from quest rewards
                    btn.innerHTML = getShardSVG(color, 18) + ' Summon (FREE! ' + freeBasic + ' left)';
                    btn.style.background = 'linear-gradient(90deg,#4ade80,#22d3ee)';
                    btn.disabled = false;
                } else {
                    const label = isGold ? getStarSVG(color, 16) + ' Gold Summon' : 'Summon';
                    btn.innerHTML = getShardSVG(color, 18) + ' ' + label + ' (' + cost.toLocaleString() + ' coins)';
                    btn.style.background = isGold ? 'linear-gradient(90deg,#ffd700,#ffb347)' : 'linear-gradient(90deg,#ffd47a,#ff80c4)';
                    btn.disabled = coins < cost;
                }
                if(btn10){
                    const cost10 = (isGold && !firstSummonDone) ? cost * 9 : cost * 10;
                    const label10 = isGold ? getStarSVG(color, 16) + ' x10' : 'x10';
                    btn10.innerHTML = getShardSVG(color, 18) + ' ' + label10 + ' (' + cost10.toLocaleString() + ' coins)';
                    btn10.style.background = isGold ? 'linear-gradient(90deg,#ffd700,#ffb347)' : 'linear-gradient(90deg,#ffd47a,#ff80c4)';
                    btn10.disabled = coins < (isGold && !firstSummonDone ? 0 : cost);
                }
            }

            // Update shard progress list in summon UI
            function updateShardProgressList() {
                const container = document.getElementById('shardProgressList');
                if (!container) return;
                let html = '';
                classOrder.forEach(c => {
                    const shards = classShards[c] || 0;
                    const unlocked = unlockedClasses.includes(c);
                    const pct = Math.min(100, Math.round((shards / SHARDS_TO_UNLOCK) * 100));
                    const color = summonColors[c] ? '#' + summonColors[c].toString(16).padStart(6, '0') : '#a78bfa';
                    html += '<div style="margin-bottom:6px; display:flex; align-items:center; gap:8px;">';
                    html += '<span style="color:' + color + '; font-weight:600; font-size:12px; min-width:65px;">' + c.charAt(0).toUpperCase() + c.slice(1) + '</span>';
                    html += '<div style="flex:1; height:6px; background:rgba(255,255,255,0.1); border-radius:3px; overflow:hidden;">';
                    html += '<div style="height:100%; width:' + pct + '%; background:' + (unlocked ? '#4ade80' : color) + '; transition:width 0.3s;"></div>';
                    html += '</div>';
                    if (unlocked) {
                        html += '<span style="color:#4ade80; font-size:10px; font-weight:700; min-width:55px; text-align:right;">UNLOCKED</span>';
                    } else {
                        html += '<span style="color:#888; font-size:10px; min-width:55px; text-align:right;">' + shards + '/' + SHARDS_TO_UNLOCK + '</span>';
                    }
                    html += '</div>';
                });
                container.innerHTML = html;
            }

        // EXP System - Session only (no saving)
        const classExp = {
            electric: { level: 1, exp: 0, maxExp: 100, evolution: 0 },
            fire: { level: 1, exp: 0, maxExp: 100, evolution: 0 },
            pierce: { level: 1, exp: 0, maxExp: 100, evolution: 0 },
            engineer: { level: 1, exp: 0, maxExp: 100, evolution: 0 },
            life: { level: 1, exp: 0, maxExp: 100, evolution: 0 },
            summoner: { level: 1, exp: 0, maxExp: 100, evolution: 0 },
            water: { level: 1, exp: 0, maxExp: 100, evolution: 0 },
            miner: { level: 1, exp: 0, maxExp: 100, evolution: 0 },
            thief: { level: 1, exp: 0, maxExp: 100, evolution: 0 },
            trapper: { level: 1, exp: 0, maxExp: 100, evolution: 0 },
            tycoon: { level: 1, exp: 0, maxExp: 100, evolution: 0 },
            fighter: { level: 1, exp: 0, maxExp: 100, evolution: 0 }
        };
        
        // Update exp displays on load
        function updateExpDisplays() {
            Object.keys(classExp).forEach(className => {
                const data = classExp[className];
                const expPercent = (data.exp / data.maxExp) * 100;
                const evolutionText = data.evolution > 0 ? ` [Evo ${data.evolution}]` : '';
                document.getElementById(`${className}-level`).textContent = `Level ${data.level}${evolutionText}`;
                document.getElementById(`${className}-exp-fill`).style.width = expPercent + '%';
                document.getElementById(`${className}-exp-text`).textContent = `${data.exp} / ${data.maxExp}`;
            });
        }
        updateExpDisplays();
        updateBuyButtons();
        updateClassCardLockState();
        updateBuyNextClassBtn();
        
        // Progression upgrades for each class (tier-based specific buffs)
        // These define the actual bonuses applied at each level tier
        const classUpgrades = {
            electric: [
                { level: 2, buffs: ['Q: -10% cooldown', '+5% movement speed'] },
                { level: 3, buffs: ['E: +2 extra targets', '+10 max HP'] },
                { level: 5, buffs: ['R: +50% chain range', 'Q: -15% cooldown'] },
                { level: 7, buffs: ['+10% movement speed', 'All abilities: -10% cooldown'] },
                { level: 10, buffs: ['R: Unlimited bounces', '+20 max HP', '+15% movement speed'] },
                { level: 15, buffs: ['EVOLUTION: Q creates chain explosions on each target'] }
            ],
            fire: [
                { level: 2, buffs: ['Q: +20% burn damage', '+5% movement speed'] },
                { level: 3, buffs: ['E: +50% healing', '+10 max HP'] },
                { level: 5, buffs: ['R: +1 fireball', 'Q: +1 range'] },
                { level: 7, buffs: ['+10% movement speed', 'Burn duration +2s'] },
                { level: 10, buffs: ['All fire abilities: +50% damage', '+20 max HP', 'E: -30% cooldown'] },
                { level: 15, buffs: ['EVOLUTION: R fireballs explode in massive AoE'] }
            ],
            pierce: [
                { level: 2, buffs: ['Q: +20% damage', '+5% movement speed'] },
                { level: 3, buffs: ['E: +2 arrows', '+10 max HP'] },
                { level: 5, buffs: ['R: +25% damage', 'Q: -20% cooldown'] },
                { level: 7, buffs: ['+10% movement speed', 'All piercing: +30% damage'] },
                { level: 10, buffs: ['Q: +50% damage', '+20 max HP', 'E: -40% cooldown'] },
                { level: 15, buffs: ['EVOLUTION: E shoots in 360-degree spiral'] }
            ],
            engineer: [
                { level: 2, buffs: ['Q: -15% cooldown', '+5% movement speed'] },
                { level: 3, buffs: ['Turrets: +25% HP', '+10 max HP'] },
                { level: 5, buffs: ['R: +50 ammo', 'E: -20% cooldown'] },
                { level: 7, buffs: ['+10% movement speed', 'Turrets: +50% damage'] },
                { level: 10, buffs: ['R: +100 ammo, +20% fire rate', '+20 max HP', 'Q: Max 2 turrets'] },
                { level: 15, buffs: ['EVOLUTION: Q spawns 3 turrets at once'] }
            ],
            life: [
                { level: 2, buffs: ['Q: +25% AoE damage', '+5% movement speed'] },
                { level: 3, buffs: ['E: +50% lifesteal', '+10 max HP'] },
                { level: 5, buffs: ['R: +10 attacks', 'Passive drain: -50%'] },
                { level: 7, buffs: ['+10% movement speed', 'All lifesteal: +25%'] },
                { level: 10, buffs: ['Q: +50 damage', '+30 max HP', 'Passive drain removed'] },
                { level: 15, buffs: ['EVOLUTION: R converts all nearby enemies to allies'] }
            ],
            summoner: [
                { level: 2, buffs: ['Minions: +25% HP', '+5% movement speed'] },
                { level: 3, buffs: ['Q: -25% cooldown', '+10 max HP'] },
                { level: 5, buffs: ['E: +1 minion', 'Minions: +50% damage'] },
                { level: 7, buffs: ['+10% movement speed', 'Minion duration +5s'] },
                { level: 10, buffs: ['R: +50 HP to guardian', '+20 max HP', 'All summons: +100% damage'] },
                { level: 15, buffs: ['EVOLUTION: E spawns ranged archers instead'] }
            ],
            water: [
                { level: 2, buffs: ['Q: +2 damage', '+5% movement speed'] },
                { level: 3, buffs: ['E: +30% knockback', '+10 max HP'] },
                { level: 5, buffs: ['R: +10 damage', 'Q: -20% cooldown'] },
                { level: 7, buffs: ['+10% movement speed', 'All abilities: +2 range'] },
                { level: 10, buffs: ['R: +5s invulnerability', '+20 max HP', 'E: -35% cooldown'] },
                { level: 15, buffs: ['EVOLUTION: E range doubled'] }
            ],
            thief: [
                { level: 2, buffs: ['Q: +3 daggers', '+10% movement speed'] },
                { level: 3, buffs: ['E: +2s invisibility', '+15 max HP'] },
                { level: 5, buffs: ['R: +50% execute threshold', 'Q: -25% cooldown'] },
                { level: 7, buffs: ['+15% movement speed', 'Q: +5 damage per dagger'] },
                { level: 10, buffs: ['E: -40% cooldown', '+25 max HP', 'R: Bomb radius +50%'] },
                { level: 15, buffs: ['EVOLUTION: R chains to 3 additional enemies'] }
            ],
            trapper: [
                { level: 2, buffs: ['Q: +1 bomb capacity', '+10 max HP'] },
                { level: 3, buffs: ['E: +1 barrier capacity', 'Barriers: +3s duration'] },
                { level: 5, buffs: ['R: +15 damage', 'Q: -30% cooldown'] },
                { level: 7, buffs: ['Bombs: +2 radius', 'Barriers: +50% slow'] },
                { level: 10, buffs: ['Q: +2 bomb capacity', '+30 max HP', 'E: -35% cooldown'] },
                { level: 15, buffs: ['EVOLUTION: R creates cluster explosions'] }
            ],
            miner: [
                { level: 2, buffs: ['Passive: +10% shovel damage', '+5% movement speed'] },
                { level: 3, buffs: ['MINE: +25% damage', '+10 max HP'] },
                { level: 5, buffs: ['DRILL: +3s duration', 'DIG: -20% cooldown'] },
                { level: 7, buffs: ['Passive: +20% shovel speed', 'MINE: +0.5 trigger radius'] },
                { level: 10, buffs: ['DRILL: +50% drill power', '+25 max HP', 'MINE: -30% cooldown'] },
                { level: 15, buffs: ['EVOLUTION: DIG teleports and plants a mine on arrival'] }
            ],
            tycoon: [
                { level: 2, buffs: ['+5% movement speed'] },
                { level: 3, buffs: ['E: +1 coin per collect', '+10 max HP'] },
                { level: 5, buffs: ['Q: -20% cooldown', 'Tycoon coins +50%'] },
                { level: 7, buffs: ['+10% movement speed'] },
                { level: 10, buffs: ['E: -30% cooldown', '+20 max HP'] },
                { level: 15, buffs: ['EVOLUTION: Tycoon building grants small area coin aura'] }
            ],
            fighter: [
                { level: 2, buffs: ['Q: +20% ram damage', '+5% movement speed'] },
                { level: 3, buffs: ['E: +25% pull range', '+15 max HP'] },
                { level: 5, buffs: ['R: +2s berserk duration', 'Q: -20% cooldown'] },
                { level: 7, buffs: ['+15% movement speed', 'Q: +0.5s invulnerability'] },
                { level: 10, buffs: ['E: +50% damage', '+25 max HP', 'R: -5 HP cost'] },
                { level: 15, buffs: ['EVOLUTION: R grants permanent +25% speed after use'] }
            ]
        };
        
        // View progression window
        function viewProgression(className) {
            const classData = classExp[className];
            const upgrades = classUpgrades[className];
            const title = className.charAt(0).toUpperCase() + className.slice(1);
            
            window.currentProgressionClass = className;
            document.getElementById('progressionTitle').textContent = `${title} Progression`;
            
            let content = '';
            upgrades.forEach(upgrade => {
                // Evolution upgrades (level 15) require reaching level 15 once
                const isEvolution = upgrade.level === 15;
                const isUnlocked = isEvolution ? classData.evolution > 0 : classData.level >= upgrade.level;
                const tierClass = isUnlocked ? 'unlocked' : 'locked';
                const status = isUnlocked ? 'UNLOCKED' : `Requires Level ${upgrade.level}`;
                
                content += `
                    <div class="upgrade-tier ${tierClass}">
                        <h3>Level ${upgrade.level}${isEvolution ? ' - EVOLUTION' : ''} - ${status}</h3>
                        ${upgrade.buffs.map(buff => `<p>â€¢ ${buff}</p>`).join('')}
                    </div>
                `;
            });
            
            // If viewing Tycoon progression, also show in-run Tycoon tiers
            if (className === 'tycoon') {
                // compute highest current tycoon level this run (if any)
                let maxTycoonLevel = 0;
                try { if (gameState && gameState.tycoons && gameState.tycoons.length) maxTycoonLevel = Math.max(...gameState.tycoons.map(t => (t.userData && t.userData.level) || 0)); } catch(e){}
                content += `<h3 style="margin-top:18px; color:var(--neon-cyan);">Tycoon In-Run Tiers</h3>`;
                tycoonTiers.forEach(t => {
                    const isUnlocked = maxTycoonLevel >= t.level;
                    const tierClass = isUnlocked ? 'unlocked' : 'locked';
                    const status = isUnlocked ? 'REACHED' : `Requires Tycoon Lv ${t.level}`;
                    content += `
                        <div class="upgrade-tier ${tierClass}">
                            <h3>Level ${t.level} - ${status}</h3>
                            ${t.buffs.map(buff => `<p>â€¢ ${buff}</p>`).join('')}
                        </div>
                    `;
                });
            }

            document.getElementById('progressionContent').innerHTML = content;
            document.getElementById('progressionWindow').style.display = 'block';
        }
        
        // Close progression window
        function closeProgression() {
            document.getElementById('progressionWindow').style.display = 'none';
            window.currentProgressionClass = null;
        }
        
        // Duplicate gameState declaration removed â€” `gameState` is declared earlier above.

        // Quick trackers for debug of invulnerability/invisibility
        let _prevInvulnerable = gameState.isInvulnerable;
        let _prevInvisible = gameState.isInvisible;

        // Update coin display
        function updateCoinDisplay() {
            document.getElementById('coinAmount').textContent = gameState.coins;
            // update summon tokens display
            const tokenEl = document.getElementById('summonTokenDisplay');
            const tokenCountEl = document.getElementById('summonTokenCount');
            if (tokenEl && tokenCountEl) {
                const n = (gameState && gameState.summonTokens) ? gameState.summonTokens : 0;
                tokenCountEl.textContent = n;
                tokenEl.style.display = n > 0 ? 'inline-block' : 'none';
            }
            // Refresh lock/unlock UI so inline unlock buttons enable/disable correctly
            try { updateClassCardLockState(); } catch (e) {}
        }
        updateCoinDisplay();

        // Buy EXP for class (now per class card)
        function buyExp(className) {
            const data = classExp[className];
            if (!data) return;
            if (data.level >= 15) {
                alert('Class is max level!');
                return;
            }

            // Compute cost to purchase exactly enough EXP for next level
            const expNeeded = Math.max(0, data.maxExp - data.exp);
            // Ratio: 1 EXP : 4 coins => 4 coins per 1 EXP
            const cost = Math.max(4, Math.ceil(expNeeded * 4));
            if (gameState.coins < cost) {
                alert('Not enough coins!');
                return;
            }

            // Deduct coins and add the required EXP to reach next level
            gameState.coins -= cost;
            data.exp += expNeeded;

            // Level up if needed and apply bonuses
            while (data.exp >= data.maxExp && data.level < 15) {
                data.exp -= data.maxExp;
                data.level++;
                if (data.level === 15) {
                    data.evolution++;
                    data.exp = 0;
                } else {
                    data.maxExp = Math.floor(data.maxExp * 1.5);
                }
                applyClassLevelBonuses(className);
            }

            updateExpDisplays();
            updateCoinDisplay();
            updateBuyButtons();
            triggerSave(); // Save after buying EXP
        }
        
        
        // Helper: create a canvas gradient texture
        function createGradientTexture(colorHexA, colorHexB, vertical = true, size = 256) {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext('2d');
            let grad;
            if (vertical) grad = ctx.createLinearGradient(0, 0, 0, size);
            else grad = ctx.createLinearGradient(0, 0, size, 0);
            grad.addColorStop(0, `#${colorHexA.toString(16).padStart(6, '0')}`);
            grad.addColorStop(1, `#${colorHexB.toString(16).padStart(6, '0')}`);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, size, size);
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            // Use sRGB encoding for correct colors when used as a color map
            try { texture.encoding = THREE.sRGBEncoding; } catch (e) {}
            return texture;
        }

        // Create player (red octahedron with gradient)
        const playerGeometry = new THREE.OctahedronGeometry(0.6, 0);
        // Ensure the geometry has UVs so the gradient `map` appears correctly.
        // We generate simple spherical/linear UVs based on vertex positions.
        try {
            playerGeometry.computeBoundingBox();
            const minY = playerGeometry.boundingBox.min.y;
            const maxY = playerGeometry.boundingBox.max.y;
            const pos = playerGeometry.attributes.position;
            const uv = new Float32Array(pos.count * 2);
            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const y = pos.getY(i);
                const z = pos.getZ(i);
                // u from azimuthal angle, v from normalized height
                const u = 0.5 + (Math.atan2(x, z) / (2 * Math.PI));
                const v = (y - minY) / Math.max(1e-6, (maxY - minY));
                uv[i * 2] = u;
                uv[i * 2 + 1] = v;
            }
            playerGeometry.setAttribute('uv', new THREE.BufferAttribute(uv, 2));
        } catch (e) { console.warn('Failed to generate UVs for player geometry', e); }
        // Load saved skin (hex string like "#00f5ff") or fallback to neon cyan
        const _savedSkinHex = localStorage.getItem('playerSkin');
        const baseColor = _savedSkinHex ? parseInt('0x' + _savedSkinHex.slice(1)) : 0x00f5ff;
        // Accent/fallback color used when restoring player gradient on restart
        const accentColor = baseColor;
        const playerMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x0a0a12,
            emissive: baseColor,
            emissiveIntensity: 0.3,
            metalness: 0.8,
            roughness: 0.2,
            transparent: true,
            opacity: 0.9
        });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.userData.rotationSpeed = 0.02;
        // Collision radius for solidity
        player.userData.collisionRadius = 0.9;
        // Track last-known safe player position for ejection fallback
        try { gameState._lastSafePlayerPos = player.position.clone(); } catch (e) { /* ignore */ }
        
        // Add wireframe outline for hollow neon effect
        const wireframeMaterial = new THREE.MeshBasicMaterial({ 
            color: baseColor, 
            wireframe: true,
            transparent: true,
            opacity: 0.8
        });
        const wireframe = new THREE.Mesh(playerGeometry.clone(), wireframeMaterial);
        wireframe.scale.setScalar(1.02);
        player.add(wireframe);
        try{ if(typeof applyStoredSkinToPlayer === 'function') applyStoredSkinToPlayer(); }catch(e){}

        // ---- Skin selection utilities ----
        function openSkinsModal(){
            const m = document.getElementById('skinsModal'); if(!m) return; m.style.display = 'flex';
            const cur = localStorage.getItem('playerSkin') || '#00f5ff';
            document.querySelectorAll('.skin-swatch').forEach(s=>s.classList.remove('selected'));
            const sel = document.querySelector('.skin-swatch[data-color="' + cur + '"]'); if(sel) sel.classList.add('selected');
            const applyBtn = document.getElementById('applySkinBtn'); if(applyBtn) applyBtn.dataset.color = cur;
        }
        function closeSkinsModal(){ const m=document.getElementById('skinsModal'); if(m) m.style.display='none'; }
        function selectSkinSwatch(el){
            document.querySelectorAll('.skin-swatch').forEach(s=>s.classList.remove('selected'));
            el.classList.add('selected');
            const applyBtn=document.getElementById('applySkinBtn');
            const applyBtnLarge=document.getElementById('applySkinBtnLarge');
            if(applyBtn) { applyBtn.dataset.color = el.dataset.color; applyBtn.dataset.aura = el.dataset.aura || 'none'; }
            if(applyBtnLarge) { applyBtnLarge.dataset.color = el.dataset.color; applyBtnLarge.dataset.aura = el.dataset.aura || 'none'; }
            const preview = document.getElementById('skinPreviewColor');
            if(preview) preview.style.background = el.dataset.color;
        }
        function applySelectedSkin(){
            const applyBtn=document.getElementById('applySkinBtn');
            const btnLarge=document.getElementById('applySkinBtnLarge');
            const hex = (applyBtn && applyBtn.dataset.color) ? applyBtn.dataset.color : (btnLarge && btnLarge.dataset.color) ? btnLarge.dataset.color : (localStorage.getItem('playerSkin') || '#00f5ff');
            const aura = (applyBtn && applyBtn.dataset.aura) ? applyBtn.dataset.aura : (btnLarge && btnLarge.dataset.aura) ? btnLarge.dataset.aura : (localStorage.getItem('playerAura') || 'none');
            // Persist chosen skin and aura
            try{ localStorage.setItem('playerSkin', hex); localStorage.setItem('playerAura', aura); } catch(e){}
            const num = parseInt('0x' + hex.slice(1));
            try{
                if(player && player.material && typeof player.material.emissive !== 'undefined'){ player.material.emissive.setHex(num); player.material.needsUpdate = true; }
                if(wireframe && wireframe.material){ wireframe.material.color.setHex(num); wireframe.material.needsUpdate = true; }
            }catch(e){ console.warn('Failed to apply skin', e); }
            try{ const preview = document.getElementById('skinPreviewColor'); if(preview) preview.style.background = hex; }catch(e){}
            // Close skins UI but do NOT start the game or initialize other UI components
            try{ const m = document.getElementById('skinsModal'); if(m) m.style.display='none'; }catch(e){}
            try{ const s = document.getElementById('skinsScreen'); if(s) s.style.display='none'; }catch(e){}
            // Ensure the skin and aura are applied to the player if player exists
            try{ if(typeof applyStoredSkinToPlayer === 'function') applyStoredSkinToPlayer(); }catch(e){}
        }

        // Show the full skins screen
        function showSkinsScreen(){
            const s = document.getElementById('skinsScreen'); if(!s) return; s.style.display = 'flex';
            // Populate swatches inside full screen container (reuse existing swatches if present)
            // Render dynamic swatches for both modal and full-screen
            try{ renderSkinSwatches(); }catch(e){ console.warn('renderSkinSwatches failed', e); }
            // Sync preview color
            const cur = localStorage.getItem('playerSkin') || '#00f5ff';
            const preview = document.getElementById('skinPreviewColor'); if(preview) preview.style.background = cur;
        }
        function closeSkinsScreen(){ const s = document.getElementById('skinsScreen'); if(s) s.style.display='none'; }

        // Create a playable class that uses the selected skin color and select it
        function applySkinAsClass(){
            const hex = localStorage.getItem('playerSkin') || '#00f5ff';
            const key = 'skin_custom';
            try{
                if(typeof classes === 'undefined') window.classes = {};
                // Use electric as a template if available
                if(!classes[key]){
                    if(classes['electric']) classes[key] = classes['electric'];
                    else {
                        // fallback: pick first class available
                        const first = Object.keys(classes)[0];
                        classes[key] = classes[first];
                    }
                }
                // Mark the class name to be unique / user-friendly
                if(classes[key]) classes[key].name = 'Skin';
                // Persist chosen class key so startGame/restore can pick it
                try{ localStorage.setItem('lastSelectedClass', key); }catch(e){}
                selectClass(key);
            }catch(e){ console.warn('applySkinAsClass failed', e); }
            closeSkinsScreen();
        }

        // Skin palette and rendering - now with aura effects
        const skinPalette = (function(){
            // Define skins with rarities and aura types: glow, sparks, glitchy, pulse, none
            const list = [
                {hex:'#00f5ff', rarity:'common', aura:'none'},
                {hex:'#ff00ff', rarity:'common', aura:'glow'},
                {hex:'#00ff88', rarity:'common', aura:'none'},
                {hex:'#ffff00', rarity:'common', aura:'sparks'},
                {hex:'#ff3366', rarity:'common', aura:'none'},
                {hex:'#ff9f00', rarity:'common', aura:'glow'},
                {hex:'#7cff00', rarity:'common', aura:'sparks'},
                {hex:'#00ffd5', rarity:'common', aura:'none'},
                {hex:'#8a2be2', rarity:'rare', aura:'glow'},
                {hex:'#ff1493', rarity:'rare', aura:'pulse'},
                {hex:'#00bfff', rarity:'rare', aura:'sparks'},
                {hex:'#ffd700', rarity:'rare', aura:'glow'},
                {hex:'#7fffd4', rarity:'rare', aura:'pulse'},
                {hex:'#ff4500', rarity:'common', aura:'sparks'},
                {hex:'#6a5acd', rarity:'common', aura:'glow'},
                {hex:'#bada55', rarity:'common', aura:'none'},
                {hex:'#00fa9a', rarity:'rare', aura:'pulse'},
                {hex:'#ff69b4', rarity:'rare', aura:'sparks'},
                {hex:'#1e90ff', rarity:'rare', aura:'glow'},
                {hex:'#00ff7f', rarity:'common', aura:'none'},
                {hex:'#e6e6fa', rarity:'shiny', aura:'glitchy'},
                {hex:'#f0e68c', rarity:'shiny', aura:'glitchy'},
                {hex:'#ffd1dc', rarity:'rare', aura:'pulse'},
                {hex:'#c0ffee', rarity:'shiny', aura:'glitchy'},
                {hex:'#eaff00', rarity:'rare', aura:'sparks'},
                {hex:'#f5a623', rarity:'common', aura:'glow'},
                {hex:'#d7263d', rarity:'common', aura:'sparks'}
            ];
            return list;
        })();

        function getOwnedSkins(){
            try{ const s = localStorage.getItem('ownedSkins'); if(!s) return new Set(['#00f5ff']); const arr = JSON.parse(s); return new Set(arr); }catch(e){ return new Set(['#00f5ff']); }
        }
        function saveOwnedSkins(set){ try{ localStorage.setItem('ownedSkins', JSON.stringify(Array.from(set))); }catch(e){}
        }

        function renderSkinSwatches(){
            const container = document.getElementById('skinSwatchesContainer');
            if(!container) return;
            container.innerHTML = '';
            const owned = getOwnedSkins();
            const auraIcons = { glow: 'Glow', sparks: 'Sparks', glitchy: 'Glitch', pulse: 'Pulse', none: '' };
            skinPalette.forEach(skin=>{
                const el = document.createElement('div');
                el.className = 'skin-swatch ' + (skin.rarity === 'rare' ? 'rare' : (skin.rarity === 'shiny' ? 'shiny' : ''));
                if (skin.aura && skin.aura !== 'none') el.classList.add('aura-' + skin.aura);
                el.dataset.color = skin.hex;
                el.dataset.rarity = skin.rarity;
                el.dataset.aura = skin.aura || 'none';
                const inner = document.createElement('span'); inner.style.background = skin.hex; inner.style.color = skin.hex;
                el.appendChild(inner);
                // Aura indicator
                if (skin.aura && skin.aura !== 'none') {
                    const auraLabel = document.createElement('div');
                    auraLabel.className = 'aura-indicator';
                    auraLabel.textContent = auraIcons[skin.aura] || '';
                    auraLabel.style.color = skin.hex;
                    el.appendChild(auraLabel);
                }
                if(!owned.has(skin.hex)){
                    el.classList.add('locked');
                    const lock = document.createElement('div'); lock.className = 'lock-overlay';
                    lock.innerHTML = '<svg viewBox="0 0 24 24" width="14" height="14" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17 8h-1V6a4 4 0 0 0-8 0v2H7a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1v-8a1 1 0 0 0-1-1z" stroke="rgba(255,255,255,0.9)" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
                    el.appendChild(lock);
                } else {
                    el.addEventListener('click', function(){ selectSkinSwatch(this); });
                }
                container.appendChild(el);
            });
            // Also populate any smaller modal swatches container if present
            try{
                const modalContainer = document.querySelector('#skinsModal .skin-swatches');
                if(modalContainer){ modalContainer.innerHTML = ''; skinPalette.forEach(skin=>{
                    const el = document.createElement('div');
                    el.className = 'skin-swatch ' + (skin.rarity === 'rare' ? 'rare' : (skin.rarity === 'shiny' ? 'shiny' : ''));
                    if (skin.aura && skin.aura !== 'none') el.classList.add('aura-' + skin.aura);
                    el.dataset.color = skin.hex; el.dataset.rarity = skin.rarity; el.dataset.aura = skin.aura || 'none';
                    const inner = document.createElement('span'); inner.style.background = skin.hex; inner.style.color = skin.hex; el.appendChild(inner);
                    if (skin.aura && skin.aura !== 'none') {
                        const auraLabel = document.createElement('div');
                        auraLabel.className = 'aura-indicator';
                        auraLabel.textContent = auraIcons[skin.aura] || '';
                        auraLabel.style.color = skin.hex;
                        el.appendChild(auraLabel);
                    }
                    const owned = getOwnedSkins();
                    if(!owned.has(skin.hex)){
                        el.classList.add('locked'); const lock = document.createElement('div'); lock.className='lock-overlay'; lock.innerHTML = '<svg viewBox="0 0 24 24" width="12" height="12" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M17 8h-1V6a4 4 0 0 0-8 0v2H7a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h10a1 1 0 0 0 1-1v-8a1 1 0 0 0-1-1z" stroke="rgba(255,255,255,0.9)" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/></svg>'; el.appendChild(lock);
                    } else { el.addEventListener('click', function(){ selectSkinSwatch(this); }); }
                    modalContainer.appendChild(el);
                }); }
            }catch(e){ }
        }

        // Weighted random pick by rarity
        function weightedRandomRarity(){
            // weights: common 75, rare 20, shiny 5
            const r = Math.random()*100;
            if(r < 5) return 'shiny';
            if(r < 25) return 'rare';
            return 'common';
        }

        function purchaseRandomSkin(){
            const cost = 500;
            const msgEl = document.getElementById('skinMessage');
            try{ if(typeof gameState === 'undefined' || typeof gameState.coins === 'undefined'){ if(msgEl) msgEl.textContent = 'No coin info available.'; return; } }catch(e){ if(msgEl) msgEl.textContent='No coin info'; return; }
            if(gameState.coins < cost){ if(msgEl) msgEl.textContent = 'Not enough gold.'; return; }
            // deduct
            gameState.coins -= cost; try{ updateCoinUI && updateCoinUI(); }catch(e){}
            const targetRarity = weightedRandomRarity();
            // pick a random skin of target rarity; prefer unowned
            const owned = getOwnedSkins();
            const candidates = skinPalette.filter(s=>s.rarity===targetRarity);
            let pick = null;
            // try to find unowned within candidates
            const unownedCandidates = candidates.filter(s=>!owned.has(s.hex));
            if(unownedCandidates.length>0){ pick = unownedCandidates[Math.floor(Math.random()*unownedCandidates.length)]; }
            else {
                // fallback: find any unowned from full palette
                const anyUnowned = skinPalette.filter(s=>!owned.has(s.hex));
                if(anyUnowned.length>0) pick = anyUnowned[Math.floor(Math.random()*anyUnowned.length)];
            }
            if(!pick){ // user already owns everything
                if(msgEl) msgEl.textContent = 'You already own all skins.';
                // refund
                gameState.coins += cost;
                try{ updateCoinUI && updateCoinUI(); }catch(e){}
                return;
            }
            // grant
            owned.add(pick.hex); saveOwnedSkins(owned);
            renderSkinSwatches();
            if(msgEl) msgEl.textContent = 'Unlocked skin ' + pick.hex + (pick.rarity==='shiny' ? ' âœ¨' : (pick.rarity==='rare' ? ' â˜…' : ''));
            // auto-select the new skin for preview only (does not start game)
            try{ const el = document.querySelector('.skin-swatch[data-color="'+pick.hex+'"]'); if(el) selectSkinSwatch(el); }catch(e){}
            setTimeout(()=>{ if(msgEl) msgEl.textContent=''; }, 4200);
        }

        // Apply stored skin to player/wireframe/glow ring if available, including aura effects
        function applyStoredSkinToPlayer(){
            try{
                const hex = localStorage.getItem('playerSkin');
                const aura = localStorage.getItem('playerAura') || 'none';
                if(!hex) return;
                const num = parseInt('0x' + hex.slice(1));
                if(typeof player !== 'undefined' && player && player.material){
                    if(typeof player.material.emissive !== 'undefined') player.material.emissive.setHex(num);
                    player.material.needsUpdate = true;
                }
                if(typeof wireframe !== 'undefined' && wireframe && wireframe.material){
                    wireframe.material.color.setHex(num);
                    wireframe.material.needsUpdate = true;
                }
                try{ if(typeof glowRing !== 'undefined' && glowRing && glowRing.material) glowRing.material.color.setHex(num); }catch(e){}
                try{ if(player && player.children && player.children[0] && player.children[0].material) player.children[0].material.color.setHex(num); }catch(e){}
                
                // Apply aura effect to player
                applyPlayerAura(aura, num);
            }catch(e){ console.warn('applyStoredSkinToPlayer error', e); }
        }
        
        // Player aura effect system - creates visual effects based on aura type
        let playerAuraInterval = null;
        function applyPlayerAura(auraType, colorNum) {
            // Clear any existing aura interval
            if (playerAuraInterval) { clearInterval(playerAuraInterval); playerAuraInterval = null; }
            if (!player || !player.material) return;
            
            const baseIntensity = 0.3;
            player.material.emissiveIntensity = baseIntensity;
            
            switch(auraType) {
                case 'glow':
                    // Pulsing glow effect
                    let glowPhase = 0;
                    playerAuraInterval = setInterval(() => {
                        if (!player || !player.material) { clearInterval(playerAuraInterval); return; }
                        glowPhase += 0.08;
                        player.material.emissiveIntensity = 0.3 + Math.sin(glowPhase) * 0.25;
                    }, 50);
                    break;
                    
                case 'sparks':
                    // Flickering sparks effect
                    playerAuraInterval = setInterval(() => {
                        if (!player || !player.material) { clearInterval(playerAuraInterval); return; }
                        player.material.emissiveIntensity = 0.2 + Math.random() * 0.5;
                        // Occasional bright flash
                        if (Math.random() < 0.1) {
                            player.material.emissiveIntensity = 0.9;
                        }
                    }, 80);
                    break;
                    
                case 'glitchy':
                        // Glitchy position jitter + intensity flicker (slower, less extreme)
                        playerAuraInterval = setInterval(() => {
                            if (!player || !player.material) { clearInterval(playerAuraInterval); return; }
                            // Small position jitter (visual only, doesn't affect gameplay)
                            if (wireframe) {
                                wireframe.position.x = (Math.random() - 0.5) * 0.03;
                                wireframe.position.y = (Math.random() - 0.5) * 0.03;
                            }
                            player.material.emissiveIntensity = 0.35 + Math.random() * 0.2;
                            // Less frequent, smaller color shifts
                            if (Math.random() < 0.06 && player.material.emissive) {
                                const shift = Math.random() < 0.5 ? 0.08 : -0.08;
                                player.material.emissive.r = Math.max(0, Math.min(1, player.material.emissive.r + shift));
                            }
                        }, 140);
                    break;
                    
                case 'pulse':
                    // Smooth scaling pulse effect
                    let pulsePhase = 0;
                    playerAuraInterval = setInterval(() => {
                        if (!player || !wireframe) { clearInterval(playerAuraInterval); return; }
                        pulsePhase += 0.1;
                        const scale = 1 + Math.sin(pulsePhase) * 0.06;
                        wireframe.scale.setScalar(scale * 1.02);
                        player.material.emissiveIntensity = 0.25 + Math.sin(pulsePhase) * 0.15;
                    }, 50);
                    break;
                    
                default:
                    // No aura - reset to default
                    player.material.emissiveIntensity = baseIntensity;
                    if (wireframe) wireframe.scale.setScalar(1.02);
                    break;
            }
        }
        
        scene.add(player);
        gameState.player = player;
        
        // Add player glow ring - neon cyan
        const glowRing = new THREE.Mesh(
            new THREE.RingGeometry(0.7, 0.75, 32),
            new THREE.MeshBasicMaterial({ 
                color: 0x00f5ff, 
                transparent: true, 
                opacity: 0.5,
                side: THREE.DoubleSide
            })
        );
        glowRing.position.z = -0.1;
        player.add(glowRing);
        
        // Create arena floor - large enough to cover screen - dark with subtle color
        const floorGeometry = new THREE.PlaneGeometry(200, 200);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x050508,
            transparent: true,
            opacity: 0.95
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.position.z = -0.5;
        scene.add(floor);
        
        // Add grid - neon cyan grid lines for hollow theme
        const gridHelper = new THREE.GridHelper(200, 80, 0x00f5ff, 0x001a1a);
        gridHelper.rotation.x = Math.PI / 2;
        gridHelper.position.z = -0.49;
        gridHelper.material.opacity = 0.15;
        gridHelper.material.transparent = true;
        scene.add(gridHelper);
        
        // Initialize managers
        const hpManager = new HPManager(player, 100);
        const effectsManager = new EffectsManager(scene);
        const movementManager = new MovementManager(player, 0.15);

        // Global helper to sync gameState HP to the HUD via hpManager
        function updateHPBar() {
            try {
                if (typeof hpManager !== 'undefined' && typeof gameState !== 'undefined') {
                    // Ensure gameState.hp exists
                    if (typeof gameState.hp === 'undefined') gameState.hp = hpManager.getHP();
                    if (typeof gameState.maxHp === 'undefined') gameState.maxHp = hpManager.getMaxHP();
                    // Sync values
                    hpManager.currentHp = Math.max(0, Math.min(gameState.maxHp, gameState.hp));
                    hpManager.updateUI();
                }
            } catch (e) { console.warn('updateHPBar error', e); }
        }
        
        // Helper function to check if enemy is visible on screen
        function isEnemyOnScreen(enemy) {
            // Get screen bounds based on orthographic camera
            const screenWidth = window.innerWidth / 40;
            const screenHeight = window.innerHeight / 40;
            
            // Check if enemy is within visible bounds (with small margin)
            return enemy.position.x >= -screenWidth - 2 && 
                   enemy.position.x <= screenWidth + 2 && 
                   enemy.position.y >= -screenHeight - 2 && 
                   enemy.position.y <= screenHeight + 2;
        }

        

        // More strict check: enemy fully on-screen (entire collision radius inside view)
        function isEnemyFullyOnScreen(enemy) {
            if (!enemy || !enemy.userData) return false;
            const radius = (enemy.userData.collisionRadius) ? enemy.userData.collisionRadius : 1;
            const screenWidth = window.innerWidth / 40;
            const screenHeight = window.innerHeight / 40;
            return (enemy.position.x - radius) >= -screenWidth &&
                   (enemy.position.x + radius) <= screenWidth &&
                   (enemy.position.y - radius) >= -screenHeight &&
                   (enemy.position.y + radius) <= screenHeight;
        }

        // Create screen-space HP UI for an enemy (only call when fully on-screen)
        function createEnemyHPUI(enemy) {
            try {
                if (!enemy) return;
                let layer = document.getElementById('enemyHpLayer');
                if (!layer) { layer = document.createElement('div'); layer.id = 'enemyHpLayer'; document.body.appendChild(layer); }
                const hpEl = document.createElement('div');
                hpEl.className = 'enemy-hp';
                const radius = (enemy.userData && enemy.userData.collisionRadius) ? enemy.userData.collisionRadius : 1;
                const fullWidthPx = Math.max(36, Math.round(40 * radius + 40));
                hpEl.style.width = (fullWidthPx) + 'px';
                hpEl.innerHTML = '<div class="bar-bg"><div class="bar-fg"></div></div>';
                layer.appendChild(hpEl);
                enemy.userData.hpUI = { el: hpEl, fullWidth: fullWidthPx, radius };
            } catch (e) { console.warn('Failed to create hp UI', e); }
        }

        // Track last mouse world position for mouse-targeted abilities
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const groundPlane = new THREE.Plane(new THREE.Vector3(0,0,1), 0);
        const lastMouseWorld = new THREE.Vector3();
        // Last clicked world position (set on pointerdown) and visible marker
        let lastClickWorld = null;
        const lastClickMarker = new THREE.Mesh(
            new THREE.RingGeometry(0.4, 0.6, 32),
            new THREE.MeshBasicMaterial({ color: 0xffcc00, side: THREE.DoubleSide })
        );
        lastClickMarker.rotation.x = Math.PI / 2;
        lastClickMarker.position.z = 0.02;
        lastClickMarker.visible = false;
        scene.add(lastClickMarker);

        function setLastClickMarker(pos) {
            if (!pos) return;
            if (!lastClickWorld) lastClickWorld = new THREE.Vector3();
            lastClickWorld.copy(pos);
            lastClickMarker.position.x = pos.x;
            lastClickMarker.position.y = pos.y;
            lastClickMarker.visible = true;
        }

        function clearLastClickMarker() {
            lastClickWorld = null;
            lastClickMarker.visible = false;
        }

        // Track clicks to set the last-click world position
        window.addEventListener('pointerdown', (e) => {
            pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const hit = new THREE.Vector3();
            if (raycaster.ray.intersectPlane(groundPlane, hit)) {
                setLastClickMarker(hit);
                
                // Check if click hit a tycoon â€” tap increases its level (do not destroy)
                if (gameState.tycoons && gameState.tycoons.length > 0) {
                    for (let i = gameState.tycoons.length - 1; i >= 0; i--) {
                        const tycoon = gameState.tycoons[i];
                        if (!tycoon || !tycoon.userData) continue;
                        const dist = hit.distanceTo(tycoon.position);
                        if (dist < 1.5) {
                            // Increase level on tap
                            tycoon.userData.level = (tycoon.userData.level || 1) + 1;
                            try { if (tycoon.userData.levelDiv) tycoon.userData.levelDiv.textContent = 'Lv.' + tycoon.userData.level; } catch(e) {}
                            // Slight visual pulse to indicate level up
                            try { tycoon.material.emissiveIntensity = 1.0; setTimeout(()=>{ if (tycoon.material) tycoon.material.emissiveIntensity = 0.4; }, 220); } catch(e) {}
                            // Optional: small coin pop to reward player feel (no auto-coin award)
                            try { effectsManager.createDamageNumber(tycoon.position, '+' + 0); } catch(e) {}
                            break; // Only apply to one tycoon per click
                        }
                    }
                }
            }
        });
        window.addEventListener('mousemove', (e) => {
            pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            raycaster.ray.intersectPlane(groundPlane, lastMouseWorld);
        });
        
        // Enemy creation
        function createEnemy(forceBoss = false) {
            // Boss spawning - rare chance, higher on boss waves
            let isBoss = forceBoss || (gameState.currentWave % 5 === 0 && Math.random() < 0.15) || (Math.random() < 0.03);
            // Disallow boss (yellow) before wave 3 and cap to 1 per wave
            if (isBoss) {
                if (gameState.currentWave < 3 || gameState.yellowSpawnedThisWave) {
                    isBoss = false;
                } else {
                    gameState.yellowSpawnedThisWave = true;
                }
            }
            
            // New enemy types for later waves
            const canSpawnInvisible = gameState.currentWave >= 5;
            const canSpawnSpeed = gameState.currentWave >= 3;
            const canSpawnArmored = gameState.currentWave >= 8;
            const canSpawnSplitter = gameState.currentWave >= 9;
            const canSpawnSummoner = gameState.currentWave >= 11;

            // Weighted spawn chances including new enemy types for later waves
            const rand = Math.random();
            let enemyType;
            if (isBoss) {
                enemyType = 'boss';
            } else if (canSpawnSummoner && rand < 0.05) {
                enemyType = 'summoner';
            } else if (canSpawnSplitter && rand < 0.10) {
                enemyType = 'splitter';
            } else if (canSpawnArmored && rand < 0.16) {
                enemyType = 'armored';
            } else if (gameState.currentWave >= 4 && rand < 0.22) {
                enemyType = 'shield';
            } else if (gameState.currentWave >= 6 && rand < 0.28) {
                enemyType = 'healer';
            } else if (gameState.currentWave >= 6 && rand < 0.34) {
                enemyType = 'suicide';
            } else if (gameState.currentWave >= 5 && rand < 0.42) {
                enemyType = 'sniper';
            } else if (gameState.currentWave >= 7 && rand < 0.50) {
                enemyType = 'phaser';
            } else if (canSpawnInvisible && rand < 0.60) {
                enemyType = 'invisible';
            } else if (canSpawnSpeed && rand < 0.72) {
                enemyType = 'speed';
            } else if (rand < 0.84) {
                enemyType = 'ranged';
            } else if (rand < 0.94) {
                enemyType = 'tank';
            } else {
                enemyType = 'melee';
            }
            
            let enemyGeometry, enemyMaterial;
            
            // Wave scaling multiplier
            const waveScale = 1 + (gameState.currentWave - 1) * 0.15;
            
            if (enemyType === 'boss') {
                // Boss: Large dodecahedron, glowing neon yellow, high HP and damage
                enemyGeometry = new THREE.DodecahedronGeometry(1.2, 0);
                enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x0a0a12,
                    emissive: 0xffff00,
                    emissiveIntensity: 0.4,
                    transparent: true,
                    opacity: 0.9
                });
            } else if (enemyType === 'melee') {
                // Melee: Tetrahedron, neon green, fast, normal HP
                enemyGeometry = new THREE.TetrahedronGeometry(0.5, 0);
                enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x0a0a12,
                    emissive: 0x00ff88,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 0.9
                });
            } else if (enemyType === 'ranged') {
                // Ranged: Octahedron, neon magenta, medium speed, low HP
                enemyGeometry = new THREE.OctahedronGeometry(0.4, 0);
                enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x0a0a12,
                    emissive: 0xff00ff,
                    emissiveIntensity: 0.35,
                    transparent: true,
                    opacity: 0.9
                });
            } else if (enemyType === 'invisible') {
                // Invisible: Icosahedron, neon purple, semi-transparent, medium HP
                enemyGeometry = new THREE.IcosahedronGeometry(0.45, 0);
                enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x0a0a12,
                    emissive: 0x9933ff,
                    emissiveIntensity: 0.4,
                    transparent: true,
                    opacity: 0
                });
            } else if (enemyType === 'speed') {
                // Speed: Cone, neon orange, very fast, low HP
                enemyGeometry = new THREE.ConeGeometry(0.4, 0.8, 4);
                enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x0a0a12,
                    emissive: 0xff6600,
                    emissiveIntensity: 0.45,
                    transparent: true,
                    opacity: 0.9
                });
            } else {
                // Tank: Box, neon red, slow, high HP
                enemyGeometry = new THREE.BoxGeometry(0.7, 0.7, 0.7);
                enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x0a0a12,
                    emissive: 0xff3366,
                    emissiveIntensity: 0.35,
                    transparent: true,
                    opacity: 0.9
                });
            }
            // Additional types: shield, healer, suicide, sniper, phaser
            if (enemyType === 'shield') {
                enemyGeometry = new THREE.OctahedronGeometry(0.6, 0);
                enemyMaterial = new THREE.MeshStandardMaterial({ color: 0x0a0a12, emissive: 0x00bfff, emissiveIntensity: 0.35, transparent: true, opacity: 0.9 });
            } else if (enemyType === 'healer') {
                enemyGeometry = new THREE.DodecahedronGeometry(0.6, 0);
                enemyMaterial = new THREE.MeshStandardMaterial({ color: 0x0a0a12, emissive: 0x00ff88, emissiveIntensity: 0.35, transparent: true, opacity: 0.9 });
            } else if (enemyType === 'suicide') {
                enemyGeometry = new THREE.ConeGeometry(0.45, 0.9, 6);
                enemyMaterial = new THREE.MeshStandardMaterial({ color: 0x0a0a12, emissive: 0xff3366, emissiveIntensity: 0.5, transparent: true, opacity: 0.9 });
            } else if (enemyType === 'sniper') {
                enemyGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
                enemyMaterial = new THREE.MeshStandardMaterial({ color: 0x0a0a12, emissive: 0x00ffaa, emissiveIntensity: 0.35, transparent: true, opacity: 0.9 });
            } else if (enemyType === 'phaser') {
                enemyGeometry = new THREE.TorusGeometry(0.5, 0.15, 8, 16);
                enemyMaterial = new THREE.MeshStandardMaterial({ color: 0x0a0a12, emissive: 0x00f5ff, emissiveIntensity: 0.45, transparent: true, opacity: 0.9 });
            } else if (enemyType === 'armored') {
                // Armored: heavy plating, more HP, shield-like behavior
                enemyGeometry = new THREE.BoxGeometry(0.85, 0.85, 0.85);
                enemyMaterial = new THREE.MeshStandardMaterial({ color: 0x0a0a12, emissive: 0x3b82f6, emissiveIntensity: 0.35, transparent: true, opacity: 0.95 });
            } else if (enemyType === 'splitter') {
                // Splitter: small spiky enemy that splits into two smaller attackers on death
                enemyGeometry = new THREE.DodecahedronGeometry(0.45, 0);
                enemyMaterial = new THREE.MeshStandardMaterial({ color: 0x0a0a12, emissive: 0xf97316, emissiveIntensity: 0.38, transparent: true, opacity: 0.95 });
            } else if (enemyType === 'summoner') {
                // Summoner: medium enemy that periodically summons low-HP minions
                enemyGeometry = new THREE.DodecahedronGeometry(0.6, 0);
                enemyMaterial = new THREE.MeshStandardMaterial({ color: 0x0a0a12, emissive: 0xa78bfa, emissiveIntensity: 0.36, transparent: true, opacity: 0.95 });
            }
            
            const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            
            // Add wireframe outline for hollow neon effect on enemies
            const enemyWireframeMat = new THREE.MeshBasicMaterial({ 
                color: enemyMaterial.emissive, 
                wireframe: true,
                transparent: true,
                opacity: 0.6
            });
            const enemyWireframe = new THREE.Mesh(enemyGeometry.clone(), enemyWireframeMat);
            enemyWireframe.scale.setScalar(1.02);
            enemy.add(enemyWireframe);
            
            // Spawn at random edge - just off-screen so enemies arrive quickly
            const side = Math.floor(Math.random() * 4);
            // Compute view bounds and spawn a bit outside them
            const viewWidth = window.innerWidth / 40;
            const viewHeight = window.innerHeight / 40;
            const spawnOffset = 6; // how far off-screen to spawn
            const spawnDistance = Math.max(viewWidth, viewHeight) + spawnOffset;
            const spawnSpread = Math.max(viewWidth, viewHeight) * 0.8;
            
            switch(side) {
                case 0:
                    enemy.position.set(Math.random() * spawnSpread - spawnSpread/2, spawnDistance, 0);
                    break;
                case 1:
                    enemy.position.set(spawnDistance, Math.random() * spawnSpread - spawnSpread/2, 0);
                    break;
                case 2:
                    enemy.position.set(Math.random() * spawnSpread - spawnSpread/2, -spawnDistance, 0);
                    break;
                case 3:
                    enemy.position.set(-spawnDistance, Math.random() * spawnSpread - spawnSpread/2, 0);
                    break;
            }

            if (gameState.debugAI) {
                console.log(`createEnemy: spawned type=${enemyType} id=${enemy.id} at (${enemy.position.x.toFixed(1)}, ${enemy.position.y.toFixed(1)}) spawnDistance=${spawnDistance}`);
            }
            
            // Set stats based on enemy type
            if (enemyType === 'boss') {
                // Boss HP scales with player's class level
                const playerLevel = selectedClass && classExp[Object.keys(classes).find(key => classes[key] === selectedClass)] 
                    ? classExp[Object.keys(classes).find(key => classes[key] === selectedClass)].level 
                    : 1;
                const levelScale = 1 + (playerLevel - 1) * 0.2;
                const bossHP = Math.floor(200 * waveScale * levelScale);
                
                enemy.userData = {
                    type: 'boss',
                    hp: bossHP,
                    maxHp: bossHP,
                    speed: 0.025,
                    damage: Math.floor(30 * waveScale),
                    attackCooldown: 0,
                    attackInterval: 800,
                    attackRange: 2,
                    rotationSpeed: 0.01,
                    isBoss: true,
                    collisionRadius: 2
                };
            } else if (enemyType === 'melee') {
                enemy.userData = {
                    type: 'melee',
                    hp: Math.floor(30 * waveScale),
                    maxHp: Math.floor(30 * waveScale),
                    speed: 0.03 + (gameState.currentWave * 0.001),
                    damage: Math.floor(10 * waveScale),
                    attackCooldown: 0,
                    attackInterval: 1000,
                    attackRange: 1.5,
                    rotationSpeed: 0.01 + Math.random() * 0.02
                ,collisionRadius: 0.9
                };
            } else if (enemyType === 'ranged') {
                enemy.userData = {
                    type: 'ranged',
                    hp: Math.floor(20 * waveScale),
                    maxHp: Math.floor(20 * waveScale),
                    speed: 0.02 + (gameState.currentWave * 0.0005),
                    damage: Math.floor(8 * waveScale),
                    attackCooldown: 0,
                    attackInterval: 2000,
                    attackRange: 12,
                    rotationSpeed: 0.02 + Math.random() * 0.03
                ,collisionRadius: 0.8
                };
            } else if (enemyType === 'invisible') {
                enemy.userData = {
                    type: 'invisible',
                    hp: Math.floor(25 * waveScale),
                    maxHp: Math.floor(25 * waveScale),
                    speed: 0.025 + (gameState.currentWave * 0.0008),
                    damage: Math.floor(12 * waveScale),
                    attackCooldown: 0,
                    attackInterval: 1200,
                    attackRange: 1.5,
                    rotationSpeed: 0.015 + Math.random() * 0.02,
                    invisFlashTimer: Math.random() * 1000,
                    collisionRadius: 0.8
                };
            } else if (enemyType === 'speed') {
                enemy.userData = {
                    type: 'speed',
                    hp: Math.floor(18 * waveScale),
                    maxHp: Math.floor(18 * waveScale),
                    speed: 0.05 + (gameState.currentWave * 0.0015),
                    damage: Math.floor(8 * waveScale),
                    attackCooldown: 0,
                    attackInterval: 900,
                    attackRange: 1.5,
                    rotationSpeed: 0.03 + Math.random() * 0.03
                ,collisionRadius: 0.7
                };
            } else if (enemyType === 'shield') {
                enemy.userData = { type: 'shield', hp: Math.floor(60 * waveScale), maxHp: Math.floor(60 * waveScale), speed: 0.02, damage: Math.floor(10 * waveScale), attackCooldown: 0, attackInterval: 1200, attackRange: 1.6, rotationSpeed: 0.01, shieldHits: 1, collisionRadius: 0.9 };
            } else if (enemyType === 'healer') {
                enemy.userData = { type: 'healer', hp: Math.floor(50 * waveScale), maxHp: Math.floor(50 * waveScale), speed: 0.015, damage: Math.floor(6 * waveScale), attackCooldown: 0, attackInterval: 1400, attackRange: 1.4, rotationSpeed: 0.01, healAmount: Math.floor(8 * waveScale), healInterval: 3000, lastHeal: 0, collisionRadius: 0.9 };
            } else if (enemyType === 'suicide') {
                enemy.userData = { type: 'suicide', hp: Math.floor(18 * waveScale), maxHp: Math.floor(18 * waveScale), speed: 0.025, damage: Math.floor(30 * waveScale), attackCooldown: 0, attackInterval: 900, attackRange: 1.0, rotationSpeed: 0.02, explodeRange: 3.5, explodeDamage: Math.floor(50 * waveScale), exploded: false, collisionRadius: 0.7 };
            } else if (enemyType === 'sniper') {
                enemy.userData = { type: 'sniper', hp: Math.floor(25 * waveScale), maxHp: Math.floor(25 * waveScale), speed: 0.01, damage: Math.floor(28 * waveScale), attackCooldown: 0, attackInterval: 2200, attackRange: 20, rotationSpeed: 0.005, collisionRadius: 0.8 };
            } else if (enemyType === 'phaser') {
                enemy.userData = { type: 'phaser', hp: Math.floor(45 * waveScale), maxHp: Math.floor(45 * waveScale), speed: 0.02, damage: Math.floor(12 * waveScale), attackCooldown: 0, attackInterval: 1100, attackRange: 1.6, rotationSpeed: 0.02, teleportCooldown: 4000, lastTeleport: 0, collisionRadius: 0.9 };
            } else if (enemyType === 'armored') {
                enemy.userData = { type: 'armored', hp: Math.floor(100 * waveScale), maxHp: Math.floor(100 * waveScale), speed: 0.012 + (gameState.currentWave * 0.0002), damage: Math.floor(18 * waveScale), attackCooldown: 0, attackInterval: 1400, attackRange: 1.6, rotationSpeed: 0.005, shieldHits: 2, collisionRadius: 1.0 };
            } else if (enemyType === 'splitter') {
                enemy.userData = { type: 'splitter', hp: Math.floor(26 * waveScale), maxHp: Math.floor(26 * waveScale), speed: 0.03 + (gameState.currentWave * 0.0008), damage: Math.floor(9 * waveScale), attackCooldown: 0, attackInterval: 900, attackRange: 1.2, rotationSpeed: 0.02, collisionRadius: 0.6 };
            } else if (enemyType === 'summoner') {
                enemy.userData = { type: 'summoner', hp: Math.floor(60 * waveScale), maxHp: Math.floor(60 * waveScale), speed: 0.015, damage: Math.floor(6 * waveScale), attackCooldown: 0, attackInterval: 1600, attackRange: 1.6, rotationSpeed: 0.01, lastSummon: 0, summonInterval: 4500, collisionRadius: 0.9 };
            } else {
                enemy.userData = { type: 'tank', hp: Math.floor(80 * waveScale), maxHp: Math.floor(80 * waveScale), speed: 0.015 + (gameState.currentWave * 0.0003), damage: Math.floor(20 * waveScale), attackCooldown: 0, attackInterval: 1500, attackRange: 1.5, rotationSpeed: 0.005 + Math.random() * 0.01, collisionRadius: 1.2 };
            }
            
            scene.add(enemy);
            // Do not create HP UI immediately; defer until enemy is fully on-screen
            enemy.userData.hpUI = null;
            // Ensure no lingering claim/target state on newly spawned enemies
            if (!enemy.userData) enemy.userData = {};
            enemy.userData.claimedBy = null;
            enemy.userData.currentTarget = null;
            gameState.enemies.push(enemy);
            if (gameState.debugAI) {
                console.log(`createEnemy: pushed enemy id=${enemy.id} claimedBy=${enemy.userData.claimedBy}`);
            }
        }
        
        // Class definitions
        // Helper: clamp a vector to map/screen bounds
        function clampToMapVec(vec, margin=0) {
            const sw = window.innerWidth / 40;
            const sh = window.innerHeight / 40;
            vec.x = Math.max(-(sw - margin), Math.min(sw - margin, vec.x));
            vec.y = Math.max(-(sh - margin), Math.min(sh - margin, vec.y));
            return vec;
        }

        // Check whether a point is blocked by barriers or enemies
        function pointIsBlocked(x, y) {
            try {
                const pr = (player && player.userData && player.userData.collisionRadius) ? player.userData.collisionRadius : 0.9;
                // Barriers
                if (window.gameState && Array.isArray(window.gameState.barriers)) {
                    for (const b of window.gameState.barriers) {
                        try {
                            if (!b || !b.userData) continue;
                            const width = (b.userData.width != null) ? b.userData.width : 4;
                            const height = (b.userData.height != null) ? b.userData.height : 0.5;
                            const dx = x - b.position.x;
                            const dy = y - b.position.y;
                            const angle = - (b.rotation ? b.rotation.z : 0);
                            const localX = dx * Math.cos(angle) - dy * Math.sin(angle);
                            const localY = dx * Math.sin(angle) + dy * Math.cos(angle);
                            if (Math.abs(localX) <= (width / 2 + pr) && Math.abs(localY) <= (height / 2 + pr)) return true;
                        } catch (e) { continue; }
                    }
                }
                // Enemies
                if (window.gameState && Array.isArray(window.gameState.enemies)) {
                    for (const e of window.gameState.enemies) {
                        try {
                            if (!e || !e.userData) continue;
                            const er = (e.userData.collisionRadius != null) ? e.userData.collisionRadius : 0.8;
                            const dx = e.position.x - x;
                            const dy = e.position.y - y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist <= (er + pr)) return true;
                        } catch (e2) { continue; }
                    }
                }
            } catch (e) { /* ignore */ }
            return false;
        }

        // Check whether moving to (x,y) would put `entity` (defaults to player) within any enemy's damaging range
        function pointWouldBeInDanger(x, y, entity) {
            try {
                const ent = entity || player;
                const pr = (ent && ent.userData && ent.userData.collisionRadius) ? ent.userData.collisionRadius : 0.9;
                if (!window.gameState || !Array.isArray(window.gameState.enemies)) return false;
                for (const enemy of window.gameState.enemies) {
                    if (!enemy || !enemy.userData) continue;
                    const er = (enemy.userData.attackRange != null) ? enemy.userData.attackRange : 1.5;
                    const ec = (enemy.userData.collisionRadius != null) ? enemy.userData.collisionRadius : 0.8;
                    const dx = enemy.position.x - x;
                    const dy = enemy.position.y - y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist <= (er + ec + pr)) return true;
                }
            } catch (e) { /* ignore */ }
            return false;
        }

                // Ensure player is not touching the map borders; if so, teleport to nearest safe point
                function ensurePlayerNotOnBorder(borderBuffer = 0.6) {
                    try {
                        if (!player || !player.position) return false;
                        const sw = (window && window.innerWidth) ? (window.innerWidth / 40) : 20;
                        const sh = (window && window.innerHeight) ? (window.innerHeight / 40) : 15;
                        const minX = -(sw - borderBuffer);
                        const maxX = (sw - borderBuffer);
                        const minY = -(sh - borderBuffer);
                        const maxY = (sh - borderBuffer);
                        const px = player.position.x;
                        const py = player.position.y;
                // If player is touching border, nudge them slightly inward but allow movement away from border
                if (px <= minX || px >= maxX || py <= minY || py >= maxY) {
                    try {
                        // Nudge inward a small amount so player can move away naturally
                        const nudged = player.position.clone();
                        const inward = 0.3;
                        if (nudged.x <= minX) nudged.x = Math.min(minX + inward, maxX - 0.1);
                        if (nudged.x >= maxX) nudged.x = Math.max(maxX - inward, minX + 0.1);
                        if (nudged.y <= minY) nudged.y = Math.min(minY + inward, maxY - 0.1);
                        if (nudged.y >= maxY) nudged.y = Math.max(maxY - inward, minY + 0.1);
                        clampToMapVec(nudged, 0);
                        player.position.copy(nudged);
                        try { gameState._lastSafePlayerPos = nudged.clone(); } catch (e) {}
                        return true;
                    } catch (e) { /* ignore */ }
                }
                    } catch (e) { /* ignore */ }
                    return false;
                }

        // Return map bounds object {minX,maxX,minY,maxY} based on viewport
        function getMapBounds() {
            const sw = (window && window.innerWidth) ? (window.innerWidth / 40) : 20;
            const sh = (window && window.innerHeight) ? (window.innerHeight / 40) : 15;
            return { minX: -sw, maxX: sw, minY: -sh, maxY: sh };
        }

        // Prevent movement that would push `nextVec` further out past the map borders relative to `currentVec`.
        // This allows movement that brings the player back inward but blocks movement that increases border penetration.
        function preventFurtherIntoBorder(currentVec, nextVec, buffer = 0.001) {
            try {
                const b = getMapBounds();
                // X axis
                if (currentVec.x >= (b.maxX - buffer) && nextVec.x > currentVec.x) nextVec.x = currentVec.x;
                if (currentVec.x <= (b.minX + buffer) && nextVec.x < currentVec.x) nextVec.x = currentVec.x;
                // Y axis
                if (currentVec.y >= (b.maxY - buffer) && nextVec.y > currentVec.y) nextVec.y = currentVec.y;
                if (currentVec.y <= (b.minY + buffer) && nextVec.y < currentVec.y) nextVec.y = currentVec.y;
            } catch (e) { /* ignore */ }
        }

        // Find nearest safe point around `center` by spiral sampling up to `maxRadius` (returns a clone)
        // If `maxRadius` is omitted, search up to the full map extents (covers borders).
        function findNearestSafePoint(centerVec, maxRadius, step = 0.5) {
            try {
                // Default maxRadius: cover whole play area (map extents based on viewport)
                if (maxRadius == null || !(typeof maxRadius === 'number') || maxRadius <= 0) {
                    try {
                        const viewWidth = (window && window.innerWidth) ? (window.innerWidth / 40) : 20;
                        const viewHeight = (window && window.innerHeight) ? (window.innerHeight / 40) : 15;
                        // multiply by 2 to ensure we can reach from one border to the opposite
                        maxRadius = Math.max(viewWidth, viewHeight) * 2;
                    } catch (e) {
                        maxRadius = 60; // fallback large radius
                    }
                }

                const c = centerVec.clone();
                clampToMapVec(c, 0);
                if (!pointIsBlocked(c.x, c.y)) return c;
                for (let r = step; r <= maxRadius; r += step) {
                    const segments = Math.max(8, Math.ceil(2 * Math.PI * r / step));
                    for (let s = 0; s < segments; s++) {
                        const ang = (s / segments) * Math.PI * 2;
                        const cand = c.clone().add(new THREE.Vector3(Math.cos(ang) * r, Math.sin(ang) * r, 0));
                        clampToMapVec(cand, 0);
                        if (!pointIsBlocked(cand.x, cand.y)) return cand;
                    }
                }
            } catch (e) { /* ignore */ }
            // As a last resort return clamped center
            const fallback = centerVec.clone(); clampToMapVec(fallback, 0); return fallback;
        }

        // Teleport player to a safe point: if `targetVec` is blocked, find nearest safe point and teleport there.
        function safeTeleportTo(targetVec) {
            try {
                if (!targetVec || !player) return false;
                const cand = targetVec.clone();
                clampToMapVec(cand, 0);
                    if (pointIsBlocked(cand.x, cand.y)) {
                    const safe = findNearestSafePoint(cand);
                    try { clampToMapVec(safe, 0); player.position.copy(safe); } catch (e) { player.position.copy(cand); }
                    try { effectsManager.createWave(player.position, 1.2); screenShake(0.6, 160); } catch (e) {}
                    return true;
                } else {
                    try { player.position.copy(cand); } catch (e) { /* ignore */ }
                    try { effectsManager.createWave(player.position, 1.2); screenShake(0.6, 160); } catch (e) {}
                    return true;
                }
            } catch (e) { console.warn('safeTeleportTo error', e); return false; }
        }

        // Smooth dash helper: move player from current position to `targetVec` over `duration` ms
        // onComplete called when finished
        function performDashTo(targetVec, duration = 180, onComplete) {
            try {
                // Clamp target within map bounds before starting
                const end = targetVec.clone();
                clampToMapVec(end, 0);
                // Pre-adjust end: if end is inside blocked geometry, step it back toward start or find a global safe
                try {
                    const startTmp = player.position ? player.position.clone() : new THREE.Vector3(0,0,0);
                    const dashDirPre = end.clone().sub(startTmp);
                    const dashLen = dashDirPre.length();
                    if (dashLen > 0 && (pointIsBlocked(end.x, end.y) || pointWouldBeInDanger(end.x, end.y))) {
                        dashDirPre.normalize();
                        let foundEnd = null;
                        const stepSize = 0.25;
                        const maxSteps = Math.ceil(Math.max(24, dashLen / stepSize) * 2);
                            for (let i = 1; i <= maxSteps; i++) {
                                const cand = end.clone().sub(dashDirPre.clone().multiplyScalar(stepSize * i));
                                clampToMapVec(cand, 0);
                                if (!pointIsBlocked(cand.x, cand.y) && !pointWouldBeInDanger(cand.x, cand.y)) { foundEnd = cand; break; }
                            }
                        if (foundEnd) {
                            end.copy(foundEnd);
                        } else {
                            const safeEnd = findNearestSafePoint(end);
                            if (safeEnd && !pointIsBlocked(safeEnd.x, safeEnd.y) && !pointWouldBeInDanger(safeEnd.x, safeEnd.y)) {
                                end.copy(safeEnd);
                            } else {
                                // fallback to clamped start
                                end.copy(startTmp);
                            }
                        }
                    }
                } catch (e) { /* ignore pre-adjust */ }
                const start = player.position.clone();
                const startTime = Date.now();
                // Helper: check collision against barriers and enemies for a given point
                function wouldCollideAt(x, y) {
                    try {
                        const pr = (player && player.userData && player.userData.collisionRadius) ? player.userData.collisionRadius : 0.9;
                        // Check barriers
                        if (window.gameState && Array.isArray(window.gameState.barriers)) {
                            for (const b of window.gameState.barriers) {
                                try {
                                    if (!b || !b.userData) continue;
                                    const width = (b.userData.width != null) ? b.userData.width : 4;
                                    const height = (b.userData.height != null) ? b.userData.height : 0.5;
                                    // Transform point into barrier local space (rotate by -rotation.z)
                                    const dx = x - b.position.x;
                                    const dy = y - b.position.y;
                                    const angle = - (b.rotation ? b.rotation.z : 0);
                                    const localX = dx * Math.cos(angle) - dy * Math.sin(angle);
                                    const localY = dx * Math.sin(angle) + dy * Math.cos(angle);
                                    if (Math.abs(localX) <= (width / 2 + pr) && Math.abs(localY) <= (height / 2 + pr)) {
                                        return true;
                                    }
                                } catch (e) { continue; }
                            }
                        }
                        // Check enemies' collision radii to avoid overlapping
                        if (window.gameState && Array.isArray(window.gameState.enemies)) {
                            for (const e of window.gameState.enemies) {
                                try {
                                    if (!e || !e.userData) continue;
                                    const er = (e.userData.collisionRadius != null) ? e.userData.collisionRadius : 0.8;
                                    const dx = e.position.x - x;
                                    const dy = e.position.y - y;
                                    const dist = Math.sqrt(dx*dx + dy*dy);
                                    if (dist <= (er + pr)) return true;
                                } catch (e2) { continue; }
                            }
                        }
                    } catch (e) { /* ignore */ }
                    return false;
                }

                // Mark dash active and create cancel token on gameState so other systems can cancel it
                try { gameState._dashActive = true; gameState._dashCancel = false; } catch(e) {}
                let lastSafe = player.position.clone();
                const tick = () => {
                    // If dash was cancelled externally, abort and teleport player to nearest safe
                    try {
                        if (gameState && gameState._dashCancel) {
                            // clear active flag
                            try { gameState._dashActive = false; gameState._dashCancel = false; } catch(e) {}
                            const fallback = findNearestSafePoint(player.position);
                            try { safeTeleportTo(fallback); } catch (e) { /* ignore */ }
                            if (typeof onComplete === 'function') {
                                try { onComplete(); } catch (e) { console.warn('performDashTo onComplete error after cancel', e); }
                            }
                            return;
                        }
                    } catch (e) {}
                    const t = Math.min(1, (Date.now() - startTime) / duration);
                        const next = start.clone().lerp(end, t);
                    // Clamp each interpolation step to ensure we never slide outside the allowed play area
                    clampToMapVec(next, 0);
                        try { preventFurtherIntoBorder(player.position.clone(), next); } catch (e) {}
                    // If next position would collide with a barrier/enemy, try to find nearest safe point
                    if (wouldCollideAt(next.x, next.y) || pointWouldBeInDanger(next.x, next.y)) {
                        // Step-back along dash direction
                        try {
                            const dashDir = end.clone().sub(start).normalize();
                            const stepSize = 0.25;
                            let found = null;
                            for (let i = 1; i <= 24; i++) {
                                const cand = next.clone().sub(dashDir.clone().multiplyScalar(stepSize * i));
                                clampToMapVec(cand, 0);
                                if (!wouldCollideAt(cand.x, cand.y) && !pointWouldBeInDanger(cand.x, cand.y)) { found = cand; break; }
                            }
                            if (!found) {
                                // Spiral search around lastSafe (global radius)
                                const spiral = findNearestSafePoint(lastSafe);
                                if (spiral && !wouldCollideAt(spiral.x, spiral.y) && !pointWouldBeInDanger(spiral.x, spiral.y)) found = spiral;
                            }
                            if (found) {
                                player.position.copy(found);
                            } else {
                                // Stronger fallback: try teleporting to nearest safe point from next
                                try {
                                    const safeNow = findNearestSafePoint(next);
                                    if (safeNow && !pointIsBlocked(safeNow.x, safeNow.y)) {
                                        safeTeleportTo(safeNow);
                                    } else if (gameState && gameState._lastSafePlayerPos) {
                                        safeTeleportTo(gameState._lastSafePlayerPos.clone());
                                    } else {
                                        // final fallback: clamp to map and stay at next
                                        try { clampToMapVec(next, 0); player.position.copy(next); } catch(e) { /* ignore */ }
                                    }
                                } catch (e) {
                                    try { player.position.copy(lastSafe); } catch (ex) { player.position.copy(next); }
                                }
                            }
                        } catch (e) {
                            try { player.position.copy(lastSafe); } catch (ex) { player.position.copy(next); }
                        }

                        // Final clamp and small visual
                        try { clampToMapVec(player.position, 0); effectsManager.createWave(player.position, 0.6); } catch(e) {}
                        // clear dash active flag
                        try { gameState._dashActive = false; } catch (e) {}
                        if (typeof onComplete === 'function') {
                            try { onComplete(); } catch (e) { console.warn('performDashTo onComplete error', e); }
                        }
                        return;
                    }
                    player.position.copy(next);
                    lastSafe = player.position.clone();
                    if (t < 1) {
                        requestAnimationFrame(tick);
                    } else {
                        // Ensure final position is clamped
                        try { clampToMapVec(player.position, 0); } catch(e) {}
                        // clear dash active flag
                        try { gameState._dashActive = false; } catch (e) {}
                        if (typeof onComplete === 'function') {
                            try { onComplete(); } catch (e) { console.warn('performDashTo onComplete error', e); }
                        }
                    }
                };
                requestAnimationFrame(tick);
            } catch (e) { console.warn('performDashTo failed', e); try { const tv = clampToMapVec(targetVec); player.position.copy(tv); } catch(ex){ try{ player.position.copy(targetVec); }catch(_){} } if (typeof onComplete === 'function') onComplete(); }
        }

        // Cancel any active dash and force player to nearest safe point
        function cancelCurrentDashAndRescue() {
            try {
                if (gameState) {
                    gameState._dashCancel = true;
                    // clear invuln timers
                    if (Array.isArray(gameState._invulnTimers)) {
                        while (gameState._invulnTimers.length) {
                            try { clearTimeout(gameState._invulnTimers.pop()); } catch (e) {}
                        }
                    }
                    gameState.isInvulnerable = false;
                }
                try { player.material.emissiveIntensity = 0; } catch (e) {}
                const safe = findNearestSafePoint(player.position);
                try { safeTeleportTo(safe); } catch (e) { /* ignore */ }
            } catch (e) { /* ignore */ }
        }

        // Eject player from overlapping barriers/enemies if stuck inside geometry
        function ejectPlayerFromBarriers() {
            try {
                if (!player || !player.position) return false;
                const pr = (player.userData && player.userData.collisionRadius) ? player.userData.collisionRadius : 0.9;
                if (!gameState) return false;

                // Accumulate push vectors from overlaps
                let pushVec = new THREE.Vector3(0,0,0);
                let overlapping = false;

                if (Array.isArray(gameState.barriers)) {
                    for (const b of gameState.barriers) {
                        try {
                            if (!b || !b.userData) continue;
                            const width = (b.userData.width != null) ? b.userData.width : 4;
                            const height = (b.userData.height != null) ? b.userData.height : 0.5;
                            const dx = player.position.x - b.position.x;
                            const dy = player.position.y - b.position.y;
                            const angle = - (b.rotation ? b.rotation.z : 0);
                            const localX = dx * Math.cos(angle) - dy * Math.sin(angle);
                            const localY = dx * Math.sin(angle) + dy * Math.cos(angle);
                            const overlapX = (width / 2 + pr) - Math.abs(localX);
                            const overlapY = (height / 2 + pr) - Math.abs(localY);
                            if (overlapX > 0 && overlapY > 0) {
                                overlapping = true;
                                // push along smallest penetration axis in barrier local space
                                if (overlapX < overlapY) {
                                    const dir = (localX >= 0) ? 1 : -1; // push to +x or -x
                                    // convert local direction to world
                                    const worldDir = new THREE.Vector3(dir, 0, 0);
                                    worldDir.applyAxisAngle(new THREE.Vector3(0,0,1), -angle);
                                    pushVec.add(worldDir.multiplyScalar(overlapX + 0.05));
                                } else {
                                    const dir = (localY >= 0) ? 1 : -1;
                                    const worldDir = new THREE.Vector3(0, dir, 0);
                                    worldDir.applyAxisAngle(new THREE.Vector3(0,0,1), -angle);
                                    pushVec.add(worldDir.multiplyScalar(overlapY + 0.05));
                                }
                            }
                        } catch (e) { continue; }
                    }
                }

                // Also consider enemy overlaps so player isn't stuck inside enemies
                if (Array.isArray(gameState.enemies)) {
                    for (const e of gameState.enemies) {
                        try {
                            if (!e || !e.userData) continue;
                            const er = (e.userData.collisionRadius != null) ? e.userData.collisionRadius : 0.8;
                            const dx = player.position.x - e.position.x;
                            const dy = player.position.y - e.position.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            const overlap = (er + pr) - dist;
                            if (overlap > 0) {
                                overlapping = true;
                                // push directly away from enemy
                                const nx = dx / (dist || 0.001);
                                const ny = dy / (dist || 0.001);
                                pushVec.add(new THREE.Vector3(nx * (overlap + 0.05), ny * (overlap + 0.05), 0));
                            }
                        } catch (e) { continue; }
                    }
                }

                if (overlapping) {
                    // Apply averaged push
                    try {
                        pushVec.multiplyScalar(1); // could scale down if needed
                        const attempt = player.position.clone().add(pushVec);
                        clampToMapVec(attempt, 0);
                        player.position.copy(attempt);
                        // If still blocked, teleport to nearest safe point
                        if (pointIsBlocked(player.position.x, player.position.y)) {
                            try {
                                const safe = findNearestSafePoint(player.position);
                                clampToMapVec(safe, 0);
                                player.position.copy(safe);
                                try { effectsManager.createWave(player.position, 1.2); } catch(e) {}
                            } catch (e) { /* ignore */ }
                        } else {
                            try { effectsManager.createWave(player.position, 0.8); } catch(e) {}
                        }
                        return true;
                    } catch (e) { /* ignore */ }
                }
            } catch (e) { /* ignore */ }
            return false;
        }

        const classes = {
            electric: {
                name: 'Electric',
                abilities: {
                    zap: {
                        cooldown: 3000,
                        lastUsed: 0,
                        damage: 50,
                        range: 10,
                        chainRange: 6,
                        maxChains: 3,
                        icon: 'ZAP',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            let closest = null;
                            let closestDist = Infinity;
                            
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = player.position.distanceTo(enemy.position);
                                if (dist < closestDist && dist <= this.range) {
                                    closest = enemy;
                                    closestDist = dist;
                                }
                            });
                            
                            if (closest) {
                                effectsManager.createLightningBolt(player.position, closest.position);
                                damageEnemy(closest, this.damage);
                                
                                let hitEnemies = [closest];
                                let currentSource = closest;
                                
                                for (let i = 0; i < this.maxChains; i++) {
                                    let nextTarget = null;
                                    let nextDist = Infinity;
                                    
                                    gameState.enemies.forEach(enemy => {
                                        if (hitEnemies.includes(enemy)) return;
                                        if (!isEnemyOnScreen(enemy)) return;
                                        const dist = currentSource.position.distanceTo(enemy.position);
                                        if (dist < nextDist && dist <= this.chainRange) {
                                            nextTarget = enemy;
                                            nextDist = dist;
                                        }
                                    });
                                    
                                    if (nextTarget) {
                                        setTimeout(() => {
                                            effectsManager.createLightningBolt(currentSource.position, nextTarget.position);
                                            damageEnemy(nextTarget, this.damage * 0.7);
                                            
                                            // Evolution: Create explosion at each chain target
                                            if (classExp.electric.evolution > 0) {
                                                const explosionRange = 4;
                                                effectsManager.createExplosion(nextTarget.position, 0xffff00);
                                                gameState.enemies.forEach(nearbyEnemy => {
                                                    if (nearbyEnemy !== nextTarget) {
                                                        const dist = nextTarget.position.distanceTo(nearbyEnemy.position);
                                                        if (dist <= explosionRange) {
                                                            damageEnemy(nearbyEnemy, this.damage * 0.5);
                                                        }
                                                    }
                                                });
                                            }
                                        }, 100 * (i + 1));
                                        
                                        hitEnemies.push(nextTarget);
                                        currentSource = nextTarget;
                                    } else {
                                        break;
                                    }
                                }
                            }
                            
                            return true;
                        }
                    },
                    lightningStrike: {
                        cooldown: 5000,
                        lastUsed: 0,
                        damage: 100,
                        targets: 3,
                        icon: 'STRIKE',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            if (gameState.enemies.length === 0) return true;
                            
                            // Select random enemies
                            const shuffled = [...gameState.enemies].sort(() => Math.random() - 0.5);
                            const targets = shuffled.slice(0, Math.min(this.targets, gameState.enemies.length));
                            
                            // Strike each target with a delay
                            targets.forEach((enemy, index) => {
                                setTimeout(() => {
                                    const strikePos = enemy.position.clone();
                                    strikePos.z += 10;
                                    effectsManager.createLightningBolt(strikePos, enemy.position);
                                    damageEnemy(enemy, this.damage);
                                }, 200 * index);
                            });
                            
                            return true;
                        }
                    },
                    superZap: {
                        cooldown: 8000,
                        lastUsed: 0,
                        damage: 50,
                        range: 15,
                        chainRange: 12.5,
                        maxChains: 1000,
                        icon: 'SUPER',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            let closest = null;
                            let closestDist = Infinity;
                            
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = player.position.distanceTo(enemy.position);
                                if (dist < closestDist && dist <= this.range) {
                                    closest = enemy;
                                    closestDist = dist;
                                }
                            });
                            
                            if (closest) {
                                effectsManager.createLightningBolt(player.position, closest.position);
                                damageEnemy(closest, this.damage);
                                
                                let hitEnemies = [closest];
                                let currentSource = closest;
                                
                                for (let i = 0; i < this.maxChains; i++) {
                                    let nextTarget = null;
                                    let nextDist = Infinity;
                                    
                                    gameState.enemies.forEach(enemy => {
                                        if (hitEnemies.includes(enemy)) return;
                                        if (!isEnemyOnScreen(enemy)) return;
                                        const dist = currentSource.position.distanceTo(enemy.position);
                                        if (dist < nextDist && dist <= this.chainRange) {
                                            nextTarget = enemy;
                                            nextDist = dist;
                                        }
                                    });
                                    
                                    if (nextTarget) {
                                        const source = currentSource;
                                        const target = nextTarget;
                                        setTimeout(() => {
                                            effectsManager.createLightningBolt(source.position, target.position);
                                            damageEnemy(target, this.damage * 0.6);
                                        }, 100 * (i + 1));
                                        
                                        hitEnemies.push(nextTarget);
                                        currentSource = nextTarget;
                                    } else {
                                        break;
                                    }
                                }
                            }
                            
                            return true;
                        }
                    }
                }
            },
            miner: {
                name: 'Miner',
                passiveMeleeDamage: 22,
                abilities: {
                    dig: {
                        cooldown: 10000,
                        lastUsed: 0,
                        icon: 'DIG',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            this.lastUsed = now;

                            // Teleport player to last clicked world position (buried dig)
                            if (lastClickWorld) {
                                // Teleport to a safe spot near the clicked world position
                                safeTeleportTo(lastClickWorld);
                            } else {
                                alert('No target selected. Click on the ground to set the target.');
                                return false;
                            }
                            return true;
                        }
                    },
                    drill: {
                        cooldown: 15000,
                        lastUsed: 0,
                        icon: 'DRILL',
                        duration: 6000,
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            this.lastUsed = now;
                            // Upgrade shovel to drill for a short duration
                            const dur = this.duration || 6000; // use configured duration
                            if (!player.userData) player.userData = {};
                            player.userData.drillUntil = now + dur;
                            effectsManager.createWave(player.position, 2);
                            screenShake(0.9, 220);
                            return true;
                        }
                    },
                    mine: {
                        cooldown: 5000,
                        lastUsed: 0,
                        icon: 'MINE',
                        damage: 90,
                        triggerRadius: 1.0,
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            this.lastUsed = now;

                            // Place a buried mine at the last clicked world position
                            if (!lastClickWorld) {
                                alert('No target selected. Click on the ground to set the target.');
                                return false;
                            }
                            const pos = lastClickWorld.clone();
                            const geom = new THREE.CircleGeometry(0.5, 12);
                            const mat = new THREE.MeshBasicMaterial({ color: 0xffcc00 });
                            const mine = new THREE.Mesh(geom, mat);
                            mine.position.copy(pos);
                            mine.position.z = 0.01;
                            scene.add(mine);
                            const mineObj = { mesh: mine, active: true, triggerRadius: this.triggerRadius || 1.0, damage: this.damage || 90 };
                            gameState.mines.push(mineObj);
                            // subtle bury effect
                            effectsManager.createWave(pos, 1.2);
                            return true;
                        }
                    }
                }
            },
            fire: {
                name: 'Fire',
                abilities: {
                    singe: {
                        cooldown: 1000,
                        lastUsed: 0,
                        damage: 15,
                        burnDamage: 5,
                        burnDuration: 5000,
                        range: 10,
                        icon: 'SINGE',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            let hitCount = 0;
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = player.position.distanceTo(enemy.position);
                                if (dist <= this.range) {
                                    hitCount++;
                                    
                                    // Create fire effect
                                    effectsManager.createWave(enemy.position, 1);
                                    
                                    if (enemy.userData.burning) {
                                        // Deal all burn damage instantly if already burning
                                        const remainingBurn = Math.ceil((enemy.userData.burnEnd - now) / 1000) * this.burnDamage;
                                        damageEnemy(enemy, this.damage + remainingBurn);
                                        enemy.userData.burning = false;
                                    } else {
                                        // Apply initial damage and start burn
                                        damageEnemy(enemy, this.damage);
                                        enemy.userData.burning = true;
                                        enemy.userData.burnEnd = now + this.burnDuration;
                                        enemy.userData.burnDamage = this.burnDamage;
                                        enemy.userData.lastBurnTick = now;
                                    }
                                }
                            });
                            
                            if (hitCount > 0) {
                                screenShake(0.2 + hitCount * 0.05, 120);
                                effectsManager.createWave(player.position, this.range);
                                
                                // Reduce cooldown if hit 3+ enemies
                                if (hitCount >= 3) {
                                    const reduction = this.cooldown * 0.5;
                                    this.lastUsed -= reduction;
                                    reduceCooldownDisplay('ability1', reduction);
                                }
                            }
                            
                            return true;
                        }
                    },
                    healingFire: {
                        cooldown: 5000,
                        lastUsed: 0,
                        damage: 20,
                        healMultiplier: 2,
                        icon: 'HEAL',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            let burnedCount = 0;
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                if (enemy.userData.burning) {
                                    burnedCount++;
                                }
                            });
                            
                            if (burnedCount > 0) {
                                screenShake(0.4 + burnedCount * 0.1, 250);
                                // Heal player
                                hpManager.heal(burnedCount * this.healMultiplier);
                                effectsManager.createWave(player.position, 2);
                                
                                // Damage burned enemies
                                gameState.enemies.forEach(enemy => {
                                    if (!isEnemyOnScreen(enemy)) return;
                                    if (enemy.userData.burning) {
                                        effectsManager.createExplosion(enemy.position, 0xff6600);
                                        damageEnemy(enemy, this.damage);
                                    }
                                });
                            }
                            
                            return true;
                        }
                    },
                    fireballs: {
                        cooldown: 8000,
                        lastUsed: 0,
                        damage: 35,
                        burnDamage: 5,
                        burnDuration: 3000,
                        speed: 0.25,
                        fireballs: 5,
                        icon: 'FIRE',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            // Find three closest enemies to auto-aim at
                            if (gameState.enemies.length === 0) return true;
                            
                            const sortedEnemies = [...gameState.enemies].filter(enemy => isEnemyOnScreen(enemy)).sort((a, b) => {
                                const distA = player.position.distanceTo(a.position);
                                const distB = player.position.distanceTo(b.position);
                                return distA - distB;
                            });
                            
                            const targets = sortedEnemies.slice(0, Math.min(this.fireballs, gameState.enemies.length));
                            screenShake(0.9, 350);
                            const sharedHitCount = { count: 0 };
                            
                            targets.forEach((target, index) => {
                                setTimeout(() => {
                                    const direction = new THREE.Vector3()
                                        .subVectors(target.position, player.position)
                                        .normalize();
                                    
                                    const projectile = effectsManager.createFireball(player.position.clone(), direction, this.speed);
                                    projectile.scale.set(2, 2, 2); // Giant fireball
                                    
                                    Object.assign(projectile.userData, {
                                        damage: this.damage,
                                        burnDamage: this.burnDamage,
                                        burnDuration: this.burnDuration,
                                        lifetime: 5000,
                                        created: Date.now(),
                                        isFireball: true,
                                        abilityRef: this,
                                        abilityId: 'ability3',
                                        hitThreshold: 5,
                                        cooldownReduction: 0.5,
                                        sharedHitCount: sharedHitCount,
                                        isEvolved: classExp.fire.evolution > 0,
                                        explosionRange: 10
                                    });
                                    
                                    gameState.projectiles.push(projectile);
                                }, index * 150);
                            });
                            
                            return true;
                        }
                    }
                }
            },
            pierce: {
                name: 'Pierce',
                abilities: {
                    pierceShot: {
                        cooldown: 2000,
                        lastUsed: 0,
                        damage: 25,
                        maxPierce: 5,
                        speed: 0.4,
                        icon: 'PIERCE',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            if (gameState.enemies.length === 0) return true;
                            
                            const closest = gameState.enemies.reduce((prev, curr) => {
                                const prevDist = player.position.distanceTo(prev.position);
                                const currDist = player.position.distanceTo(curr.position);
                                return currDist < prevDist ? curr : prev;
                            });
                            
                            const direction = new THREE.Vector3()
                                .subVectors(closest.position, player.position)
                                .normalize();
                            
                            screenShake(0.2, 100);
                            
                            const geometry = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
                            const material = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                            const arrow = new THREE.Mesh(geometry, material);
                            arrow.position.copy(player.position);
                            arrow.rotation.z = Math.atan2(direction.y, direction.x) - Math.PI / 2;
                            
                            scene.add(arrow);
                            
                            arrow.userData = {
                                direction: direction,
                                speed: this.speed,
                                damage: this.damage,
                                pierceCount: 0,
                                maxPierce: this.maxPierce,
                                hitEnemies: [],
                                created: now,
                                lifetime: 5000,
                                isPiercing: true,
                                abilityRef: this,
                                abilityId: 'ability1',
                                hitThreshold: 3,
                                cooldownReduction: 0.5
                            };
                            
                            gameState.projectiles.push(arrow);
                            return true;
                        }
                    },
                    multiShot: {
                        cooldown: 4000,
                        lastUsed: 0,
                        damage: 20,
                        speed: 0.50,
                        icon: 'MULTI',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            if (gameState.enemies.length === 0) return true;
                            
                            // Find 5 closest enemies for auto-aim
                            const sortedEnemies = [...gameState.enemies].sort((a, b) => {
                                const distA = player.position.distanceTo(a.position);
                                const distB = player.position.distanceTo(b.position);
                                return distA - distB;
                            });
                            
                            const targets = sortedEnemies.slice(0, Math.min(5, gameState.enemies.length));
                            screenShake(0.4, 180);
                            const sharedHitCount = { count: 0 };
                            
                            // Evolution: Shoot in 360-degree spiral pattern
                            if (classExp.pierce.evolution > 0) {
                                const arrowCount = 16;
                                for (let i = 0; i < arrowCount; i++) {
                                    const angle = (Math.PI * 2 / arrowCount) * i;
                                    const direction = new THREE.Vector3(Math.cos(angle), Math.sin(angle), 0).normalize();
                                    
                                    const geometry = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
                                    const material = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                                    const arrow = new THREE.Mesh(geometry, material);
                                    arrow.position.copy(player.position);
                                    arrow.rotation.z = Math.atan2(direction.y, direction.x) - Math.PI / 2;
                                    
                                    scene.add(arrow);
                                    
                                    arrow.userData = {
                                        direction: direction,
                                        speed: this.speed,
                                        damage: this.damage,
                                        pierceCount: 0,
                                        maxPierce: 3,
                                        hitEnemies: [],
                                        created: now,
                                        lifetime: 5000,
                                        isPiercing: true,
                                        abilityRef: this,
                                        abilityId: 'ability2',
                                        hitThreshold: 8,
                                        cooldownReduction: 0.5,
                                        sharedHitCount: sharedHitCount
                                    };
                                    
                                    gameState.projectiles.push(arrow);
                                }
                                screenShake(0.6, 250);
                                
                                // Evolution: Heal 30 HP after attacking
                                hpManager.heal(30);
                                
                                return true;
                            }
                            
                            targets.forEach((target) => {
                                const direction = new THREE.Vector3()
                                    .subVectors(target.position, player.position)
                                    .normalize();
                                
                                const geometry = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
                                const material = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                                const arrow = new THREE.Mesh(geometry, material);
                                arrow.position.copy(player.position);
                                arrow.rotation.z = Math.atan2(direction.y, direction.x) - Math.PI / 2;
                                
                                scene.add(arrow);
                                
                                arrow.userData = {
                                    direction: direction,
                                    speed: this.speed,
                                    damage: this.damage,
                                    pierceCount: 0,
                                    maxPierce: 3,
                                    hitEnemies: [],
                                    created: now,
                                    lifetime: 5000,
                                    isPiercing: true,
                                    abilityRef: this,
                                    abilityId: 'ability2',
                                    hitThreshold: 8,
                                    cooldownReduction: 0.5,
                                    sharedHitCount: sharedHitCount
                                };
                                
                                gameState.projectiles.push(arrow);
                            });
                            
                            return true;
                        }
                    },
                    arrowStorm: {
                        cooldown: 8000,
                        lastUsed: 0,
                        damage: 15,
                        speed: 0.50,
                        icon: 'STORM',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            if (gameState.enemies.length === 0) return true;
                            
                            // Find 15 closest enemies for auto-aim (or all if fewer)
                            const sortedEnemies = [...gameState.enemies].sort((a, b) => {
                                const distA = player.position.distanceTo(a.position);
                                const distB = player.position.distanceTo(b.position);
                                return distA - distB;
                            });
                            
                            const targets = sortedEnemies.slice(0, Math.min(15, gameState.enemies.length));
                            screenShake(0.8, 350);
                            const sharedHitCount = { count: 0 };
                            
                            targets.forEach((target) => {
                                const direction = new THREE.Vector3()
                                    .subVectors(target.position, player.position)
                                    .normalize();
                                
                                const geometry = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
                                const material = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                                const arrow = new THREE.Mesh(geometry, material);
                                arrow.position.copy(player.position);
                                arrow.rotation.z = Math.atan2(direction.y, direction.x) - Math.PI / 2;
                                
                                scene.add(arrow);
                                
                                arrow.userData = {
                                    direction: direction,
                                    speed: this.speed,
                                    damage: this.damage,
                                    pierceCount: 0,
                                    maxPierce: 3,
                                    hitEnemies: [],
                                    created: now,
                                    lifetime: 5000,
                                    isPiercing: true,
                                    abilityRef: this,
                                    abilityId: 'ability3',
                                    hitThreshold: 10,
                                    cooldownReduction: 0.5,
                                    sharedHitCount: sharedHitCount
                                };
                                
                                gameState.projectiles.push(arrow);
                            });
                            
                            return true;
                        }
                    }
                }
            },
            engineer: {
                name: 'Engineer',
                abilities: {
                    q: {
                        name: 'Deploy Turret',
                        cooldown: 10000,
                        lastUsed: 0,
                        icon: 'TURRET',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            // Determine max turret limit: prefer configured ability property, else fallback to level-based heuristic
                            const engineerLevel = (classExp && classExp.engineer) ? classExp.engineer.level : 1;
                            const hasEvolution = (classExp && classExp.engineer) ? classExp.engineer.evolution > 0 : false;
                            const fallbackMax = (hasEvolution ? 3 : (engineerLevel >= 10 ? 2 : 1)) + 3;
                            const allowedMaxTurrets = (this.maxTurrets != null) ? this.maxTurrets : fallbackMax;

                            // Remove oldest turret if at limit
                            if (gameState.turrets.length >= allowedMaxTurrets) {
                                const oldestTurret = gameState.turrets.shift();
                                try { scene.remove(oldestTurret); } catch(e) {}
                                try { effectsManager.createExplosion(oldestTurret.position, 0xff6600); } catch(e) {}
                            }
                            
                            // Create turret at player position
                            const turretGeometry = new THREE.BoxGeometry(1, 1, 1);
                            const turretMaterial = new THREE.MeshPhongMaterial({ 
                                color: 0xffa500,
                                emissive: 0xff8800,
                                emissiveIntensity: 0.3
                            });
                            const turret = new THREE.Mesh(turretGeometry, turretMaterial);
                            turret.position.set(
                                gameState.player.position.x,
                                gameState.player.position.y,
                                0.5
                            );
                            
                            // Add nose to turret
                            const noseGeometry = new THREE.BoxGeometry(0.3, 0.6, 0.3);
                            const noseMaterial = new THREE.MeshPhongMaterial({ 
                                color: 0xff8800,
                                emissive: 0xff6600,
                                emissiveIntensity: 0.5
                            });
                            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
                            nose.position.set(0, 0.5, 0); // Position nose in front
                            turret.add(nose);
                            
                            turret.userData = {
                                isTurret: true,
                                collisionRadius: 0.9,
                                hp: (this.turretHp != null) ? this.turretHp : (this.turretBaseHp || 50),
                                maxHp: (this.turretHp != null) ? this.turretHp : (this.turretBaseHp || 50),
                                damage: (this.turretDamage != null) ? this.turretDamage : (this.turretDamage || 8),
                                range: (this.turretRange != null) ? this.turretRange : (this.range || 12),
                                attackCooldown: 0,
                                attackInterval: (this.turretAttackInterval != null) ? this.turretAttackInterval : (this.attackInterval || 1000),
                                level: 1
                            };
                            
                            scene.add(turret);
                            gameState.turrets.push(turret);
                            
                            screenShake(0.2, 150);
                            effectsManager.createExplosion(turret.position, 0xffa500);
                            
                            return true;
                        }
                    },
                    e: {
                        name: 'Heal Turret',
                        cooldown: 4000,
                        lastUsed: 0,
                        icon: 'HEAL',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            // Find nearest turret
                            let nearestTurret = null;
                            let minDist = Infinity;
                            
                            gameState.turrets.forEach(turret => {
                                if (!isEnemyOnScreen(turret)) return;
                                const dist = gameState.player.position.distanceTo(turret.position);
                                if (dist < minDist) {
                                    minDist = dist;
                                    nearestTurret = turret;
                                }
                            });
                            
                            if (nearestTurret && minDist <= 10) {
                                this.lastUsed = now;
                                
                                // Heal turret
                                nearestTurret.userData.hp = Math.min(
                                    nearestTurret.userData.hp + 30,
                                    nearestTurret.userData.maxHp
                                );
                                
                                // Upgrade if full HP
                                if (nearestTurret.userData.hp === nearestTurret.userData.maxHp && nearestTurret.userData.level < 3) {
                                    nearestTurret.userData.level++;
                                    nearestTurret.userData.damage += 5;
                                    nearestTurret.userData.attackInterval = Math.max(500, nearestTurret.userData.attackInterval - 200);
                                    nearestTurret.scale.set(1 + nearestTurret.userData.level * 0.2, 1 + nearestTurret.userData.level * 0.2, 1 + nearestTurret.userData.level * 0.2);
                                }
                                
                                screenShake(0.15, 100);
                                effectsManager.createExplosion(nearestTurret.position, 0x00ff00);
                                
                                return true;
                            }
                            return false;
                        }
                    },
                    r: {
                        name: 'Machine Gun',
                        cooldown: 15000, // 15 second reload time
                        lastUsed: 0,
                        icon: 'MGUN',
                        execute: function() {
                            const now = Date.now();
                            
                            // Check if currently reloading
                            if (gameState.machineGunAmmo <= 0 && now - this.lastUsed < this.cooldown) {
                                return false; // Still reloading
                            }
                            
                            // Refill ammo if empty and reload cooldown finished
                            if (gameState.machineGunAmmo <= 0 && now - this.lastUsed >= this.cooldown) {
                                gameState.machineGunAmmo = gameState.maxMachineGunAmmo;
                                document.getElementById('ammoCount').textContent = gameState.machineGunAmmo;
                            }
                            
                            // Fire single bullet if ammo available
                            if (gameState.machineGunAmmo > 0) {
                                // Check fire rate
                                if (now - gameState.machineGunLastFired < gameState.machineGunFireRate) {
                                    return false; // Too soon to fire again
                                }
                                
                                gameState.machineGunLastFired = now;
                                
                                // Find nearest enemy
                                let nearestEnemy = null;
                                let minDist = Infinity;
                                
                                gameState.enemies.forEach(enemy => {
                                    if (!isEnemyOnScreen(enemy)) return;
                                    const dist = gameState.player.position.distanceTo(enemy.position);
                                    if (dist < minDist) {
                                        minDist = dist;
                                        nearestEnemy = enemy;
                                    }
                                });
                                
                                // Fire in direction of enemy or forward if no enemy
                                let direction;
                                if (nearestEnemy) {
                                    direction = new THREE.Vector3()
                                        .subVectors(nearestEnemy.position, gameState.player.position)
                                        .normalize();
                                } else {
                                    // Fire in player's facing direction (forward)
                                    direction = new THREE.Vector3(0, 1, 0);
                                }
                                
                                // Add inaccuracy/spread
                                const spread = 0.15; // Adjust for more/less accuracy
                                direction.x += (Math.random() - 0.5) * spread;
                                direction.y += (Math.random() - 0.5) * spread;
                                direction.normalize();
                                
                                const bullet = effectsManager.createFireball(gameState.player.position.clone(), direction, 0.5);
                                bullet.userData = {
                                    direction: direction,
                                    speed: 0.5,
                                    damage: 5,
                                    created: Date.now(),
                                    lifetime: 2000
                                };
                                
                                gameState.projectiles.push(bullet);
                                gameState.machineGunAmmo--;
                                
                                // Update ammo display
                                document.getElementById('ammoCount').textContent = gameState.machineGunAmmo;
                                
                                // Start reload cooldown when ammo depletes
                                if (gameState.machineGunAmmo === 0) {
                                    this.lastUsed = Date.now();
                                    screenShake(0.1, 50);
                                    return 'reload'; // Special return value to trigger cooldown UI
                                }
                                
                                screenShake(0.1, 50);
                                return 'fired'; // Return different value to skip cooldown UI
                            }
                            return false;
                        }
                    }
                }
            },
            life: {
                name: 'Life',
                abilities: {
                    q: {
                        name: 'Kill',
                        cooldown: 2000,
                        lastUsed: 0,
                        icon: 'KILL',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            // Enable invulnerability
                            gameState.isInvulnerable = true;
                            
                            // Find nearest enemy
                            let nearestEnemy = null;
                            let minDist = Infinity;
                            
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = gameState.player.position.distanceTo(enemy.position);
                                if (dist < minDist) {
                                    minDist = dist;
                                    nearestEnemy = enemy;
                                }
                            });
                            
                            if (nearestEnemy) {
                                const damage = 100;
                                const targetPos = nearestEnemy.position.clone();
                                const targetMaxHp = nearestEnemy.userData.maxHp;
                                const targetHpBefore = nearestEnemy.userData.hp;
                                
                                // Deal damage
                                damageEnemy(nearestEnemy, damage);
                                
                                // Check if enemy died
                                if (targetHpBefore <= damage) {
                                    // Gain HP equal to half the target's max health
                                    hpManager.heal(targetMaxHp/2);
                                    
                                    // Teleport to target location with boundary checking
                                    const viewHeight = window.innerHeight / 40;
                                    const viewWidth = window.innerWidth / 40;
                                    const bounds = { 
                                        minX: -viewWidth + 1, 
                                        maxX: viewWidth - 1, 
                                        minY: -viewHeight + 1, 
                                        maxY: viewHeight - 1 
                                    };
                                    
                                    gameState.player.position.x = Math.max(bounds.minX, Math.min(bounds.maxX, targetPos.x));
                                    gameState.player.position.y = Math.max(bounds.minY, Math.min(bounds.maxY, targetPos.y));
                                    
                                    // AoE damage with lifesteal
                                    const aoeRange = 5;
                                    let totalHealed = 0;
                                    
                                    gameState.enemies.forEach(enemy => {
                                        if (!isEnemyOnScreen(enemy)) return;
                                        const dist = targetPos.distanceTo(enemy.position);
                                        if (dist <= aoeRange && enemy.userData.hp > 0) {
                                            const aoeDamage = 10;
                                            damageEnemy(enemy, aoeDamage);
                                            totalHealed += aoeDamage;
                                        }
                                    });
                                    
                                    // Lifesteal from AoE
                                    if (totalHealed > 0) {
                                        const healAmount = Math.floor(totalHealed * 0.6);
                                        hpManager.heal(healAmount);
                                    }
                                    
                                    // Visual effects
                                    effectsManager.createWave(targetPos, aoeRange);
                                    screenShake(0.8, 200);
                                } else {
                                    screenShake(0.3, 150);
                                }
                                
                                // Disable invulnerability after 500ms
                                setTimeout(() => {
                                    gameState.isInvulnerable = false;
                                }, 500);
                                
                                return true;
                            }
                            
                            // Disable invulnerability if no target found
                            gameState.isInvulnerable = false;
                            return false;
                        }
                    },
                    e: {
                        name: 'Life Burst',
                        cooldown: 5000,
                        lastUsed: 0,
                        icon: 'BURST',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            // AoE damage around player
                            const aoeRange = 8;
                            let totalHealed = 0;
                            
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = gameState.player.position.distanceTo(enemy.position);
                                if (dist <= aoeRange) {
                                    const damage = 50;
                                    damageEnemy(enemy, damage);
                                    totalHealed += damage;
                                }
                            });
                            
                            // Create expanding ring effect
                            effectsManager.createWave(gameState.player.position, aoeRange);
                            
                            // Lifesteal 50% of damage dealt
                            if (totalHealed > 0) {
                                const healAmount = Math.floor(totalHealed * 0.5);
                                hpManager.heal(healAmount);
                            }
                            
                            screenShake(0.6, 200);
                            return true;
                        }
                    },
                    r: {
                        name: 'Blood Frenzy',
                        cooldown: 8000,
                        lastUsed: 0,
                        icon: 'FRENZY',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            const blastRange = 25;
                            const blastCount = Math.floor(Math.random() * 11) + 20; // 20-30 blasts
                            const blastRadius = 10;
                            const blastDamage = classExp.life.evolution > 0 ? 30 : 25;
                            
                            // Evolution: Also convert enemies to allies
                            if (classExp.life.evolution > 0) {
                                const conversionRange = 10;
                                const enemiesToConvert = [];
                                gameState.enemies.forEach(enemy => {
                                    if (!isEnemyOnScreen(enemy)) return;
                                    const dist = gameState.player.position.distanceTo(enemy.position);
                                    if (dist <= conversionRange) {
                                        enemiesToConvert.push(enemy);
                                    }
                                });
                                
                                enemiesToConvert.forEach(enemy => {
                                    convertToAlly(enemy);
                                });
                                
                                if (enemiesToConvert.length > 0) {
                                    effectsManager.createWave(gameState.player.position, conversionRange);
                                }
                            }
                            
                            // Rain random blasts within range
                            const duration = 2000;
                            const blastInterval = duration / blastCount;
                            
                            for (let i = 0; i < blastCount; i++) {
                                setTimeout(() => {
                                    // Random position within range around player
                                    const angle = Math.random() * Math.PI * 2;
                                    const distance = Math.random() * blastRange;
                                    const blastPos = new THREE.Vector3(
                                        gameState.player.position.x + Math.cos(angle) * distance,
                                        gameState.player.position.y + Math.sin(angle) * distance,
                                        0
                                    );
                                    
                                    // Create explosion effect
                                    effectsManager.createExplosion(blastPos, 0xff0000);
                                    
                                    // Damage enemies in blast radius
                                    gameState.enemies.forEach(enemy => {
                                        if (!isEnemyOnScreen(enemy)) return;
                                        const dist = blastPos.distanceTo(enemy.position);
                                        if (dist <= blastRadius) {
                                            damageEnemy(enemy, blastDamage);
                                        }
                                    });
                                }, i * blastInterval);
                            }
                            
                            screenShake(0.8, duration);
                            return true;
                        }
                    }
                }
            },
            summoner: {
                name: 'Summoner',
                abilities: {
                    q: {
                        name: 'Attack Command (CMD)',
                        cooldown: 3500,
                        lastUsed: 0,
                        icon: 'CMD',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            this.lastUsed = now;
                            let didAttack = false;
                            if (gameState.allies && gameState.allies.length > 0 && gameState.enemies.length > 0) {
                                gameState.allies.forEach(ally => {
                                    // Prefer the enemy this ally was already targeting
                                    let finalTarget = null;
                                    const current = ally.userData && ally.userData.currentTarget ? ally.userData.currentTarget : null;
                                    if (current && gameState.enemies.includes(current)) {
                                        finalTarget = current;
                                    } else {
                                        // Fallback: nearest enemy to the ally
                                        let nearestEnemy = null;
                                        let minDist = Infinity;
                                        gameState.enemies.forEach(enemy => {
                                            const dist = ally.position.distanceTo(enemy.position);
                                            if (dist < minDist) {
                                                minDist = dist;
                                                nearestEnemy = enemy;
                                            }
                                        });
                                        finalTarget = nearestEnemy;
                                    }

                                    if (finalTarget) {
                                        // Allies now always spawn projectiles for CMD to avoid instant-kill melee
                                        // Weaken CMD damage too
                                        const dmg = ally.userData.isGuardian ? 50 : 20;

                                        // Direction from ally to target
                                        const direction = new THREE.Vector3()
                                            .subVectors(finalTarget.position, ally.position)
                                            .normalize();

                                        // Offset spawn so projectile doesn't immediately collide when spawned inside target
                                        const offsetDist = (ally.userData && ally.userData.collisionRadius ? ally.userData.collisionRadius : 0.6) + 0.25;
                                        const spawnPos = ally.position.clone();
                                        spawnPos.x += direction.x * offsetDist;
                                        spawnPos.y += direction.y * offsetDist;

                                        // Create projectile using existing effect helper for consistency
                                        const projectile = effectsManager.createFireball(spawnPos, direction, 0.35);
                                        projectile.userData = {
                                            direction: direction,
                                            speed: 0.45,
                                            damage: dmg,
                                            created: Date.now(),
                                            lifetime: 3000,
                                            isAllyProjectile: true,
                                            sourceAlly: ally
                                        };
                                        scene.add(projectile);
                                        gameState.projectiles.push(projectile);
                                        didAttack = true;
                                    }
                                });
                                screenShake(0.5, 180);
                            }
                            return didAttack;
                        }
                    },
                    e: {
                        name: 'Summon Squad+',
                        cooldown: 7000,
                        lastUsed: 0,
                        icon: 'SQUAD+',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            this.lastUsed = now;
                            // Summon minions (count, duration, HP, damage, attackInterval configurable by progression)
                            const minionGeometry = new THREE.TetrahedronGeometry(0.5, 0);
                            const minionMaterial = new THREE.MeshStandardMaterial({ color: 0x3b82f6, emissive: 0x2563eb, emissiveIntensity: 0.3, transparent: true, opacity: 1 });
                            const count = (this.minionCount != null) ? this.minionCount : 4;
                            for (let i = 0; i < count; i++) {
                                const angle = (Math.PI * 2 / count) * i;
                                const dist = 2;
                                const minion = new THREE.Mesh(minionGeometry, minionMaterial);
                                minion.position.set(
                                    gameState.player.position.x + Math.cos(angle) * dist,
                                    gameState.player.position.y + Math.sin(angle) * dist,
                                    0
                                );
                                minion.userData = {
                                    isAlly: true,
                                    allyUntil: now + (this.minionDurationMs || 22000),
                                    hp: (this.minionHp != null) ? this.minionHp : 60,
                                    maxHp: (this.minionHp != null) ? this.minionHp : 60,
                                    damage: (this.minionDamage != null) ? this.minionDamage : 10,
                                    speed: (this.minionSpeed != null) ? this.minionSpeed : 0.06,
                                    attackCooldown: 0,
                                    attackInterval: (this.minionAttackInterval != null) ? this.minionAttackInterval : 800,
                                    rotationSpeed: 0.02,
                                    isMinion: true,
                                    collisionRadius: (this.minionCollisionRadius != null) ? this.minionCollisionRadius : 0.6
                                };
                                scene.add(minion);
                                // Track minions separately so minion AI runs in updateMinions()
                                if (!gameState.minions) gameState.minions = [];
                                gameState.minions.push(minion);
                                effectsManager.createExplosion(minion.position, 0x3b82f6);
                            }
                            screenShake(0.5, 150);
                            return true;
                        }
                    },
                    r: {
                        name: 'Summon Guardian+',
                        cooldown: 12000,
                        lastUsed: 0,
                        icon: 'GUARD+',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            this.lastUsed = now;
                            // Guardian: 150 HP, attackInterval 600ms
                            const guardianGeometry = new THREE.DodecahedronGeometry(0.7, 0);
                            const guardianMaterial = new THREE.MeshStandardMaterial({ color: 0x2563eb, emissive: 0x3b82f6, emissiveIntensity: 0.5, transparent: true, opacity: 1 });
                            const guardian = new THREE.Mesh(guardianGeometry, guardianMaterial);
                            guardian.position.copy(gameState.player.position);
                            guardian.userData = {
                                isAlly: true,
                                allyUntil: now + (this.guardianDurationMs || 35000),
                                hp: (this.guardianHp != null) ? this.guardianHp : 150,
                                attackCooldown: 0,
                                attackInterval: (this.guardianAttackInterval != null) ? this.guardianAttackInterval : 600,
                                rotationSpeed: 0.01,
                                isGuardian: true,
                                collisionRadius: (this.guardianCollisionRadius != null) ? this.guardianCollisionRadius : 1.1
                            };
                            scene.add(guardian);
                            gameState.allies.push(guardian);
                            effectsManager.createExplosion(guardian.position, 0x3b82f6);
                            screenShake(0.8, 220);
                            return true;
                        }
                    }
                }
            },
            water: {
                name: 'Water',
                abilities: {
                    q: {
                        name: 'Water Blast',
                        cooldown: 2000,
                        lastUsed: 0,
                        icon: 'BLAST',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            // Knockback enemies in cone in front of player
                            const range = 8;
                            const knockback = 6;
                            let hit = false;
                            
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = gameState.player.position.distanceTo(enemy.position);
                                if (dist <= range) {
                                    const dx = enemy.position.x - gameState.player.position.x;
                                    const dy = enemy.position.y - gameState.player.position.y;
                                    const len = Math.sqrt(dx * dx + dy * dy);
                                    if (len > 0) {
                                        enemy.position.x += (dx / len) * knockback;
                                        enemy.position.y += (dy / len) * knockback;
                                        // Proximity damage: more damage up close
                                        const proximityDamage = Math.floor(15 * (1 - dist / range));
                                        damageEnemy(enemy, proximityDamage);
                                        hit = true;
                                    }
                                }
                            });
                            
                            if (hit) {
                                screenShake(0.4, 180);
                                effectsManager.createWave(gameState.player.position, range);
                            }
                            return hit;
                        }
                    },
                    e: {
                        name: 'Tidal Wave',
                        cooldown: 5000,
                        lastUsed: 0,
                        icon: 'WAVE',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            // Push all enemies away radially
                            // Evolution: Double range
                            const range = classExp.water.evolution > 0 ? 24 : 12;
                            const knockback = 10;
                            let hit = false;
                            
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = gameState.player.position.distanceTo(enemy.position);
                                if (dist <= range) {
                                    const dx = enemy.position.x - gameState.player.position.x;
                                    const dy = enemy.position.y - gameState.player.position.y;
                                    const len = Math.sqrt(dx * dx + dy * dy);
                                    if (len > 0) {
                                        enemy.position.x += (dx / len) * knockback;
                                        enemy.position.y += (dy / len) * knockback;
                                        // Proximity damage: more damage up close
                                        const proximityDamage = Math.floor(25 * (1 - dist / range));
                                        damageEnemy(enemy, proximityDamage);
                                        hit = true;
                                    }
                                }
                            });
                            
                            if (hit) {
                                screenShake(0.7, 280);
                                effectsManager.createWave(gameState.player.position, range);
                            }
                            return hit;
                        }
                    },
                    r: {
                        name: 'Whirlpool',
                        cooldown: 8000,
                        lastUsed: 0,
                        icon: 'WHIRL',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            const playerPos = gameState.player.position.clone();
                            
                            // Evolution: Create blue ball with repeated suck/knockback cycles
                            if (classExp.water.evolution > 0) {
                                const range = 18;
                                const damage = 25;
                                const duration = 3000;
                                const cycleInterval = 500;
                                const cycles = Math.floor(duration / cycleInterval);
                                
                                // Create blue orb
                                const orbGeometry = new THREE.SphereGeometry(2, 32, 32);
                                const orbMaterial = new THREE.MeshStandardMaterial({ 
                                    color: 0x0080ff,
                                    emissive: 0x0080ff,
                                    emissiveIntensity: 0.8,
                                    transparent: true,
                                    opacity: 0.7
                                });
                                const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                                orb.position.copy(playerPos);
                                scene.add(orb);
                                
                                // Pulsing animation
                                const orbStartTime = Date.now();
                                const orbAnimate = () => {
                                    const elapsed = Date.now() - orbStartTime;
                                    if (elapsed < duration) {
                                        const pulse = Math.sin(elapsed * 0.01) * 0.3 + 1;
                                        orb.scale.set(pulse, pulse, pulse);
                                        orb.rotation.y += 0.05;
                                        requestAnimationFrame(orbAnimate);
                                    } else {
                                        scene.remove(orb);
                                    }
                                };
                                orbAnimate();
                                
                                screenShake(1.2, duration);
                                gameState.isInvulnerable = true;
                                
                                // Repeated suck and knockback cycles
                                for (let i = 0; i < cycles; i++) {
                                    setTimeout(() => {
                                        // Reverse wave animation (collapsing inward)
                                        effectsManager.createReverseWave(playerPos, range);
                                        
                                        // Find enemies in range
                                        const affectedEnemies = [];
                                        gameState.enemies.forEach(enemy => {
                                            if (!isEnemyOnScreen(enemy)) return;
                                            const dist = playerPos.distanceTo(enemy.position);
                                            if (dist <= range) {
                                                affectedEnemies.push(enemy);
                                            }
                                        });
                                        
                                        // Suck phase (pull enemies in and damage on contact)
                                        affectedEnemies.forEach(enemy => {
                                            if (gameState.enemies.includes(enemy)) {
                                                const dx = playerPos.x - enemy.position.x;
                                                const dy = playerPos.y - enemy.position.y;
                                                const len = Math.sqrt(dx * dx + dy * dy);
                                                if (len > 0) {
                                                    enemy.position.x += (dx / len) * 3;
                                                    enemy.position.y += (dy / len) * 3;
                                                    
                                                    // Damage when pulled close to the orb
                                                    const newDist = playerPos.distanceTo(enemy.position);
                                                    if (newDist < 4) {
                                                        damageEnemy(enemy, damage);
                                                    }
                                                }
                                            }
                                        });
                                        
                                        // Knockback phase after 250ms
                                        setTimeout(() => {
                                            affectedEnemies.forEach(enemy => {
                                                if (gameState.enemies.includes(enemy)) {
                                                    const dx = enemy.position.x - playerPos.x;
                                                    const dy = enemy.position.y - playerPos.y;
                                                    const len = Math.sqrt(dx * dx + dy * dy);
                                                    if (len > 0) {
                                                        enemy.position.x += (dx / len) * 5;
                                                        enemy.position.y += (dy / len) * 5;
                                                    }
                                                    damageEnemy(enemy, damage);
                                                }
                                            });
                                        }, 250);
                                    }, i * cycleInterval);
                                }
                                
                                setTimeout(() => {
                                    gameState.isInvulnerable = false;
                                }, duration);
                                
                                return true;
                            }
                            
                            // Normal whirlpool
                            const range = 15;
                            const damage = 30;
                            const pullStrength = 8;
                            let hit = false;
                            
                            const affectedEnemies = [];
                            
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = playerPos.distanceTo(enemy.position);
                                if (dist <= range) {
                                    affectedEnemies.push(enemy);
                                    hit = true;
                                }
                            });
                            
                            if (hit) {
                                screenShake(1.0, 400);
                                gameState.isInvulnerable = true;
                                setTimeout(() => {
                                    gameState.isInvulnerable = false;
                                }, 1200);
                                
                                effectsManager.createWave(playerPos, range);
                                setTimeout(() => {
                                    effectsManager.createWave(playerPos, range * 0.7);
                                }, 200);
                                
                                affectedEnemies.forEach(enemy => {
                                    if (gameState.enemies.includes(enemy)) {
                                        const dx = playerPos.x - enemy.position.x;
                                        const dy = playerPos.y - enemy.position.y;
                                        const len = Math.sqrt(dx * dx + dy * dy);
                                        if (len > 0) {
                                            enemy.position.x += (dx / len) * pullStrength;
                                            enemy.position.y += (dy / len) * pullStrength;
                                        }
                                    }
                                });
                                
                                setTimeout(() => {
                                    affectedEnemies.forEach(enemy => {
                                        if (gameState.enemies.includes(enemy)) {
                                            const dx = enemy.position.x - playerPos.x;
                                            const dy = enemy.position.y - playerPos.y;
                                            const len = Math.sqrt(dx * dx + dy * dy);
                                            if (len > 0) {
                                                enemy.position.x += (dx / len) * pullStrength * 1.5;
                                                enemy.position.y += (dy / len) * pullStrength * 1.5;
                                            }
                                            damageEnemy(enemy, damage);
                                        }
                                    });
                                }, 1000);
                            }
                            
                            return hit;
                        }
                    }
                }
            },
            thief: {
                name: 'Thief',
                abilities: {
                    q: {
                        name: 'Throw Daggers',
                        cooldown: 1500,
                        lastUsed: 0,
                        icon: 'DAGGER',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            const daggerCount = 5;
                            const damage = 15;
                            const speed = 0.6;
                            const spreadAngle = Math.PI / 6;
                            
                            // Find nearest enemy for aim direction
                            let targetDirection = new THREE.Vector3(0, 1, 0);
                            let nearestEnemy = null;
                            let minDist = Infinity;
                            
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = player.position.distanceTo(enemy.position);
                                if (dist < minDist) {
                                    minDist = dist;
                                    nearestEnemy = enemy;
                                }
                            });
                            
                            if (nearestEnemy) {
                                targetDirection.subVectors(nearestEnemy.position, player.position).normalize();
                            }
                            
                            const baseAngle = Math.atan2(targetDirection.y, targetDirection.x);
                            
                            for (let i = 0; i < daggerCount; i++) {
                                const offset = (i - (daggerCount - 1) / 2) * (spreadAngle / daggerCount);
                                const angle = baseAngle + offset;
                                const direction = new THREE.Vector3(Math.cos(angle), Math.sin(angle), 0);
                                
                                const geometry = new THREE.ConeGeometry(0.15, 0.6, 4);
                                const material = new THREE.MeshStandardMaterial({ 
                                    color: 0x888888,
                                    metalness: 0.8,
                                    roughness: 0.2
                                });
                                const dagger = new THREE.Mesh(geometry, material);
                                dagger.position.copy(player.position);
                                dagger.rotation.z = angle - Math.PI / 2;
                                
                                scene.add(dagger);
                                
                                dagger.userData = {
                                    direction: direction,
                                    speed: speed,
                                    damage: damage,
                                    created: now,
                                    lifetime: 3000,
                                    isProjectile: true
                                };
                                
                                gameState.projectiles.push(dagger);
                            }
                            
                            screenShake(0.3, 100);
                            return true;
                        }
                    },
                    e: {
                        name: 'Vanish',
                        cooldown: 6000,
                        lastUsed: 0,
                        icon: 'VANISH',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            const duration = 3000;

                            // Make player semi-transparent and invulnerable
                            player.material.opacity = 0.3;
                            player.material.transparent = true;
                            player.material.needsUpdate = true;
                            gameState.isInvulnerable = true;
                            gameState.isInvisible = true;

                            // Apply a temporary movement speed buff and healing-over-time while invisible
                            try {
                                if (!player.userData) player.userData = {};
                                // store previous multiplier so we can restore it
                                const prevMult = player.userData.moveSpeedMultiplier || 1;
                                const speedBuff = 1.4; // 40% speed increase while invisible
                                player.userData.moveSpeedMultiplier = prevMult * speedBuff;

                                // Healing over time: small heals every interval
                                const healAmount = 2;
                                const healIntervalMs = 600;
                                let healIntervalId = null;
                                if (typeof hpManager !== 'undefined' && hpManager) {
                                    healIntervalId = setInterval(() => {
                                        try { hpManager.heal(healAmount); } catch (e) {}
                                    }, healIntervalMs);
                                }

                                // Freeze all enemies briefly so Vanish guarantees safety
                                try {
                                    const freezeDur = 1000; // ms
                                    const freezeUntil = Date.now() + freezeDur;
                                    if (gameState.enemies && gameState.enemies.length) {
                                        gameState.enemies.forEach(e => {
                                            if (!e.userData) e.userData = {};
                                            e.userData.frozenUntil = freezeUntil;
                                        });
                                        if (gameState.debugAI) console.log(`Vanish: froze ${gameState.enemies.length} enemies for ${freezeDur}ms`);
                                    }
                                } catch (e) {}

                                // Tear-down after duration: restore visuals, invulnerability, movement, and clear heal interval
                                setTimeout(() => {
                                    player.material.opacity = 1;
                                    player.material.transparent = false;
                                    player.material.needsUpdate = true;
                                    gameState.isInvulnerable = false;
                                    gameState.isInvisible = false;
                                    try { player.userData.moveSpeedMultiplier = prevMult; } catch (e) {}
                                    try { if (healIntervalId) clearInterval(healIntervalId); } catch (e) {}
                                }, duration);
                            } catch (e) {
                                // fallback: still restore invis flags after duration
                                setTimeout(() => {
                                    player.material.opacity = 1;
                                    player.material.transparent = false;
                                    player.material.needsUpdate = true;
                                    gameState.isInvulnerable = false;
                                    gameState.isInvisible = false;
                                }, duration);
                            }

                            screenShake(0.2, 200);
                            return true;
                        }
                    },
                    r: {
                        name: 'Shadow Strike',
                        cooldown: 10000,
                        lastUsed: 0,
                        icon: 'STRIKE',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            // Find farthest enemy
                            let farthestEnemy = null;
                            let maxDist = 0;
                            
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = player.position.distanceTo(enemy.position);
                                if (dist > maxDist) {
                                    maxDist = dist;
                                    farthestEnemy = enemy;
                                }
                            });
                            
                            if (!farthestEnemy) return false;
                            
                            const targetPos = farthestEnemy.position.clone();
                            const executeThreshold = 50;
                            
                            // Evolution: Chain to multiple enemies
                            if (classExp.thief.evolution > 0) {
                                const chainTargets = [farthestEnemy];
                                const chainRange = 8;
                                
                                // Find 3 more nearby enemies
                                gameState.enemies.forEach(enemy => {
                                    if (!isEnemyOnScreen(enemy)) return;
                                    if (chainTargets.includes(enemy)) return;
                                    if (chainTargets.length >= 4) return;
                                    
                                    const dist = farthestEnemy.position.distanceTo(enemy.position);
                                    if (dist <= chainRange) {
                                        chainTargets.push(enemy);
                                    }
                                });
                                
                                // Dash to each target
                                chainTargets.forEach((target, index) => {
                                    setTimeout(() => {
                                        if (gameState.enemies.includes(target)) {
                                                    // Teleport to target position but ensure it's safe
                                                    try { safeTeleportTo(target.position); } catch(e) { try{ player.position.copy(target.position); }catch(_){} }
                                            
                                                        // Clamp within screen bounds (leave a small margin)
                                                        const screenWidth = window.innerWidth / 40;
                                                        const screenHeight = window.innerHeight / 40;
                                                        const margin = 2;
                                                        player.position.x = Math.max(-(screenWidth - margin), Math.min(screenWidth - margin, player.position.x));
                                                        player.position.y = Math.max(-(screenHeight - margin), Math.min(screenHeight - margin, player.position.y));
                                            
                                            // Execute if below threshold
                                            if (target.userData.hp <= executeThreshold) {
                                                target.userData.hp = 0;
                                                damageEnemy(target, 0);
                                            } else {
                                                damageEnemy(target, 100);
                                            }
                                            
                                            // Leave landmine (spawn and arm shortly after)
                                            (function() {
                                                const minePos = target.position.clone();
                                                const geom = new THREE.CircleGeometry(0.5, 12);
                                                const mat = new THREE.MeshBasicMaterial({ color: 0xffcc00 });
                                                const mineMesh = new THREE.Mesh(geom, mat);
                                                mineMesh.position.copy(minePos);
                                                mineMesh.position.z = 0.01;
                                                scene.add(mineMesh);
                                                const mineObj = { mesh: mineMesh, active: false, triggerRadius: 1.5, damage: 60, created: Date.now() };
                                                gameState.mines.push(mineObj);
                                                // Small arming delay so the mine doesn't trigger immediately on landing
                                                setTimeout(() => { try { mineObj.active = true; } catch (e) {} }, 300);
                                                effectsManager.createWave(minePos, 1.2);
                                            })();
                                            
                                            screenShake(0.8, 200);
                                        }
                                    }, index * 300);
                                });
                                
                                return true;
                            }
                            
                            // Normal dash (teleport to nearest safe point of target)
                            try { safeTeleportTo(targetPos); } catch(e) { try { player.position.copy(targetPos); } catch(_) {} }

                            // Clamp within screen bounds (leave a small margin)
                            const screenWidth = window.innerWidth / 40;
                            const screenHeight = window.innerHeight / 40;
                            const margin = 2;
                            player.position.x = Math.max(-(screenWidth - margin), Math.min(screenWidth - margin, player.position.x));
                            player.position.y = Math.max(-(screenHeight - margin), Math.min(screenHeight - margin, player.position.y));
                            
                            // Execute if below threshold
                            if (farthestEnemy.userData.hp <= executeThreshold) {
                                farthestEnemy.userData.hp = 0;
                                damageEnemy(farthestEnemy, 0);
                            } else {
                                damageEnemy(farthestEnemy, 100);
                            }
                            
                            // Leave landmine at target location (arm shortly after)
                            (function() {
                                const minePos = targetPos.clone();
                                const geom = new THREE.CircleGeometry(0.5, 12);
                                const mat = new THREE.MeshBasicMaterial({ color: 0xffcc00 });
                                const mineMesh = new THREE.Mesh(geom, mat);
                                mineMesh.position.copy(minePos);
                                mineMesh.position.z = 0.01;
                                scene.add(mineMesh);
                                const mineObj = { mesh: mineMesh, active: false, triggerRadius: 1.5, damage: 60, created: Date.now() };
                                gameState.mines.push(mineObj);
                                setTimeout(() => { try { mineObj.active = true; } catch (e) {} }, 300);
                                effectsManager.createWave(minePos, 1.2);
                            })();
                            
                            screenShake(1.0, 300);
                            return true;
                        }
                    }
                }
            },
            trapper: {
                name: 'Trapper',
                abilities: {
                    q: {
                        name: 'Place Bomb',
                        cooldown: 2000,
                        lastUsed: 0,
                        icon: 'BOMB',
                        bombs: [],
                        // Default max bombs (can be increased via progression)
                        maxBombs: 3,
                        // Explosion radius in world units
                        explosionRadius: 6,
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            // Create bomb at player position
                            const bombGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                            const bombMaterial = new THREE.MeshStandardMaterial({ 
                                color: 0xff0000,
                                emissive: 0xff0000,
                                emissiveIntensity: 0.5
                            });
                            const bomb = new THREE.Mesh(bombGeometry, bombMaterial);
                            bomb.position.copy(player.position);
                            scene.add(bomb);
                            
                            bomb.userData = {
                                created: now,
                                armed: true
                            };
                            
                            // Enforce capacity
                            try {
                                const allowed = (this.maxBombs != null) ? this.maxBombs : 3;
                                if (this.bombs.length >= allowed) {
                                    const oldest = this.bombs.shift();
                                    try { scene.remove(oldest); } catch(e) {}
                                }
                            } catch (e) {}
                            this.bombs.push(bomb);
                            
                            // Bomb explodes when enemy gets close or after 10 seconds
                            const checkBomb = setInterval(() => {
                                if (!bomb.userData.armed || !scene.children.includes(bomb)) {
                                    clearInterval(checkBomb);
                                    return;
                                }
                                
                                // Check for nearby enemies
                                let triggered = false;
                                gameState.enemies.forEach(enemy => {
                                    const dist = bomb.position.distanceTo(enemy.position);
                                    if (dist <= 2) {
                                        triggered = true;
                                    }
                                });
                                
                                if (triggered || Date.now() - bomb.userData.created > 10000) {
                                    bomb.userData.armed = false;
                                    scene.remove(bomb);
                                    const index = this.bombs.indexOf(bomb);
                                    if (index > -1) this.bombs.splice(index, 1);
                                    
                                    // Explosion
                                    effectsManager.createExplosion(bomb.position, 0xff6600);
                                    gameState.enemies.forEach(enemy => {
                                        if (!isEnemyOnScreen(enemy)) return;
                                        const dist = bomb.position.distanceTo(enemy.position);
                                        const blastR = (this.explosionRadius != null) ? this.explosionRadius : 6;
                                        if (dist <= blastR) {
                                            damageEnemy(enemy, 40);
                                        }
                                    });
                                    screenShake(0.6, 200);
                                    clearInterval(checkBomb);
                                }
                            }, 100);
                            
                            return true;
                        }
                    },
                    e: {
                        name: 'Spike Barrier',
                        cooldown: 4000,
                        lastUsed: 0,
                        icon: 'BARRIER',
                        barriers: [],
                        // Default maximum concurrent barriers (can be increased by progression bonuses)
                        maxBarriers: 3,
                        // Default barrier lifetime in ms (can be modified by duration bonuses)
                        duration: 5000,
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            // Create barrier wall
                            const barrierGeometry = new THREE.BoxGeometry(4, 0.5, 0.5);
                            const barrierMaterial = new THREE.MeshStandardMaterial({ 
                                color: 0x8b4513,
                                emissive: 0x654321,
                                emissiveIntensity: 0.3
                            });
                            const barrier = new THREE.Mesh(barrierGeometry, barrierMaterial);
                            barrier.position.copy(player.position);
                            barrier.position.y += 1.5;
                            
                            // Rotate barrier based on player velocity/last movement
                            const lastMove = movementManager.getLastMovement();
                            if (lastMove.x !== 0 || lastMove.y !== 0) {
                                const angle = Math.atan2(lastMove.y, lastMove.x);
                                barrier.rotation.z = angle + Math.PI / 2; // Perpendicular to movement
                            }
                            
                            scene.add(barrier);

                            // Track barrier globally so it can be cleared on restart/play-again
                            try { gameState.barriers = gameState.barriers || []; gameState.barriers.push(barrier); } catch (e) {}
                            
                            barrier.userData = {
                                created: now,
                                active: true,
                                width: 4,
                                height: 0.5,
                                hp: 60,
                                maxHp: 60
                            };
                            
                            // Remove oldest barrier if we exceed maxBarriers
                            const allowed = (this.maxBarriers != null) ? this.maxBarriers : 3;
                            if (this.barriers.length >= allowed) {
                                const oldestBarrier = this.barriers.shift();
                                scene.remove(oldestBarrier);
                                try {
                                    if (gameState.barriers) {
                                        const i = gameState.barriers.indexOf(oldestBarrier);
                                        if (i > -1) gameState.barriers.splice(i, 1);
                                    }
                                } catch (e) {}
                            }
                            
                            this.barriers.push(barrier);
                            
                            // Barrier damages and slows enemies that touch it
                            // Track barrier lifetime and interactions
                            barrier.userData.duration = (this.duration != null) ? this.duration : 5000;
                            const checkBarrier = setInterval(() => {
                                // Expire barrier after its duration
                                try {
                                    if (Date.now() - barrier.userData.created >= (barrier.userData.duration || 5000)) {
                                        barrier.userData.active = false;
                                    }
                                } catch (e) {}

                                if (!barrier.userData.active) {
                                    try { scene.remove(barrier); } catch(e) {}
                                    const index = this.barriers.indexOf(barrier);
                                    if (index > -1) this.barriers.splice(index, 1);
                                    clearInterval(checkBarrier);
                                    return;
                                }

                                gameState.enemies.forEach(enemy => {
                                    const dist = barrier.position.distanceTo(enemy.position);
                                    if (dist <= 2.5) {
                                        damageEnemy(enemy, 5);
                                        // Slow enemy
                                        const originalSpeed = enemy.userData.speed;
                                        // Allow progression to modify slow factor in future by reading barrier.userData.slowFactor
                                        const slowFactor = (barrier.userData.slowFactor != null) ? barrier.userData.slowFactor : 0.5;
                                        enemy.userData.speed = originalSpeed * slowFactor;
                                        setTimeout(() => {
                                            if (gameState.enemies.includes(enemy)) {
                                                enemy.userData.speed = originalSpeed;
                                            }
                                        }, 1000);
                                    }
                                });
                            }, 500);
                            
                            return true;
                        }
                    },
                    r: {
                        name: 'C4 Detonation',
                        cooldown: 12000,
                        lastUsed: 0,
                        icon: 'C4',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            const c4Pos = player.position.clone();
                            const damage = 80;
                            const range = 12;
                            
                            // Evolution: Cluster explosions
                            if (classExp.trapper.evolution > 0) {
                                // Main explosion
                                effectsManager.createExplosion(c4Pos, 0xff0000);
                                
                                // 8 cluster explosions
                                for (let i = 0; i < 8; i++) {
                                    setTimeout(() => {
                                        const angle = (Math.PI * 2 / 8) * i;
                                        const clusterPos = new THREE.Vector3(
                                            c4Pos.x + Math.cos(angle) * 6,
                                            c4Pos.y + Math.sin(angle) * 6,
                                            0
                                        );
                                        
                                        effectsManager.createExplosion(clusterPos, 0xff6600);
                                        
                                        gameState.enemies.forEach(enemy => {
                                            if (!isEnemyOnScreen(enemy)) return;
                                            const dist = clusterPos.distanceTo(enemy.position);
                                            if (dist <= 5) {
                                                damageEnemy(enemy, damage * 0.6);
                                            }
                                        });
                                    }, i * 100);
                                }
                                
                                screenShake(1.5, 1000);
                                return true;
                            }
                            
                            // Normal C4
                            effectsManager.createExplosion(c4Pos, 0xff0000);
                            
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = c4Pos.distanceTo(enemy.position);
                                if (dist <= range) {
                                    damageEnemy(enemy, damage);
                                }
                            });
                            
                            screenShake(1.2, 400);
                            return true;
                        }
                    }
                }
            },
            tycoon: {
                name: 'Tycoon',
                abilities: {
                    q: {
                        name: 'Dash',
                        cooldown: 3000,
                        lastUsed: 0,
                        icon: 'DASH',
                        range: 5,
                        damage: 25,
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            this.lastUsed = now;
                            
                            const clsLv = (classExp.tycoon && classExp.tycoon.level) || 1;
                            // Map large historical thresholds to the class's 1-15 progression
                            const canDamage = clsLv >= 5;
                            const isUpgraded = clsLv >= 10;
                            const hasBurn = clsLv >= 12;
                            const hasInvincibility = clsLv >= 12;
                            const isMaster = clsLv >= 15;
                            
                            let dashRange = this.range || 5;
                            let dashDamage = this.damage || 25;
                            if (isUpgraded) { dashRange *= 1.5; dashDamage *= 1.5; }
                            if (isMaster) dashDamage *= 2;
                            
                            // Dash in current movement direction if available, otherwise toward mouse
                            let dir = null;
                            try {
                                const lastMove = (typeof movementManager !== 'undefined' && movementManager.getLastMovement) ? movementManager.getLastMovement() : null;
                                if (lastMove && (lastMove.x !== 0 || lastMove.y !== 0)) {
                                    dir = new THREE.Vector3(lastMove.x, lastMove.y, 0).normalize();
                                }
                            } catch (e) { dir = null; }
                            if (!dir) {
                                if (lastMouseWorld) {
                                    dir = lastMouseWorld.clone().sub(player.position).setZ(0).normalize();
                                } else {
                                    dir = new THREE.Vector3(0, 1, 0);
                                }
                            }
                            
                            const startPos = player.position.clone();
                            const endPos = startPos.clone().add(dir.multiplyScalar(dashRange));
                            
                            // Clamp to screen
                            const sw = window.innerWidth / 40;
                            const sh = window.innerHeight / 40;
                            endPos.x = Math.max(-sw, Math.min(sw, endPos.x));
                            endPos.y = Math.max(-sh, Math.min(sh, endPos.y));
                            
                            // Damage enemies in path if unlocked
                            if (canDamage) {
                                gameState.enemies.forEach(enemy => {
                                    if (!isEnemyOnScreen(enemy)) return;
                                    // Check if enemy is within dash corridor
                                    const toEnemy = enemy.position.clone().sub(startPos);
                                    const dashDir = endPos.clone().sub(startPos).normalize();
                                    const proj = toEnemy.dot(dashDir);
                                    if (proj > 0 && proj < dashRange) {
                                        const perpDist = toEnemy.clone().sub(dashDir.clone().multiplyScalar(proj)).length();
                                        if (perpDist < 1.5) {
                                            damageEnemy(enemy, dashDamage);
                                            if (hasBurn) {
                                                enemy.userData.burning = true;
                                                enemy.userData.burnEnd = now + 4000;
                                                enemy.userData.burnDamage = 8;
                                                enemy.userData.lastBurnTick = now;
                                            }
                                        }
                                    }
                                });
                            }
                            
                            // Move player
                            player.position.copy(endPos);
                            effectsManager.createWave(endPos, 1.5);
                            
                            // Invincibility after dash
                            if (hasInvincibility) {
                                gameState.isInvulnerable = true;
                                setTimeout(() => { gameState.isInvulnerable = false; }, 800);
                            }
                            
                            screenShake(0.4, 150);
                            return true;
                        }
                    },
                    e: {
                        name: 'Place Tycoon',
                        cooldown: 8000,
                        lastUsed: 0,
                        icon: 'TYC',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            this.lastUsed = now;
                            
                            // Tycoon in-run features (barrier/laser/etc) are applied as the spawned tycoon levels up
                            let hasBarrier = false;
                            let hasLaser = false;
                            
                            // Create tycoon building
                            const buildGeom = new THREE.BoxGeometry(1.2, 1.2, 1.5);
                            const buildMat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffa500, emissiveIntensity: 0.4 });
                            const tycoon = new THREE.Mesh(buildGeom, buildMat);
                            tycoon.position.copy(player.position);
                            tycoon.position.z = 0.75;
                            scene.add(tycoon);
                            
                            // HP bar container (small div above the tycoon)
                            const hpContainer = document.createElement('div');
                            hpContainer.style.cssText = 'position:absolute; width:50px; height:6px; background:rgba(0,0,0,0.5); border-radius:3px; pointer-events:none; z-index:100;';
                            const hpBar = document.createElement('div');
                            hpBar.style.cssText = 'width:100%; height:100%; background:#4ade80; border-radius:3px; transition:width 0.2s;';
                            hpContainer.appendChild(hpBar);
                            document.body.appendChild(hpContainer);
                            
                            const tycoonHP = hasBarrier ? 150 : 80;
                            tycoon.userData = {
                                type: 'tycoon',
                                level: 1,
                                hp: tycoonHP,
                                maxHp: tycoonHP,
                                hasBarrier: hasBarrier,
                                hasLaser: hasLaser,
                                coinMultiplier: 1,
                                speedMultiplier: 1,
                                damageMultiplier: 1,
                                createdAt: now,
                                hpContainer: hpContainer,
                                hpBar: hpBar
                            };
                            
                            // Track tycoons in gameState
                            if (!gameState.tycoons) gameState.tycoons = [];
                            gameState.tycoons.push(tycoon);
                            
                            // Level counter display
                            const levelDiv = document.createElement('div');
                            levelDiv.style.cssText = 'position:absolute; color:#ffd700; font-size:12px; font-weight:bold; text-shadow:0 0 4px #000; pointer-events:none; z-index:101;';
                            levelDiv.textContent = 'Lv.1';
                            document.body.appendChild(levelDiv);
                            tycoon.userData.levelDiv = levelDiv;
                            
                            // Level up every 5 seconds exponentially
                            const levelInterval = setInterval(() => {
                                if (!gameState.tycoons || !gameState.tycoons.includes(tycoon)) {
                                    clearInterval(levelInterval);
                                    return;
                                }
                                tycoon.userData.level++;
                                levelDiv.textContent = 'Lv.' + tycoon.userData.level;
                                // Glow effect on level up
                                tycoon.material.emissiveIntensity = 0.8;
                                setTimeout(() => { if (tycoon.material) tycoon.material.emissiveIntensity = 0.4; }, 200);
                                // Apply any tycoon tier buffs for this in-run tycoon
                                try {
                                    if (!tycoon.userData._appliedTycoonTiers) tycoon.userData._appliedTycoonTiers = {};
                                    tycoonTiers.forEach(tier => {
                                        if (tycoon.userData.level >= tier.level && !tycoon.userData._appliedTycoonTiers[tier.level]) {
                                            // apply simple parsed effects from the tier buffs
                                            tier.buffs.forEach(b => {
                                                const lower = b.toLowerCase();
                                                if (lower.includes('tycoon coins') && lower.includes('doubled')) {
                                                    tycoon.userData.coinMultiplier = (tycoon.userData.coinMultiplier || 1) * 2;
                                                }
                                                if (lower.includes('tycoon coins') && lower.includes('tripled')) {
                                                    tycoon.userData.coinMultiplier = (tycoon.userData.coinMultiplier || 1) * 3;
                                                }
                                                if (lower.includes('gains damage barrier') || lower.includes('damage barrier')) {
                                                    tycoon.userData.hasBarrier = true;
                                                }
                                                if (lower.includes('upgraded to laser') || lower.includes('laser')) {
                                                    tycoon.userData.hasLaser = true;
                                                }
                                                if (lower.includes('+50 max hp')) {
                                                    tycoon.userData.maxHp = (tycoon.userData.maxHp || 0) + 50;
                                                    tycoon.userData.hp = (tycoon.userData.hp || 0) + 50;
                                                }
                                                if (lower.includes('+100% movement speed')) {
                                                    tycoon.userData.speedMultiplier = (tycoon.userData.speedMultiplier || 1) * 2;
                                                }
                                                if (lower.includes('+100% damage') || lower.includes('+100%')) {
                                                    tycoon.userData.damageMultiplier = (tycoon.userData.damageMultiplier || 1) * 2;
                                                }
                                            });
                                            tycoon.userData._appliedTycoonTiers[tier.level] = true;
                                        }
                                    });
                                } catch (e) { console.warn('Failed to apply tycoon tier buffs', e); }
                            }, 5000);
                            
                            // Barrier/laser damage logic
                            if (hasBarrier || hasLaser) {
                                const barrierInterval = setInterval(() => {
                                    if (!gameState.tycoons || !gameState.tycoons.includes(tycoon)) {
                                        clearInterval(barrierInterval);
                                        return;
                                    }
                                    gameState.enemies.forEach(enemy => {
                                        if (!enemy || !enemy.userData) return;
                                        const dist = tycoon.position.distanceTo(enemy.position);
                                        if (dist < 3) {
                                            const etype = enemy.userData.type;
                                            // Barrier blocks melee (triangles = melee, speed, invisible)
                                            if (hasBarrier && (etype === 'melee' || etype === 'speed' || etype === 'invisible')) {
                                                damageEnemy(enemy, 15);
                                            }
                                            // Laser also kills ranged (squares = ranged, tank, sniper)
                                            if (hasLaser && (etype === 'ranged' || etype === 'tank' || etype === 'sniper')) {
                                                damageEnemy(enemy, 25);
                                            }
                                        }
                                    });
                                }, 500);
                            }
                            
                            // Update HP bar position each frame
                            const updateHPBar = () => {
                                if (!gameState.tycoons || !gameState.tycoons.includes(tycoon)) {
                                    hpContainer.remove();
                                    levelDiv.remove();
                                    return;
                                }
                                // Project tycoon position to screen
                                const vec = tycoon.position.clone();
                                vec.project(camera);
                                const x = (vec.x * 0.5 + 0.5) * window.innerWidth;
                                const y = (-vec.y * 0.5 + 0.5) * window.innerHeight;
                                hpContainer.style.left = (x - 25) + 'px';
                                hpContainer.style.top = (y - 45) + 'px';
                                levelDiv.style.left = (x - 15) + 'px';
                                levelDiv.style.top = (y - 60) + 'px';
                                hpBar.style.width = Math.max(0, (tycoon.userData.hp / tycoon.userData.maxHp) * 100) + '%';
                                requestAnimationFrame(updateHPBar);
                            };
                            requestAnimationFrame(updateHPBar);
                            
                            effectsManager.createWave(tycoon.position, 2);
                            return true;
                        }
                    },
                    r: {
                        name: 'Stab',
                        cooldown: 4000,
                        lastUsed: 0,
                        damage: 60,
                        icon: 'STAB',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            this.lastUsed = now;
                            
                            const clsLv = (classExp.tycoon && classExp.tycoon.level) || 1;
                            const hpScaling = clsLv >= 10;
                            const isMaster = clsLv >= 15;
                            
                            let baseDamage = this.damage || 60;
                            if (isMaster) baseDamage *= 2;
                            
                            // Find closest enemy
                            let closest = null;
                            let closestDist = 8; // extended stab range
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = player.position.distanceTo(enemy.position);
                                if (dist < closestDist) {
                                    closest = enemy;
                                    closestDist = dist;
                                }
                            });
                            
                            if (closest) {
                                let dmg = baseDamage;
                                // HP scaling for bosses
                                if (hpScaling && closest.userData && closest.userData.maxHp) {
                                    dmg += Math.floor(closest.userData.maxHp * 0.15);
                                }
                                damageEnemy(closest, dmg);
                                effectsManager.createWave(closest.position, 1);
                            }
                            
                            // Visual stab effect
                            effectsManager.createWave(player.position, 0.8);
                            screenShake(0.5, 100);
                            return true;
                        }
                    }
                }
            },
            fighter: {
                name: 'Fighter',
                abilities: {
                    q: {
                        name: 'Ram',
                        cooldown: 4000,
                        lastUsed: 0,
                        damage: 45,
                        icon: 'RAM',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            this.lastUsed = now;
                            
                            const fighterLevel = (classExp.fighter && classExp.fighter.level) || 1;
                            const bonusDamage = fighterLevel >= 2 ? 1.2 : 1;
                            const bonusInvuln = fighterLevel >= 7 ? 1500 : 1000;
                            
                            // Find nearest enemy
                            let closest = null;
                            let closestDist = 15;
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = player.position.distanceTo(enemy.position);
                                if (dist < closestDist) {
                                    closest = enemy;
                                    closestDist = dist;
                                }
                            });
                            
                            // Ram toward enemy if found, otherwise dash toward mouse/movement direction
                            const startPos = player.position.clone();
                            let dir;
                            let ramDist = 8;
                            
                            if (closest) {
                                dir = closest.position.clone().sub(startPos).normalize();
                                ramDist = Math.min(closestDist, 8);
                            } else {
                                // No enemy nearby - dash toward mouse or movement direction
                                try {
                                    const lastMove = (typeof movementManager !== 'undefined' && movementManager.getLastMovement) ? movementManager.getLastMovement() : null;
                                    if (lastMove && (lastMove.x !== 0 || lastMove.y !== 0)) {
                                        dir = new THREE.Vector3(lastMove.x, lastMove.y, 0).normalize();
                                    }
                                } catch (e) { dir = null; }
                                if (!dir) {
                                    if (typeof lastMouseWorld !== 'undefined' && lastMouseWorld) {
                                        dir = lastMouseWorld.clone().sub(player.position).setZ(0).normalize();
                                    } else {
                                        dir = new THREE.Vector3(0, 1, 0);
                                    }
                                }
                            }
                            
                            const endPos = startPos.clone().add(dir.clone().multiplyScalar(ramDist));

                            // Clamp to screen
                            const sw = window.innerWidth / 40;
                            const sh = window.innerHeight / 40;
                            endPos.x = Math.max(-sw, Math.min(sw, endPos.x));
                            endPos.y = Math.max(-sh, Math.min(sh, endPos.y));

                            // Invulnerability during dash
                            gameState.isInvulnerable = true;
                            player.material.emissive = new THREE.Color(0xff4444);
                            player.material.emissiveIntensity = 0.8;
                            // Track invulnerability timer so it can be cancelled if we forcibly move the player
                            try {
                                gameState._invulnTimers = gameState._invulnTimers || [];
                                const _t = setTimeout(() => {
                                    gameState.isInvulnerable = false;
                                    try { player.material.emissiveIntensity = 0; } catch (e) {}
                                }, bonusInvuln);
                                gameState._invulnTimers.push(_t);
                            } catch (e) { /* ignore */ }

                            performDashTo(endPos, 160, () => {
                                // Damage enemies upon landing
                                gameState.enemies.forEach(enemy => {
                                    if (!isEnemyOnScreen(enemy)) return;
                                    const dist = enemy.position.distanceTo(player.position);
                                    if (dist < 2.5) {
                                        damageEnemy(enemy, this.damage * bonusDamage);
                                    }
                                });
                                effectsManager.createWave(player.position, 2);
                                screenShake(0.6, 200);
                            });

                            return true;
                        }
                    },
                    e: {
                        name: 'Vortex',
                        cooldown: 10000,
                        lastUsed: 0,
                        damage: 35,
                        pullRange: 10,
                        icon: 'VORTEX',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            this.lastUsed = now;
                            
                            const fighterLevel = (classExp.fighter && classExp.fighter.level) || 1;
                            const bonusPull = fighterLevel >= 3 ? 1.25 : 1;
                            const bonusDamage = fighterLevel >= 10 ? 1.5 : 1;
                            const pullRange = this.pullRange * bonusPull;
                            
                            // Find all nearby enemies
                            const nearbyEnemies = [];
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = player.position.distanceTo(enemy.position);
                                if (dist <= pullRange) {
                                    nearbyEnemies.push(enemy);
                                }
                            });
                            
                            // Even if no enemies nearby, ability still triggers for the dash/effect
                            
                            // Determine nearest dense group of enemies (cluster centroid)
                            let bestClusterCenter = null;
                            let bestCount = 0;
                            const clusterRadius = 6;
                            for (let i = 0; i < gameState.enemies.length; i++) {
                                const e1 = gameState.enemies[i];
                                if (!e1 || !e1.userData) continue;
                                const neighbors = [];
                                gameState.enemies.forEach(e2 => {
                                    if (!e2 || !e2.userData) return;
                                    if (e1.position.distanceTo(e2.position) <= clusterRadius) neighbors.push(e2);
                                });
                                if (neighbors.length > bestCount) {
                                    bestCount = neighbors.length;
                                    // compute centroid
                                    const centroid = new THREE.Vector3(0,0,0);
                                    neighbors.forEach(n => centroid.add(n.position));
                                    centroid.multiplyScalar(1 / neighbors.length);
                                    bestClusterCenter = centroid;
                                }
                            }
                            // Fallback: if no cluster found, use a nearby random point
                            let pullPoint = null;
                            if (bestClusterCenter && bestCount > 0) {
                                pullPoint = bestClusterCenter;
                            } else {
                                pullPoint = player.position.clone().add(
                                    new THREE.Vector3((Math.random() - 0.5) * 6, (Math.random() - 0.5) * 6, 0)
                                );
                            }
                            
                            // Ensure pullPoint is not inside a barrier/enemy; if so, find nearest safe point and clamp to map
                            try {
                                clampToMapVec(pullPoint, 0);
                                if (pointIsBlocked(pullPoint.x, pullPoint.y) || pointWouldBeInDanger(pullPoint.x, pullPoint.y)) {
                                    pullPoint = findNearestSafePoint(pullPoint);
                                    clampToMapVec(pullPoint, 0);
                                }
                            } catch (e) { /* ignore */ }

                            // Move nearby enemies to cluster point with small jitter for stability (clamped)
                            nearbyEnemies.forEach(enemy => {
                                if (!enemy || !enemy.userData) return;
                                const jitter = new THREE.Vector3((Math.random()-0.5)*1.2, (Math.random()-0.5)*1.2, 0);
                                const targetPos = pullPoint.clone().add(jitter);
                                clampToMapVec(targetPos, 0);
                                enemy.position.copy(targetPos);
                            });
                            
                            effectsManager.createWave(pullPoint, 3);
                            
                            // Ram into pull point after short delay
                            setTimeout(() => {
                                const ramDir = pullPoint.clone().sub(player.position).normalize();
                                const ramDist = player.position.distanceTo(pullPoint);
                                // Smooth dash into the pull point instead of instant teleport
                                performDashTo(pullPoint, 200, () => {
                                    // Damage all enemies near the player after landing (recompute from gameState to avoid off-screen filtering)
                                    try {
                                        gameState.enemies.forEach(enemy => {
                                            try {
                                                if (!enemy || !enemy.userData) return;
                                                const dist = enemy.position.distanceTo(player.position);
                                                if (dist < 4) {
                                                    damageEnemy(enemy, this.damage * bonusDamage);
                                                }
                                            } catch (ee) { /* ignore per-enemy */ }
                                        });
                                    } catch (e) { /* ignore */ }
                                    effectsManager.createExplosion(player.position, 0xff6600);
                                    screenShake(0.8, 300);
                                });
                            }, 300);
                            
                            // Invulnerability
                            gameState.isInvulnerable = true;
                            player.material.emissive = new THREE.Color(0xff6600);
                            player.material.emissiveIntensity = 0.8;
                            try {
                                gameState._invulnTimers = gameState._invulnTimers || [];
                                const _t2 = setTimeout(() => {
                                    gameState.isInvulnerable = false;
                                    try { player.material.emissiveIntensity = 0; } catch (e) {}
                                }, 1300);
                                gameState._invulnTimers.push(_t2);
                            } catch (e) { /* ignore */ }
                            
                            return true;
                        }
                    },
                    r: {
                        name: 'Berserk',
                        cooldown: 25000,
                        lastUsed: 0,
                        icon: 'BERSERK',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            this.lastUsed = now;
                            
                            const fighterLevel = (classExp.fighter && classExp.fighter.level) || 1;
                            const bonusDuration = fighterLevel >= 5 ? 2000 : 0;
                            const reducedCost = fighterLevel >= 10 ? 5 : 10;
                            const hasEvolution = classExp.fighter && classExp.fighter.evolution > 0;
                            const duration = 5000 + bonusDuration;
                            
                            // Cost HP
                            if (gameState.hp <= reducedCost) return false;
                            gameState.hp -= reducedCost;
                            updateHPBar();
                            
                            // Berserk state
                            gameState.isBerserk = true;
                            gameState.isInvulnerable = true;
                            const originalSpeed = gameState.playerSpeed || 0.15;
                            gameState.playerSpeed = originalSpeed * 2;
                            
                            // Reduce all cooldowns to almost zero (5% of original, min 50ms)
                            // Track modified abilities so we can restore them reliably even if classes change
                            gameState._berserkModified = gameState._berserkModified || [];
                            if (selectedClass && selectedClass.abilities) {
                                Object.keys(selectedClass.abilities).forEach(key => {
                                    const ability = selectedClass.abilities[key];
                                    try {
                                        if (!ability) return;
                                        if (ability._berserkOriginalCooldown == null) ability._berserkOriginalCooldown = ability.cooldown;
                                        ability.cooldown = Math.max(50, ability._berserkOriginalCooldown * 0.05);
                                        gameState._berserkModified.push(ability);
                                    } catch (e) { /* ignore */ }
                                });
                            }
                            
                            // Visual: Red glowing aura
                            player.material.emissive = new THREE.Color(0xff0000);
                            player.material.emissiveIntensity = 1.2;
                            
                            // Glitchy fidget effect
                            const fidgetInterval = setInterval(() => {
                                if (!gameState.isBerserk) {
                                    clearInterval(fidgetInterval);
                                    return;
                                }
                                player.position.x += (Math.random() - 0.5) * 0.15;
                                player.position.y += (Math.random() - 0.5) * 0.15;
                                player.material.emissiveIntensity = 0.8 + Math.random() * 0.6;
                            }, 50);
                            
                            effectsManager.createExplosion(player.position, 0xff0000);
                            screenShake(1.0, 500);
                            
                            // End berserk
                            setTimeout(() => {
                                gameState.isBerserk = false;
                                gameState.isInvulnerable = false;
                                gameState.playerSpeed = hasEvolution ? originalSpeed * 1.25 : originalSpeed;
                                
                                // Restore cooldowns on any abilities we modified during berserk
                                try {
                                    if (gameState._berserkModified && Array.isArray(gameState._berserkModified)) {
                                        gameState._berserkModified.forEach(ab => {
                                            try {
                                                if (ab && ab._berserkOriginalCooldown != null) {
                                                    ab.cooldown = ab._berserkOriginalCooldown;
                                                    delete ab._berserkOriginalCooldown;
                                                }
                                            } catch (ee) {}
                                        });
                                    }
                                } catch (e) {}
                                try { gameState._berserkModified = []; } catch(e) {}
                                
                                player.material.emissiveIntensity = hasEvolution ? 0.3 : 0;
                                if (!hasEvolution) {
                                    player.material.emissive = new THREE.Color(0x000000);
                                }
                                clearInterval(fidgetInterval);
                            }, duration);
                            
                            return true;
                        }
                    }
                }
            }
        };
        // Keep immutable baseline of class ability numbers so level bonuses don't compound
        const classBaseline = JSON.parse(JSON.stringify(classes));

        // Apply tier-based bonuses from classUpgrades (called whenever level changes)
        function applyClassLevelBonuses(className) {
            if (!classBaseline[className] || !classExp[className]) return;
            const baseline = classBaseline[className];
            const level = Math.max(1, classExp[className].level);
            const targetClass = classes[className];
            if (!targetClass || !targetClass.abilities) return;

            // Reset to baseline first
            Object.keys(targetClass.abilities).forEach(key => {
                const base = baseline.abilities[key];
                if (base) Object.assign(targetClass.abilities[key], JSON.parse(JSON.stringify(base)));
            });

            // Track cumulative bonuses from all unlocked tiers
            let hpBonus = 0;
            let moveSpeedBonus = 0;
            const cooldownMods = { Q: 1, E: 1, R: 1, all: 1 };
            const damageMods = { Q: 1, E: 1, R: 1, all: 1, passive: 1 };
            const rangeMods = { Q: 0, E: 0, R: 0, all: 0 };
            let extraTargets = 0, extraArrows = 0, extraDaggers = 0, extraMinions = 0;
            let extraBombs = 0, extraBarriers = 0, extraAmmo = 0, extraFireballs = 0;
            let barrierSlowPercent = 0;
            let bombRadiusAdd = 0;
            let extraTurrets = 0;
            let turretHpPercent = 0;
            let turretDamagePercent = 0;
            let durationMod = 1, triggerRadiusMod = 0;
            let minionDurationAdd = 0;
            let minionHpPercent = 0;
            let minionDamagePercent = 0;

            // Get upgrades for this class
            const upgrades = classUpgrades[className] || [];
            
            // Apply all unlocked tier bonuses
            upgrades.forEach(tier => {
                if (level < tier.level) return; // Not unlocked yet
                
                tier.buffs.forEach(buff => {
                    // Parse buff strings and apply effects
                    const b = buff.toLowerCase();
                    
                    // HP bonuses
                    const hpMatch = b.match(/\+(\d+)\s*max\s*hp/i);
                    if (hpMatch) hpBonus += parseInt(hpMatch[1]);
                    
                    // Movement speed
                    const moveMatch = b.match(/\+(\d+)%\s*movement\s*speed/i);
                    if (moveMatch) moveSpeedBonus += parseInt(moveMatch[1]);
                    
                    // Cooldown reductions
                    if (b.includes('q:') && b.includes('cooldown')) {
                        const cdMatch = b.match(/-(\d+)%\s*cooldown/i);
                        if (cdMatch) cooldownMods.Q *= (1 - parseInt(cdMatch[1]) / 100);
                    }
                    if (b.includes('e:') && b.includes('cooldown')) {
                        const cdMatch = b.match(/-(\d+)%\s*cooldown/i);
                        if (cdMatch) cooldownMods.E *= (1 - parseInt(cdMatch[1]) / 100);
                    }
                    if (b.includes('r:') && b.includes('cooldown')) {
                        const cdMatch = b.match(/-(\d+)%\s*cooldown/i);
                        if (cdMatch) cooldownMods.R *= (1 - parseInt(cdMatch[1]) / 100);
                    }
                    if (b.includes('all') && b.includes('cooldown')) {
                        const cdMatch = b.match(/-(\d+)%\s*cooldown/i);
                        if (cdMatch) cooldownMods.all *= (1 - parseInt(cdMatch[1]) / 100);
                    }
                    if (b.includes('dig:') && b.includes('cooldown')) {
                        const cdMatch = b.match(/-(\d+)%\s*cooldown/i);
                        if (cdMatch) cooldownMods.E *= (1 - parseInt(cdMatch[1]) / 100);
                    }
                    if (b.includes('mine:') && b.includes('cooldown')) {
                        const cdMatch = b.match(/-(\d+)%\s*cooldown/i);
                        if (cdMatch) cooldownMods.Q *= (1 - parseInt(cdMatch[1]) / 100);
                    }
                    
                    // Damage bonuses
                    if (b.includes('q:') && b.includes('damage')) {
                        const dmgMatch = b.match(/\+(\d+)%?\s*damage/i);
                        if (dmgMatch) {
                            if (b.includes('%')) damageMods.Q *= (1 + parseInt(dmgMatch[1]) / 100);
                            else damageMods.Q += parseInt(dmgMatch[1]) / 100;
                        }
                    }
                    if (b.includes('r:') && b.includes('damage')) {
                        const dmgMatch = b.match(/\+(\d+)%\s*damage/i);
                        if (dmgMatch) damageMods.R *= (1 + parseInt(dmgMatch[1]) / 100);
                    }
                    if (b.includes('all') && b.includes('damage')) {
                        const dmgMatch = b.match(/\+(\d+)%\s*damage/i);
                        if (dmgMatch) damageMods.all *= (1 + parseInt(dmgMatch[1]) / 100);
                    }
                    if (b.includes('passive') && b.includes('shovel') && b.includes('damage')) {
                        const dmgMatch = b.match(/\+(\d+)%/i);
                        if (dmgMatch) damageMods.passive *= (1 + parseInt(dmgMatch[1]) / 100);
                    }
                    if (b.includes('mine:') && b.includes('damage')) {
                        const dmgMatch = b.match(/\+(\d+)%\s*damage/i);
                        if (dmgMatch) damageMods.Q *= (1 + parseInt(dmgMatch[1]) / 100);
                    }
                    if (b.includes('burn') && b.includes('damage')) {
                        const dmgMatch = b.match(/\+(\d+)%/i);
                        if (dmgMatch) damageMods.Q *= (1 + parseInt(dmgMatch[1]) / 100);
                    }
                    if (b.includes('piercing') && b.includes('damage')) {
                        const dmgMatch = b.match(/\+(\d+)%\s*damage/i);
                        if (dmgMatch) damageMods.all *= (1 + parseInt(dmgMatch[1]) / 100);
                    }
                    if (b.includes('turrets') && b.includes('damage')) {
                        const dmgMatch = b.match(/\+(\d+)%\s*damage/i);
                        if (dmgMatch) damageMods.Q *= (1 + parseInt(dmgMatch[1]) / 100);
                    }
                    if (b.includes('minions') && b.includes('damage')) {
                        const dmgMatch = b.match(/\+(\d+)%\s*damage/i);
                        if (dmgMatch) damageMods.all *= (1 + parseInt(dmgMatch[1]) / 100);
                    }
                    if (b.includes('summons') && b.includes('damage')) {
                        const dmgMatch = b.match(/\+(\d+)%\s*damage/i);
                        if (dmgMatch) damageMods.all *= (1 + parseInt(dmgMatch[1]) / 100);
                    }
                    
                    // Range bonuses
                    if (b.includes('q:') && b.includes('range')) {
                        const rngMatch = b.match(/\+(\d+)\s*range/i);
                        if (rngMatch) rangeMods.Q += parseInt(rngMatch[1]);
                    }
                    if (b.includes('all') && b.includes('range')) {
                        const rngMatch = b.match(/\+(\d+)\s*range/i);
                        if (rngMatch) rangeMods.all += parseInt(rngMatch[1]);
                    }
                    if (b.includes('chain range')) {
                        const rngMatch = b.match(/\+(\d+)%/i);
                        if (rngMatch) rangeMods.R += parseInt(rngMatch[1]) / 100;
                    }
                    
                    // Extra projectiles/targets
                    if (b.includes('e:') && b.includes('extra targets')) {
                        const m = b.match(/\+(\d+)/i);
                        if (m) extraTargets += parseInt(m[1]);
                    }
                    if (b.includes('e:') && b.includes('arrows')) {
                        const m = b.match(/\+(\d+)/i);
                        if (m) extraArrows += parseInt(m[1]);
                    }
                    if (b.includes('q:') && b.includes('daggers')) {
                        const m = b.match(/\+(\d+)/i);
                        if (m) extraDaggers += parseInt(m[1]);
                    }
                    if (b.includes('e:') && b.includes('minion')) {
                        const m = b.match(/\+(\d+)/i);
                        if (m) extraMinions += parseInt(m[1]);
                    }
                    if (b.includes('bomb capacity')) {
                        const m = b.match(/\+(\d+)/i);
                        if (m) extraBombs += parseInt(m[1]);
                    }
                    // Example: "Bombs: +2 radius"
                    if (b.includes('bombs') && b.includes('radius')) {
                        const m = b.match(/\+(\d+)/i);
                        if (m) bombRadiusAdd += parseInt(m[1]);
                    }
                    if (b.includes('barrier capacity')) {
                        const m = b.match(/\+(\d+)/i);
                        if (m) extraBarriers += parseInt(m[1]);
                    }
                    // Example: "Barriers: +3s duration" or "Barriers: +50% slow"
                    if (b.includes('barriers') && b.includes('duration')) {
                        const m = b.match(/\+(\d+)s/i);
                        if (m) durationMod += parseInt(m[1]) * 1000 / (baseline.abilities.E?.duration || (targetClass.abilities.E && targetClass.abilities.E.duration) || 5000);
                    }
                    if (b.includes('barriers') && b.includes('slow')) {
                        const m = b.match(/\+(\d+)%/i);
                        if (m) barrierSlowPercent += parseInt(m[1]);
                    }
                    // Minion-specific buffs
                    if (b.includes('minion') && b.includes('duration')) {
                        const m = b.match(/\+(\d+)s/i);
                        if (m) minionDurationAdd += parseInt(m[1]);
                    }
                    if (b.includes('minions') && b.includes('hp')) {
                        const m = b.match(/\+(\d+)%/i);
                        if (m) minionHpPercent += parseInt(m[1]);
                    }
                    if (b.includes('minions') && b.includes('damage')) {
                        const m = b.match(/\+(\d+)%/i);
                        if (m) minionDamagePercent += parseInt(m[1]);
                    }
                    // Turret-specific buffs
                    if (b.includes('turrets') && b.includes('hp')) {
                        const m = b.match(/\+(\d+)%/i);
                        if (m) turretHpPercent += parseInt(m[1]);
                    }
                    if (b.includes('turrets') && b.includes('damage')) {
                        const m = b.match(/\+(\d+)%/i);
                        if (m) turretDamagePercent += parseInt(m[1]);
                    }
                    // Example: "Q: Max 2 turrets"
                    if (b.includes('q:') && b.includes('max') && b.includes('turret')) {
                        const m = b.match(/max\s*(\d+)/i);
                        if (m) extraTurrets += parseInt(m[1]);
                    }
                    if (b.includes('r:') && b.includes('ammo')) {
                        const m = b.match(/\+(\d+)/i);
                        if (m) extraAmmo += parseInt(m[1]);
                    }
                    if (b.includes('r:') && b.includes('fireball')) {
                        const m = b.match(/\+(\d+)/i);
                        if (m) extraFireballs += parseInt(m[1]);
                    }
                    
                    // Duration bonuses
                    if (b.includes('drill:') && b.includes('duration')) {
                        const m = b.match(/\+(\d+)s/i);
                        if (m) durationMod += parseInt(m[1]) * 1000 / (baseline.abilities.R?.duration || 5000);
                    }
                    if (b.includes('invisibility')) {
                        const m = b.match(/\+(\d+)s/i);
                        if (m) durationMod += parseInt(m[1]) * 1000 / (baseline.abilities.E?.duration || 2000);
                    }
                    
                    // Trigger radius
                    if (b.includes('trigger radius')) {
                        const m = b.match(/\+(\d+\.?\d*)/i);
                        if (m) triggerRadiusMod += parseFloat(m[1]);
                    }
                });
            });

            // Apply accumulated bonuses to abilities
            const abilityMap = { Q: 'Q', E: 'E', R: 'R' };
            Object.keys(abilityMap).forEach(key => {
                const ability = targetClass.abilities[key];
                const base = baseline.abilities[key];
                if (!ability || !base) return;
                
                // Apply cooldown mods
                if (base.cooldown !== undefined) {
                    ability.cooldown = Math.max(50, Math.round(base.cooldown * cooldownMods[key] * cooldownMods.all));
                }
                
                // Apply damage mods
                if (base.damage !== undefined) {
                    ability.damage = Math.max(1, Math.round(base.damage * damageMods[key] * damageMods.all));
                }
                
                // Apply range mods
                if (base.range !== undefined) {
                    ability.range = base.range + rangeMods[key] + rangeMods.all;
                    if (rangeMods[key] > 0 && rangeMods[key] < 1) {
                        // Percentage based
                        ability.range = base.range * (1 + rangeMods[key]);
                    }
                }
                
                // Apply extra counts
                if (key === 'E' && base.targets !== undefined) ability.targets = base.targets + extraTargets;
                if (key === 'E' && base.arrowCount !== undefined) ability.arrowCount = base.arrowCount + extraArrows;
                if (key === 'Q' && base.daggerCount !== undefined) ability.daggerCount = base.daggerCount + extraDaggers;
                if (key === 'E' && base.minionCount !== undefined) ability.minionCount = base.minionCount + extraMinions;
                if (key === 'Q' && base.maxBombs !== undefined) ability.maxBombs = base.maxBombs + extraBombs;
                if (key === 'Q' && base.explosionRadius !== undefined) ability.explosionRadius = base.explosionRadius + bombRadiusAdd;
                if (key === 'E' && base.maxBarriers !== undefined) ability.maxBarriers = base.maxBarriers + extraBarriers;
                // Apply turret-related bonuses to Engineer Q ability if present
                if (key === 'Q' && base.turretHp !== undefined) {
                    ability.turretHp = Math.max(1, Math.round(base.turretHp * (1 + turretHpPercent / 100)));
                } else if (key === 'Q' && turretHpPercent > 0) {
                    ability.turretHp = Math.max(1, Math.round((ability.turretHp || 50) * (1 + turretHpPercent / 100)));
                }
                if (key === 'Q' && base.turretDamage !== undefined) {
                    ability.turretDamage = Math.max(1, Math.round(base.turretDamage * (1 + turretDamagePercent / 100)));
                } else if (key === 'Q' && turretDamagePercent > 0) {
                    ability.turretDamage = Math.max(1, Math.round((ability.turretDamage || ability.damage || 8) * (1 + turretDamagePercent / 100)));
                }
                if (key === 'Q' && base.maxTurrets !== undefined) ability.maxTurrets = base.maxTurrets + extraTurrets;
                if (key === 'Q' && base.turretRange !== undefined) ability.turretRange = (ability.turretRange || base.turretRange);
                if (key === 'Q' && base.turretAttackInterval !== undefined) ability.turretAttackInterval = (ability.turretAttackInterval || base.turretAttackInterval);
                if (key === 'R' && base.ammo !== undefined) ability.ammo = base.ammo + extraAmmo;
                if (key === 'R' && base.fireballCount !== undefined) ability.fireballCount = base.fireballCount + extraFireballs;
                
                // Apply duration mod
                if (base.duration !== undefined && durationMod !== 1) {
                    ability.duration = Math.round(base.duration * durationMod);
                }
                
                // Apply trigger radius
                if (base.triggerRadius !== undefined) {
                    ability.triggerRadius = base.triggerRadius + triggerRadiusMod;
                }

                // Apply minion-specific derived values for Summoner
                if (key === 'E') {
                    // default minion values
                    ability.minionDurationMs = (ability.minionDurationMs != null) ? ability.minionDurationMs : 22000;
                    ability.minionDurationMs = ability.minionDurationMs + (minionDurationAdd * 1000);
                    ability.minionHp = (ability.minionHp != null) ? ability.minionHp : 60;
                    ability.minionHp = Math.max(1, Math.round(ability.minionHp * (1 + minionHpPercent / 100)));
                    ability.minionDamage = (ability.minionDamage != null) ? ability.minionDamage : 10;
                    ability.minionDamage = Math.max(1, Math.round(ability.minionDamage * (1 + minionDamagePercent / 100)));
                }
                if (key === 'R') {
                    ability.guardianDurationMs = (ability.guardianDurationMs != null) ? ability.guardianDurationMs : 35000;
                    ability.guardianDurationMs = ability.guardianDurationMs + (minionDurationAdd * 1000);
                    ability.guardianHp = (ability.guardianHp != null) ? ability.guardianHp : 150;
                    ability.guardianHp = Math.max(1, Math.round(ability.guardianHp * (1 + minionHpPercent / 100)));
                    ability.guardianDamage = (ability.guardianDamage != null) ? ability.guardianDamage : (ability.damage || 0);
                    ability.guardianDamage = Math.max(1, Math.round(ability.guardianDamage * (1 + minionDamagePercent / 100)));
                }
            });

            // Apply HP bonus
            if (typeof hpManager !== 'undefined') {
                const baseHp = 100;
                hpManager.maxHp = baseHp + hpBonus;
                hpManager.currentHp = Math.min(hpManager.currentHp, hpManager.maxHp);
                hpManager.updateUI();
            }

            // Apply barrier slow percent to E ability baseline if present
            try {
                const ab = targetClass.abilities && targetClass.abilities.E;
                if (ab) {
                    const baseSlow = (ab.slowFactor != null) ? ab.slowFactor : undefined;
                    if (baseSlow !== undefined) {
                        ab.slowFactor = baseSlow * (1 + (barrierSlowPercent / 100));
                    } else if (barrierSlowPercent > 0) {
                        ab.slowFactor = 0.5 * (1 + (barrierSlowPercent / 100));
                    }
                }
            } catch (e) {}

            // Apply movement speed bonus: set the active multiplier used by movement code
            if (typeof player !== 'undefined') {
                if (!player.userData) player.userData = {};
                const mult = 1 + (moveSpeedBonus / 100);
                player.userData.moveSpeedMultiplier = mult;
            }

            // Apply passive melee damage for Miner
            if (baseline.passiveMeleeDamage !== undefined && typeof player !== 'undefined') {
                if (!player.userData) player.userData = {};
                player.userData.meleeDamage = Math.max(1, Math.round(baseline.passiveMeleeDamage * damageMods.passive));
            }
            
            console.log(`[Progression] Applied tier bonuses for ${className} at level ${level}: +${hpBonus} HP, +${moveSpeedBonus}% speed`);
        }

        // Update all "Buy" buttons to show cost to reach next level
        function updateBuyButtons() {
            if (typeof classExp === 'undefined') return;
            Object.keys(classExp).forEach(className => {
                // Prefer explicit data-class attribute if present
                let btn = document.querySelector(`.buy-exp-btn[data-class="${className}"]`);
                if (!btn) btn = document.querySelector(`.buy-exp-btn[onclick*="buyExp('${className}')"]`);
                if (!btn) return;
                const data = classExp[className];
                if (!data) return;
                if (data.level >= 15) {
                    btn.innerHTML = 'Max Level';
                    btn.disabled = true;
                    return;
                }
                const expNeeded = Math.max(0, data.maxExp - data.exp);
                // Display cost using 4 coins per 1 EXP
                const cost = Math.max(4, Math.ceil(expNeeded * 4));
                btn.innerHTML = `Buy Next Level<br>(${cost} coins)`;
                btn.disabled = false;
            });
        }
        
        // Current class and abilities
        let selectedClass = null;
        let abilities = {};
        
        // Class selection
        function selectClass(className) {
            if (typeof classes === 'undefined' || !classes[className]) {
                console.warn('selectClass: classes not initialized yet');
                return;
            }
            // Check if class is unlocked
            if (!isClassUnlocked(className)) {
                alert('This class is locked! Unlock it first.');
                return;
            }
            // Remove any existing shovel mesh when switching classes
            try {
                if (player && player.userData && player.userData.shovelMesh) {
                    try { player.remove(player.userData.shovelMesh); } catch (e) {}
                    delete player.userData.shovelMesh;
                    delete player.userData.shovelAngle;
                    delete player.userData.shovelRadius;
                    delete player.userData.shovelSpeed;
                }
            } catch (e) {}
            selectedClass = classes[className];
            const classAbilities = selectedClass.abilities;
            
            // Assign abilities: if class uses q/e/r keys use them directly, otherwise map first three keys to q/e/r
            let abilityQ, abilityE, abilityR;
            if (classAbilities.q && classAbilities.e && classAbilities.r) {
                abilityQ = classAbilities.q;
                abilityE = classAbilities.e;
                abilityR = classAbilities.r;
            } else {
                // Fallback: map first three abilities in declaration order
                const keys = Object.keys(classAbilities);
                abilityQ = classAbilities[keys[0]] || null;
                abilityE = classAbilities[keys[1]] || null;
                abilityR = classAbilities[keys[2]] || null;
            }
            abilities = { q: abilityQ, e: abilityE, r: abilityR };
            
            // Update ability icons
            document.querySelector('#ability1 .ability-icon').textContent = (abilityQ && abilityQ.icon) ? abilityQ.icon : 'Q';
            document.querySelector('#ability2 .ability-icon').textContent = (abilityE && abilityE.icon) ? abilityE.icon : 'E';
            document.querySelector('#ability3 .ability-icon').textContent = (abilityR && abilityR.icon) ? abilityR.icon : 'R';
            // For Summoner, show full text for icons
            if (className === 'summoner') {
                document.querySelector('#ability1 .ability-icon').textContent = 'CMD';
                document.querySelector('#ability2 .ability-icon').textContent = 'SQUAD';
                document.querySelector('#ability3 .ability-icon').textContent = 'GUARD';
            }
            
            // Class selection visual effect
            effectsManager.createClassEffect(player.position, className);

            // Miner-specific initial state (no passive shovel mesh)
            if (className === 'miner') {
                if (!player.userData) player.userData = {};
                player.userData.meleeDamage = 22; // base shovel damage
                player.userData.meleeInterval = 700; // ms between swings
                player.userData.meleeCooldown = 0;
                player.userData.drillUntil = 0;
                // Remove any old shovel mesh if present
                if (player.userData.shovelMesh) {
                    try { player.remove(player.userData.shovelMesh); } catch (e) {}
                    delete player.userData.shovelMesh;
                }
            }
            
            // Update player color based on class
            const classColors = {
                electric: { base: 0xfff367, emissive: 0xfff700 },
                fire: { base: 0xff5c42, emissive: 0xff2000 },
                pierce: { base: 0xd97706, emissive: 0xbf5f00 },
                engineer: { base: 0xffb347, emissive: 0xff8c00 },
                life: { base: 0xff4d4d, emissive: 0xff1f1f },
                summoner: { base: 0x8b5cf6, emissive: 0x6d28d9 },
                water: { base: 0x38bdf8, emissive: 0x0ea5d8 },
                miner: { base: 0xd97706, emissive: 0xbf5f00 }
            };
            
            if (classColors[className]) {
                try {
                    // Regenerate gradient texture so the player's `map` reflects class colors
                    const newMap = createGradientTexture(classColors[className].base, classColors[className].emissive, true, 256);
                    player.material.map = newMap;
                    player.material.color.setHex(0xffffff);
                    player.material.emissive.setHex(classColors[className].emissive);
                    player.material.emissiveIntensity = 0.08;
                    player.material.needsUpdate = true;
                    // Update glow ring color if present
                    try { if (typeof glowRing !== 'undefined' && glowRing && glowRing.material) glowRing.material.color.setHex(classColors[className].base); } catch (e) {}
                    // Update first child (legacy code used this) and shovel if present
                    if (player.children[0] && player.children[0].material) {
                        player.children[0].material.color.setHex(classColors[className].base);
                    }
                    if (player.userData && player.userData.shovelMesh && player.userData.shovelMesh.material) {
                        player.userData.shovelMesh.material.color.setHex(classColors[className].base);
                    }
                } catch (e) { console.warn('Failed to apply class gradient', e); }
            // After applying class visuals, ensure any user-selected skin overrides class colors
            try{ if(typeof applyStoredSkinToPlayer === 'function') applyStoredSkinToPlayer(); }catch(e){}
            } else if (typeof className === 'string' && className.startsWith('skin_')) {
                // Skin-based custom class: apply saved player skin color
                try {
                    const hex = localStorage.getItem('playerSkin') || '#00f5ff';
                    const num = parseInt('0x' + hex.slice(1));
                    const newMap = createGradientTexture(num, num, true, 256);
                    player.material.map = newMap;
                    player.material.color.setHex(0xffffff);
                    player.material.emissive.setHex(num);
                    player.material.emissiveIntensity = 0.08;
                    player.material.needsUpdate = true;
                    try { if (typeof glowRing !== 'undefined' && glowRing && glowRing.material) glowRing.material.color.setHex(num); } catch (e) {}
                    if (player.children[0] && player.children[0].material) player.children[0].material.color.setHex(num);
                    if (player.userData && player.userData.shovelMesh && player.userData.shovelMesh.material) player.userData.shovelMesh.material.color.setHex(num);
                } catch (e) { console.warn('Failed to apply skin-based class color', e); }
            }
            
            // Hide class selection
            document.getElementById('classSelection').style.display = 'none';

            // Persist this selection so we can restore it on next load (only the class choice)
            try { localStorage.setItem('lastSelectedClass', className); } catch (e) { /* ignore */ }

            // Update mobile button labels (use ability icon/text rather than Q/E/R)
            try {
                const m1 = document.querySelector('#mAbility1 .mobile-ability-label');
                const m2 = document.querySelector('#mAbility2 .mobile-ability-label');
                const m3 = document.querySelector('#mAbility3 .mobile-ability-label');
                if (m1) m1.textContent = (abilityQ && abilityQ.icon) ? abilityQ.icon : 'Primary';
                if (m2) m2.textContent = (abilityE && abilityE.icon) ? abilityE.icon : 'Secondary';
                if (m3) m3.textContent = (abilityR && abilityR.icon) ? abilityR.icon : 'Ultimate';
            } catch (e) { /* ignore */ }
            
            // Life class passive HP drain
            if (className === 'life') {
                setInterval(() => {
                    if (!gameState.isGameOver && selectedClass && selectedClass.name === 'Life') {
                        // Drain 5 HP, but don't drop below 1
                        const newHP = hpManager.currentHp - 5;
                        if (newHP <= 1) {
                            hpManager.currentHp = 1;
                            hpManager.updateUI();
                        } else {
                            hpManager.damage(5);
                        }
                    }
                }, 1000);
            }
            
            // Show ammo counter for Engineer (selection only)
            const ammoCounter = document.getElementById('ammoCounter');
            if (className === 'engineer') {
                ammoCounter.style.display = 'block';
                gameState.machineGunAmmo = gameState.maxMachineGunAmmo;
                document.getElementById('ammoCount').textContent = gameState.machineGunAmmo;
            } else {
                ammoCounter.style.display = 'none';
            }

            // DO NOT enable wave system here; only mark the class as selected and return to home screen.
            // Show the home screen so the player can press PLAY (which will actually start the run).
            document.getElementById('homeScreen').style.display = 'flex';

            // Hide HUD Home button while on the home screen
            const hb = document.getElementById('homeButton');
            if (hb) hb.style.display = 'none';
            // Hide ability UI and mobile controls while on home screen
            try { const ab = document.getElementById('abilities'); if (ab) ab.style.display = 'none'; } catch (e) {}
            try { const mc = document.getElementById('mobileControls'); if (mc) mc.style.display = 'none'; } catch (e) {}
            
            // Initialize wave progress
            document.getElementById('waveProgress').style.width = '0%';
            document.getElementById('waveProgressText').textContent = '0 / 10';
            try { if (typeof updateCheckpointHUD === 'function') updateCheckpointHUD(); } catch(e) {}

            // Apply class level bonuses when selecting the class
            try { applyClassLevelBonuses(className); } catch (e) { console.warn('Failed to apply class level bonuses', e); }
        }
        
        // Old abilities - will be replaced by class selection
        const oldAbilities = {
            lightning: {
                cooldown: 3000,
                lastUsed: 0,
                damage: 50,
                range: 5,
                chainRange: 4,
                maxChains: 3,
                execute: function() {
                    const now = Date.now();
                    if (now - this.lastUsed < this.cooldown) return false;
                    
                    this.lastUsed = now;
                    console.log('Lightning: Searching for enemies, count:', gameState.enemies.length);
                    
                    // Find closest enemy
                    let closest = null;
                    let closestDist = Infinity;
                    
                    gameState.enemies.forEach(enemy => {
                        const dist = player.position.distanceTo(enemy.position);
                        console.log('Enemy at distance:', dist);
                        if (dist < closestDist && dist <= this.range) {
                            closest = enemy;
                            closestDist = dist;
                        }
                    });
                    
                    if (closest) {
                        console.log('Lightning hit enemy at distance:', closestDist);
                        effectsManager.createLightningBolt(player.position, closest.position);
                        damageEnemy(closest, this.damage);
                        
                        // Chain lightning to nearby enemies
                        let hitEnemies = [closest];
                        let currentSource = closest;
                        
                        for (let i = 0; i < this.maxChains; i++) {
                            let nextTarget = null;
                            let nextDist = Infinity;
                            
                            gameState.enemies.forEach(enemy => {
                                if (hitEnemies.includes(enemy)) return;
                                const dist = currentSource.position.distanceTo(enemy.position);
                                if (dist < nextDist && dist <= this.chainRange) {
                                    nextTarget = enemy;
                                    nextDist = dist;
                                }
                            });
                            
                            if (nextTarget) {
                                setTimeout(() => {
                                    effectsManager.createLightningBolt(currentSource.position, nextTarget.position);
                                    damageEnemy(nextTarget, this.damage * 0.7); // Reduced damage for chained hits
                                }, 100 * (i + 1));
                                
                                hitEnemies.push(nextTarget);
                                currentSource = nextTarget;
                            } else {
                                break;
                            }
                        }
                    } else {
                        console.log('No enemy in range (range:', this.range, ')');
                        // Still show effect at player position
                        const targetPos = player.position.clone();
                        targetPos.x += 2;
                        effectsManager.createLightningBolt(player.position, targetPos);
                    }
                    
                    return true;
                }
            },
            fireball: {
                cooldown: 5000,
                lastUsed: 0,
                damage: 40,
                speed: 0.3,
                execute: function() {
                    const now = Date.now();
                    if (now - this.lastUsed < this.cooldown) return false;
                    
                    this.lastUsed = now;
                    console.log('Fireball: Searching for enemies, count:', gameState.enemies.length);
                    
                    // Find closest enemy for targeting
                    let target = null;
                    let closestDist = Infinity;
                    
                    gameState.enemies.forEach(enemy => {
                        const dist = player.position.distanceTo(enemy.position);
                        if (dist < closestDist) {
                            target = enemy;
                            closestDist = dist;
                        }
                    });
                    
                    // Shoot towards target or forward
                    let direction;
                    if (target) {
                        console.log('Fireball targeting enemy');
                        direction = new THREE.Vector3()
                            .subVectors(target.position, player.position)
                            .normalize();
                    } else {
                        console.log('No target, shooting forward');
                        // Shoot in the direction player is facing
                        const angle = player.rotation.z + Math.PI / 2;
                        direction = new THREE.Vector3(Math.cos(angle), Math.sin(angle), 0);
                    }
                    
                    const projectile = effectsManager.createFireball(player.position, direction, this.speed);
                    // Extend userData instead of overwriting to preserve direction and speed
                    Object.assign(projectile.userData, {
                        damage: this.damage,
                        lifetime: 5000,
                        created: Date.now()
                    });
                    gameState.projectiles.push(projectile);
                    
                    return true;
                }
            },
            wave: {
                cooldown: 8000,
                lastUsed: 0,
                damage: 25,
                knockbackForce: 8,
                execute: function() {
                    const now = Date.now();
                    if (now - this.lastUsed < this.cooldown) return false;
                    
                    this.lastUsed = now;
                    console.log('Wave: Knocking back enemies');
                    
                    const waveRange = 8;
                    effectsManager.createWave(player.position, waveRange);
                    
                    gameState.enemies.forEach(enemy => {
                        const dist = player.position.distanceTo(enemy.position);
                        if (dist <= waveRange) {
                            // Calculate knockback direction (away from player)
                            const knockbackDir = new THREE.Vector3()
                                .subVectors(enemy.position, player.position)
                                .normalize();
                            
                            // Apply knockback force (stronger when closer)
                            const knockbackStrength = this.knockbackForce * (1 - dist / waveRange);
                            enemy.position.x += knockbackDir.x * knockbackStrength;
                            enemy.position.y += knockbackDir.y * knockbackStrength;
                            
                            // Keep within arena bounds
                            enemy.position.x = Math.max(-24, Math.min(24, enemy.position.x));
                            enemy.position.y = Math.max(-24, Math.min(24, enemy.position.y));
                            
                            // Still apply damage
                            damageEnemy(enemy, this.damage);
                        }
                    });
                    
                    return true;
                }
            }
        };
        
        // Damage enemy
        function damageEnemy(enemy, damage) {
            // Prevent damage to far off-screen enemies, but allow close-range hits (melee) to apply
            try {
                if (!isEnemyOnScreen(enemy)) {
                    // If enemy is close to the player (melee range), still allow damage
                    if (typeof player !== 'undefined' && enemy.position.distanceTo(player.position) <= 3) {
                        // allow melee/close damage even if off-screen
                    } else {
                        if (gameState.debugAI) console.log(`damageEnemy: skipped damage to off-screen enemy id=${enemy.id}`);
                        return;
                    }
                }
            } catch (e) {}
            // Shield behaviour: absorb or reduce first hit(s)
            try {
                if (enemy.userData && enemy.userData.shieldHits && enemy.userData.shieldHits > 0) {
                    // Reduce incoming damage and consume a shield hit
                    damage = Math.floor(damage * 0.5);
                    enemy.userData.shieldHits -= 1;
                    if (gameState.debugAI) console.log(`damageEnemy: shield absorbed part of dmg for enemy id=${enemy.id}, remaining shieldHits=${enemy.userData.shieldHits}`);
                }
            } catch (e) {}
            enemy.userData.hp -= damage;
            effectsManager.createDamageNumber(enemy.position, damage);
            
            // Hit flash effect
            const originalColor = enemy.material.color.getHex();
            enemy.material.color.setHex(0xffffff);
            setTimeout(() => {
                if (enemy.material) {
                    enemy.material.color.setHex(originalColor);
                }
            }, 50);
            
            if (enemy.userData.hp <= 0) {
                // Death animation
                const deathDuration = 300;
                const startTime = Date.now();
                const startScale = enemy.scale.clone();
                const startY = enemy.position.y;
                
                enemy.userData.dying = true;
                
                const deathAnim = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / deathDuration, 1);
                    
                    if (progress < 1) {
                        // Shrink and fade
                        enemy.scale.set(
                            startScale.x * (1 - progress),
                            startScale.y * (1 - progress),
                            startScale.z * (1 - progress)
                        );
                        enemy.position.y = startY - progress * 2;
                        enemy.material.opacity = 1 - progress;
                        enemy.rotation.x += 0.2;
                        enemy.rotation.y += 0.2;
                        requestAnimationFrame(deathAnim);
                    } else {
                        scene.remove(enemy);
                        // Remove any associated HP UI immediately
                        try {
                            if (enemy.userData && enemy.userData.hpUI && enemy.userData.hpUI.el) {
                                enemy.userData.hpUI.el.remove();
                            }
                        } catch (e) {}
                        const index = gameState.enemies.indexOf(enemy);
                        if (index > -1) gameState.enemies.splice(index, 1);
                        // If this was a splitter, spawn two small minions in its place
                        try {
                            if (enemy.userData && enemy.userData.type === 'splitter') {
                                for (let i = 0; i < 2; i++) {
                                    const geom = new THREE.SphereGeometry(0.28, 8, 8);
                                    const mat = new THREE.MeshStandardMaterial({ color: 0x0a0a12, emissive: 0xffdd99, emissiveIntensity: 0.45, transparent: true, opacity: 0.95 });
                                    const mini = new THREE.Mesh(geom, mat);
                                    mini.position.set(enemy.position.x + (Math.random() - 0.5) * 0.8, enemy.position.y + (Math.random() - 0.5) * 0.8, 0);
                                    const miniHp = Math.max(6, Math.floor((enemy.userData.maxHp || 20) * 0.25));
                                    mini.userData = { type: 'minion', hp: miniHp, maxHp: miniHp, speed: 0.04 + (gameState.currentWave * 0.0007), damage: Math.floor(5 + gameState.currentWave * 0.5), attackCooldown: 0, attackInterval: 900, attackRange: 1.0, rotationSpeed: 0.03, collisionRadius: 0.4 };
                                    scene.add(mini);
                                    gameState.enemies.push(mini);
                                }
                            }
                        } catch (e) {}
                                // Award coins to player based on enemy type (scaled by wave)
                                try {
                                    const baseRewards = { melee: 5, ranged: 6, speed: 5, invisible: 8, tank: 15, armored: 18, splitter: 7, summoner: 20, minion: 3 };
                                    let reward = enemy.userData && enemy.userData.isBoss ? Math.floor(50 + gameState.currentWave * 10) : (baseRewards[enemy.userData.type] || 5);
                                    // Scale a bit with enemy maxHp to reward tougher enemies
                                    if (enemy.userData && enemy.userData.maxHp) {
                                        reward = Math.max(reward, Math.floor(reward * (enemy.userData.maxHp / 40)));
                                    }
                                    gameState.coins = (gameState.coins || 0) + reward;
                                    updateCoinDisplay();
                                    // Track quest progress: coins earned
                                    if (typeof trackQuestProgress === 'function') trackQuestProgress('totalCoinsEarned', reward);
                                    // Show reward popup
                                    if (typeof effectsManager !== 'undefined' && effectsManager.createDamageNumber) {
                                        effectsManager.createDamageNumber(enemy.position, reward);
                                    }
                                } catch (e) {}
                                // Award EXP to the player's selected class based on enemy type
                                try {
                                    const expBase = { melee: 2, ranged: 3, speed: 2, invisible: 4, tank: 8, armored: 6, splitter: 3, summoner: 7, minion: 1 };
                                    let expGain = enemy.userData && enemy.userData.isBoss ? Math.floor(20 + (gameState.currentWave || 1) * 5) : (expBase[enemy.userData.type] || 2);
                                    // Scale slightly with enemy maxHp
                                    if (enemy.userData && enemy.userData.maxHp) {
                                        expGain = Math.max(expGain, Math.floor(expGain * (enemy.userData.maxHp / 40)));
                                    }
                                    if (gameState.classSelected && typeof selectedClass !== 'undefined' && selectedClass && classExp[selectedClass]) {
                                        const ce = classExp[selectedClass];
                                        ce.exp = (ce.exp || 0) + expGain;
                                        // Level up loop
                                        while (ce.exp >= ce.maxExp && ce.level < 15) {
                                            ce.exp -= ce.maxExp;
                                            ce.level++;
                                            if (ce.level === 15) {
                                                ce.evolution = (ce.evolution || 0) + 1;
                                            }
                                            // increase next level cap modestly
                                            ce.maxExp = Math.min(1000, Math.floor(ce.maxExp * 1.15));
                                        }
                                        // Update displays
                                        try { updateExpDisplays(); } catch (e) {}
                                        try { updateBuyButtons(); } catch (e) {}
                                        // Visual feedback for EXP gain
                                        try { if (typeof effectsManager !== 'undefined' && effectsManager.createDamageNumber) effectsManager.createDamageNumber(enemy.position, '+' + expGain + ' EXP'); } catch (e) {}
                                    }
                                } catch (e) {}
                                // Clear any claims this enemy held on targets
                        try {
                            const claimerId = enemy.id;
                            if (gameState.allies) {
                                gameState.allies.forEach(a => {
                                    if (a.userData && a.userData.claimedBy === claimerId) a.userData.claimedBy = null;
                                });
                            }
                            if (gameState.turrets) {
                                gameState.turrets.forEach(t => {
                                    if (t.userData && t.userData.claimedBy === claimerId) t.userData.claimedBy = null;
                                });
                            }
                            if (gameState.player && gameState.player.userData && gameState.player.userData.claimedBy === claimerId) {
                                gameState.player.userData.claimedBy = null;
                            }
                        } catch (e) {
                            // ignore
                        }
                    }
                };
                
                deathAnim();
                
                // Enemy killed
                
                // Track quest progress: kills and boss kills
                if (typeof trackQuestProgress === 'function') {
                    trackQuestProgress('totalKills', 1);
                    if (enemy.userData && enemy.userData.isBoss) {
                        trackQuestProgress('bossKills', 1);
                    }
                }
                
                // Update wave progress
                if (gameState.classSelected) {
                    gameState.enemiesKilledThisWave++;
                    const progressPercent = Math.min(100, (gameState.enemiesKilledThisWave / gameState.enemiesPerWave) * 100);
                    document.getElementById('waveProgress').style.width = progressPercent + '%';
                    document.getElementById('waveProgressText').textContent = gameState.enemiesKilledThisWave + ' / ' + gameState.enemiesPerWave;
                }
                
                const deathColor = enemy.userData.isBoss ? 0xfbbf24 : 0x4ade80;
                effectsManager.createDeathExplosion(enemy.position, deathColor);
            }
        }

        // Resolve simple circle-based collisions between player, allies, enemies, and turrets
        function resolveEntityCollisions() {
            const entities = [];
            if (gameState.player) entities.push(gameState.player);
            if (gameState.allies && gameState.allies.length) entities.push(...gameState.allies);
            if (gameState.enemies && gameState.enemies.length) entities.push(...gameState.enemies);
            if (gameState.turrets && gameState.turrets.length) entities.push(...gameState.turrets);

            for (let i = 0; i < entities.length; i++) {
                for (let j = i + 1; j < entities.length; j++) {
                    const a = entities[i];
                    const b = entities[j];
                    if (!a.position || !b.position) continue;

                    const rA = (a.userData && a.userData.collisionRadius) ? a.userData.collisionRadius : 0.8;
                    const rB = (b.userData && b.userData.collisionRadius) ? b.userData.collisionRadius : 0.8;

                    const dx = a.position.x - b.position.x;
                    const dy = a.position.y - b.position.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = rA + rB;

                    if (dist < 0.001) dist = 0.001;

                    if (dist < minDist) {
                        const overlap = minDist - dist;
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const aImmovable = a.userData && a.userData.isTurret;
                        const bImmovable = b.userData && b.userData.isTurret;
                        const aIsPlayer = (gameState.player === a);
                        const bIsPlayer = (gameState.player === b);
                        const aIsEnemy = gameState.enemies && gameState.enemies.includes(a);
                        const bIsEnemy = gameState.enemies && gameState.enemies.includes(b);

                        if (aImmovable && bImmovable) continue;

                        // Prevent enemies from pushing the player: if one side is player and the other an enemy,
                        // only move the enemy, never the player.
                        if (aIsPlayer && bIsEnemy) {
                            // move enemy b away from player a
                            b.position.x -= nx * overlap;
                            b.position.y -= ny * overlap;
                        } else if (bIsPlayer && aIsEnemy) {
                            a.position.x += nx * overlap;
                            a.position.y += ny * overlap;
                        } else if (aImmovable) {
                            b.position.x -= nx * overlap;
                            b.position.y -= ny * overlap;
                        } else if (bImmovable) {
                            a.position.x += nx * overlap;
                            a.position.y += ny * overlap;
                        } else {
                            a.position.x += nx * (overlap * 0.5);
                            a.position.y += ny * (overlap * 0.5);
                            b.position.x -= nx * (overlap * 0.5);
                            b.position.y -= ny * (overlap * 0.5);
                        }
                    }
                }
            }
        }

        // Update and trigger mines
        function updateMines(deltaTime) {
            if (!gameState.mines || gameState.mines.length === 0) return;
            for (let i = gameState.mines.length - 1; i >= 0; i--) {
                const mine = gameState.mines[i];
                if (!mine || !mine.active) continue;
                // Check enemies stepping on mine
                let triggered = false;
                gameState.enemies.forEach(enemy => {
                    if (!enemy) return;
                    const dist = enemy.position.distanceTo(mine.mesh.position);
                    if (dist <= mine.triggerRadius) triggered = true;
                });
                if (triggered) {
                    // Explode
                    const pos = mine.mesh.position.clone();
                    effectsManager.createExplosion(pos, 0xffcc00);
                    const explosionRange = 3.5;
                    gameState.enemies.forEach(enemy => {
                        const d = enemy.position.distanceTo(pos);
                        if (d <= explosionRange) {
                            damageEnemy(enemy, mine.damage);
                        }
                    });
                    // Remove mine
                    try { scene.remove(mine.mesh); } catch (e) {}
                    gameState.mines.splice(i, 1);
                }
            }
        }

        // When an ally dies, remove it from the game
        function handleAllyDown(ally) {
            try {
                // Remove HP UI if exists
                if (ally.userData && ally.userData.hpUI && ally.userData.hpUI.el) {
                    ally.userData.hpUI.el.remove();
                }
                // Death explosion effect
                effectsManager.createExplosion(ally.position, 0x3b82f6);
                // Remove from scene
                scene.remove(ally);
                // Remove from allies array
                const allyIndex = gameState.allies.indexOf(ally);
                if (allyIndex > -1) gameState.allies.splice(allyIndex, 1);
                // Also check minions array
                if (gameState.minions) {
                    const minionIndex = gameState.minions.indexOf(ally);
                    if (minionIndex > -1) gameState.minions.splice(minionIndex, 1);
                }
            } catch (e) {
                // ignore
            }
        }
        
        // Create screen-space HP UI for an ally
        function createAllyHPUI(ally) {
            try {
                if (!ally) return;
                let layer = document.getElementById('allyHpLayer');
                if (!layer) { layer = document.createElement('div'); layer.id = 'allyHpLayer'; document.body.appendChild(layer); }
                const hpEl = document.createElement('div');
                hpEl.className = 'ally-hp';
                const radius = (ally.userData && ally.userData.collisionRadius) ? ally.userData.collisionRadius : 0.8;
                const fullWidthPx = Math.max(30, Math.round(30 * radius + 30));
                hpEl.style.width = (fullWidthPx) + 'px';
                hpEl.innerHTML = '<div class="bar-bg"><div class="bar-fg"></div></div>';
                layer.appendChild(hpEl);
                ally.userData.hpUI = { el: hpEl, fullWidth: fullWidthPx, radius };
            } catch (e) { console.warn('Failed to create ally hp UI', e); }
        }
        
        // Screen shake effect
        let cameraShake = { intensity: 0, duration: 0, startTime: 0 };
        
        function screenShake(intensity, duration) {
            cameraShake = {
                intensity: intensity,
                duration: duration,
                startTime: Date.now()
            };
        }
        
        function updateCameraShake() {
            if (cameraShake.intensity > 0) {
                const elapsed = Date.now() - cameraShake.startTime;
                if (elapsed < cameraShake.duration) {
                    const progress = elapsed / cameraShake.duration;
                    const currentIntensity = cameraShake.intensity * (1 - progress);
                    camera.position.x = (Math.random() - 0.5) * currentIntensity;
                    camera.position.y = (Math.random() - 0.5) * currentIntensity;
                } else {
                    camera.position.x = 0;
                    camera.position.y = 0;
                    cameraShake.intensity = 0;
                }
            }
        }
        
        // Input handling
        const keys = { q: false, e: false, r: false };
        
        window.addEventListener('keydown', (e) => {
            const key = (e.key || '').toLowerCase();
            
            if (gameState.isGameOver) return;
            
            if (key === 'q' && abilities.q) {
                if (abilities.q.execute()) {
                    // Use display cooldown if provided (e.g., berserk temporaries)
                    const cdQ = (abilities.q && abilities.q._berserkOriginalCooldown != null) ? abilities.q._berserkOriginalCooldown : abilities.q.cooldown;
                    updateAbilityCooldown('ability1', cdQ);
                    document.getElementById('ability1').style.transform = 'scale(0.9)';
                    setTimeout(() => {
                        document.getElementById('ability1').style.transform = 'scale(1)';
                    }, 100);
                }
            } else if (key === 'e' && abilities.e) {
                if (abilities.e.execute()) {
                    const cdE = (abilities.e && abilities.e._berserkOriginalCooldown != null) ? abilities.e._berserkOriginalCooldown : abilities.e.cooldown;
                    updateAbilityCooldown('ability2', cdE);
                    document.getElementById('ability2').style.transform = 'scale(0.9)';
                    setTimeout(() => {
                        document.getElementById('ability2').style.transform = 'scale(1)';
                    }, 100);
                }
            } else if (key === 'r' && abilities.r) {
                // Engineer uses hold-down mechanic, others use single press
                if (selectedClass && selectedClass.name === 'Engineer') {
                    if (!keys.r) {
                        keys.r = true;
                    }
                } else {
                    // Single press for other classes
                    const result = abilities.r.execute();
                    if (result === 'reload') {
                        const cdR_reload = (abilities.r && abilities.r._berserkOriginalCooldown != null) ? abilities.r._berserkOriginalCooldown : abilities.r.cooldown;
                        updateAbilityCooldown('ability3', cdR_reload);
                    } else if (result || result === true) {
                        const cdR = (abilities.r && abilities.r._berserkOriginalCooldown != null) ? abilities.r._berserkOriginalCooldown : abilities.r.cooldown;
                        updateAbilityCooldown('ability3', cdR);
                        document.getElementById('ability3').style.transform = 'scale(0.9)';
                        setTimeout(() => {
                            document.getElementById('ability3').style.transform = 'scale(1)';
                        }, 100);
                    }
                }
            }
        });
        
        window.addEventListener('keyup', (e) => {
            const key = (e.key || '').toLowerCase();
            if (key === 'r') {
                keys.r = false;
            }
        });
        
        // Convert enemy to ally
        function convertToAlly(enemy) {
            if (!gameState.allies) {
                gameState.allies = [];
            }
            
            // Remove from enemies array
            const index = gameState.enemies.indexOf(enemy);
            if (index > -1) {
                gameState.enemies.splice(index, 1);
                
                // Count as killed for wave progress
                gameState.enemiesKilledThisWave++;
                const progressPercent = Math.min(100, (gameState.enemiesKilledThisWave / gameState.enemiesPerWave) * 100);
                document.getElementById('waveProgress').style.width = progressPercent + '%';
                document.getElementById('waveProgressText').textContent = gameState.enemiesKilledThisWave + ' / ' + gameState.enemiesPerWave;
            }
            
            // Change color to blue
            enemy.material.color.setHex(0x3b82f6);
            
            // Set ally data
            enemy.userData.isAlly = true;
            enemy.userData.allyUntil = Date.now() + 15000; // 15 second duration
            enemy.userData.hp = 50; // Give allies HP
            enemy.userData.maxHp = 50; // Set max HP for HP bar
            enemy.userData.attackCooldown = 0;
            enemy.userData.attackInterval = 1000; // Attack once per second
            enemy.userData.rotationSpeed = 0.02;
            
            // Add to allies array
            gameState.allies.push(enemy);
        }
        
        // Ability UI updates
        const cooldownIntervals = {};
        
        function updateAbilityCooldown(abilityId, cooldownTime) {
            const abilityEl = document.getElementById(abilityId);
            const overlay = abilityEl.querySelector('.cooldown-overlay');
            const text = abilityEl.querySelector('.cooldown-text');
            
            abilityEl.classList.add('disabled');
            overlay.style.height = '100%';
            // ensure mobile button overlay/text show immediately when cooldown starts
            try {
                const mobileMap = { 'ability1': 'mAbility1', 'ability2': 'mAbility2', 'ability3': 'mAbility3' };
                const mid0 = mobileMap[abilityId];
                if (mid0) {
                    const mbtn0 = document.getElementById(mid0);
                    if (mbtn0) {
                        const mOverlay0 = mbtn0.querySelector('.mobile-cooldown-overlay');
                        const mText0 = mbtn0.querySelector('.mobile-cooldown-text');
                        if (mOverlay0) mOverlay0.style.height = '100%';
                        if (mText0) mText0.textContent = Math.ceil(cooldownTime / 1000) || '';
                        mbtn0.classList.add('disabled');
                    }
                }
            } catch (e) { /* ignore */ }
            
            const startTime = Date.now();
            const interval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const remaining = Math.max(0, cooldownTime - elapsed);
                const percentage = (remaining / cooldownTime) * 100;

                overlay.style.height = percentage + '%';
                text.textContent = Math.ceil(remaining / 1000);

                // Also update mobile button if present
                try {
                    const mobileMap = { 'ability1': 'mAbility1', 'ability2': 'mAbility2', 'ability3': 'mAbility3' };
                    const mid = mobileMap[abilityId];
                    if (mid) {
                        const mbtn = document.getElementById(mid);
                        if (mbtn) {
                            const mOverlay = mbtn.querySelector('.mobile-cooldown-overlay');
                            const mText = mbtn.querySelector('.mobile-cooldown-text');
                            if (mOverlay) mOverlay.style.height = percentage + '%';
                            if (mText) mText.textContent = '';
                            if (remaining <= 0) {
                                if (mOverlay) mOverlay.style.height = '0%';
                                if (mText) mText.textContent = '';
                                mbtn.classList.remove('disabled');
                            }
                        }
                    }
                } catch (e) { /* ignore */ }

                if (remaining <= 0) {
                    clearInterval(interval);
                    delete cooldownIntervals[abilityId];
                    abilityEl.classList.remove('disabled');
                    text.textContent = '';
                }
            }, 100);

            cooldownIntervals[abilityId] = { interval, startTime, totalCooldown: cooldownTime };
        }
        
        function reduceCooldownDisplay(abilityId, reductionAmount) {
            const cooldownData = cooldownIntervals[abilityId];
            if (!cooldownData) return;
            
            // Restart the cooldown with reduced time
            clearInterval(cooldownData.interval);
            const elapsed = Date.now() - cooldownData.startTime;
            const newCooldown = Math.max(0, cooldownData.totalCooldown - elapsed - reductionAmount);
            
            const abilityEl = document.getElementById(abilityId);
            const overlay = abilityEl.querySelector('.cooldown-overlay');
            const text = abilityEl.querySelector('.cooldown-text');
            
            if (newCooldown <= 0) {
                delete cooldownIntervals[abilityId];
                abilityEl.classList.remove('disabled');
                text.textContent = '';
                overlay.style.height = '0%';
                return;
            }
            
            const newStartTime = Date.now();
            const interval = setInterval(() => {
                const elapsed = Date.now() - newStartTime;
                const remaining = Math.max(0, newCooldown - elapsed);
                const percentage = (remaining / newCooldown) * 100;
                
                overlay.style.height = percentage + '%';
                text.textContent = Math.ceil(remaining / 1000);
                
                if (remaining <= 0) {
                    clearInterval(interval);
                    delete cooldownIntervals[abilityId];
                    abilityEl.classList.remove('disabled');
                    text.textContent = '';
                }
            }, 100);
            
            cooldownIntervals[abilityId] = { interval, startTime: newStartTime, totalCooldown: newCooldown };
        }
        
        // Update projectiles
        function updateProjectiles(deltaTime) {
            const now = Date.now();
            // Miner passive projectiles: shovels and drills
            // Move and handle collision for these
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const proj = gameState.projectiles[i];
                if (proj.userData.isShovel || proj.userData.isDrill) {
                    // Move forward
                    proj.position.x += proj.userData.velocity.x;
                    proj.position.y += proj.userData.velocity.y;
                    // Optional: spin shovel for effect
                    if (proj.userData.isShovel) proj.rotation.z += 0.35;
                    // Lifetime: 1.5s for shovel, 2.2s for drill
                    const maxLifetime = proj.userData.isDrill ? 2200 : 1500;
                    if (!proj.userData.created) proj.userData.created = Date.now();
                    if (now - proj.userData.created > maxLifetime) {
                        scene.remove(proj);
                        gameState.projectiles.splice(i, 1);
                        continue;
                    }
                    // Collision with enemies
                    let hit = false;
                    const hitRadius = proj.userData.isDrill ? 1.0 : 0.7;
                    let pierce = proj.userData.pierce || 1;
                    if (!proj.userData.hitEnemies) proj.userData.hitEnemies = [];
                    for (const enemy of gameState.enemies) {
                        if (proj.userData.hitEnemies.includes(enemy)) continue;
                        if (proj.position.distanceTo(enemy.position) < hitRadius) {
                            damageEnemy(enemy, proj.userData.damage);
                            proj.userData.hitEnemies.push(enemy);
                            pierce--;
                            effectsManager.createExplosion(enemy.position, proj.userData.isDrill ? 0xd1b000 : 0xffe066);
                            if (pierce <= 0) {
                                hit = true;
                                break;
                            }
                        }
                    }
                    if (hit) {
                        scene.remove(proj);
                        gameState.projectiles.splice(i, 1);
                        continue;
                    }
                }
            }
            
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const proj = gameState.projectiles[i];
                
                // Handle arcing projectiles (arrow storm)
                if (proj.userData.isArcing) {
                    proj.userData.travelTime += deltaTime;
                    const progress = Math.min(proj.userData.travelTime / 1000, 1);
                    
                    // Interpolate position
                    proj.position.x = proj.userData.startPos.x + (proj.userData.targetPos.x - proj.userData.startPos.x) * progress;
                    proj.position.y = proj.userData.startPos.y + (proj.userData.targetPos.y - proj.userData.startPos.y) * progress;
                    proj.position.z = Math.sin(progress * Math.PI) * proj.userData.arcHeight;
                    
                    // Check collision during arc (for piercing arrows)
                    if (proj.userData.isPiercing) {
                        const hitRadius = 0.8;
                        gameState.enemies.forEach(enemy => {
                            if (!proj.userData.hitEnemies.includes(enemy) && 
                                proj.position.distanceTo(enemy.position) < hitRadius) {
                                // Do 30 damage after first hit to incentivize lining up shots
                                const damage = proj.userData.pierceCount > 0 ? 30 : proj.userData.damage;
                                damageEnemy(enemy, damage);
                                proj.userData.hitEnemies.push(enemy);
                                proj.userData.pierceCount++;
                                effectsManager.createExplosion(enemy.position, 0x8b4513);
                            }
                        });
                    }
                    
                    // Remove if reached end of arc
                    if (progress >= 1) {
                        scene.remove(proj);
                        gameState.projectiles.splice(i, 1);
                        continue;
                    }
                } else {
                    // Move projectile normally only if direction and speed are defined
                    if (proj.userData.direction && typeof proj.userData.speed === 'number') {
                        proj.position.x += proj.userData.direction.x * proj.userData.speed;
                        proj.position.y += proj.userData.direction.y * proj.userData.speed;
                    }
                    // Add trail effect for fireballs and arrows
                    if (Math.random() < 0.3) {
                        if (proj.userData.isFireball) {
                            effectsManager.createProjectileTrail(proj.position, 0xff6600);
                        } else if (proj.userData.isPiercing) {
                            effectsManager.createProjectileTrail(proj.position, 0x8b4513);
                        }
                    }
                }
                
                // Check collision with enemies or player
                let hit = false;
                
                // Check if enemy projectile hits barriers
                if (proj.userData.isEnemyProjectile && abilities.e && abilities.e.barriers) {
                    abilities.e.barriers.forEach(barrier => {
                        if (barrier.userData.active) {
                            const dist = barrier.position.distanceTo(proj.position);
                            if (dist <= 2.5) {
                                hit = true;
                            }
                        }
                    });
                }
                
                // Handle enemy projectiles hitting player/allies
                if (proj.userData.isEnemyProjectile && !hit) {
                    const hitRadius = 0.5;
                    
                    if (proj.userData.targetIsAlly) {
                        // Check collision with the specific targeted ally (if still exists)
                        if (proj.userData.target && (gameState.allies.includes(proj.userData.target) || (gameState.minions && gameState.minions.includes(proj.userData.target)))) {
                            const dist = proj.position.distanceTo(proj.userData.target.position);
                            if (dist < hitRadius) {
                                proj.userData.target.userData.hp -= proj.userData.damage;
                                effectsManager.createDamageNumber(proj.userData.target.position, proj.userData.damage);
                                if (proj.userData.target.userData.hp <= 0) {
                                    handleAllyDown(proj.userData.target);
                                }
                                hit = true;
                            }
                        } else {
                            hit = true; // Target no longer exists
                        }
                    }

                    // If not already hit, check collision with any nearby ally/minion (covers stray projectiles)
                    if (!hit) {
                        const allyList = [];
                        if (gameState.allies && gameState.allies.length) allyList.push(...gameState.allies);
                        if (gameState.minions && gameState.minions.length) allyList.push(...gameState.minions);
                        for (const a of allyList) {
                            if (!a || !a.position || !a.userData) continue;
                            const d = proj.position.distanceTo(a.position);
                            if (d < hitRadius) {
                                a.userData.hp = (a.userData.hp != null) ? a.userData.hp - proj.userData.damage : ( (a.userData.maxHp || 50) - proj.userData.damage );
                                try { effectsManager.createDamageNumber(a.position, proj.userData.damage); } catch (e) {}
                                if (a.userData.hp <= 0) handleAllyDown(a);
                                hit = true;
                                break;
                            }
                        }
                    }

                    // If still not hit, check collision with player as fallback
                    if (!hit) {
                        const dist = proj.position.distanceTo(gameState.player.position);
                        if (dist < hitRadius) {
                            if (!gameState.isInvulnerable) {
                                hpManager.damage(proj.userData.damage);
                                gameState.lastDamageTime = Date.now();
                                if (hpManager.isDead()) {
                                    gameOver();
                                }
                                if (gameState.debugAI) console.log(`updateProjectiles: projectile hit player dmg=${proj.userData.damage} playerHp=${hpManager.currentHp}`);
                            } else {
                                if (gameState.debugAI) console.log(`updateProjectiles: projectile blocked by invulnerability dmg=${proj.userData.damage} invulnerable=${gameState.isInvulnerable} invisible=${gameState.isInvisible}`);
                            }
                            hit = true;
                        }
                    }
                } else if (proj.userData.isFireball) {
                    // Fireballs have larger trigger radius and always do AoE
                    const triggerRadius = 3;
                    const aoeRadius = 5;
                    
                    gameState.enemies.forEach(enemy => {
                        if (proj.position.distanceTo(enemy.position) < triggerRadius) {
                            hit = true;
                        }
                    });
                    
                    if (hit) {
                        // Evolution: Massive AoE explosion
                        const finalRadius = proj.userData.isEvolved ? proj.userData.explosionRange : aoeRadius;
                        effectsManager.createWave(proj.position, finalRadius);
                        effectsManager.createExplosion(proj.position, 0xff6600);
                        if (proj.userData.isEvolved) {
                            // Extra visual effects for evolved
                            setTimeout(() => effectsManager.createWave(proj.position, finalRadius * 0.7), 100);
                            setTimeout(() => effectsManager.createExplosion(proj.position, 0xffaa00), 150);
                        }
                        
                        let aoeHitCount = 0;
                        gameState.enemies.forEach(enemy => {
                            const dist = proj.position.distanceTo(enemy.position);
                            if (dist <= finalRadius) {
                                damageEnemy(enemy, proj.userData.damage);
                                aoeHitCount++;
                                
                                // Apply burn
                                enemy.userData.burning = true;
                                enemy.userData.burnEnd = now + proj.userData.burnDuration;
                                enemy.userData.burnDamage = proj.userData.burnDamage;
                                enemy.userData.lastBurnTick = now;
                            }
                        });
                        
                        // Track shared hit count for multi-fireball ability
                        if (proj.userData.sharedHitCount) {
                            proj.userData.sharedHitCount.count += aoeHitCount;
                            if (proj.userData.sharedHitCount.count >= proj.userData.hitThreshold && proj.userData.abilityRef) {
                                const reduction = proj.userData.abilityRef.cooldown * proj.userData.cooldownReduction;
                                proj.userData.abilityRef.lastUsed -= reduction;
                                reduceCooldownDisplay(proj.userData.abilityId, reduction);
                                proj.userData.sharedHitCount.count = -999; // Prevent multiple triggers
                            }
                        }
                    }
                } else if (proj.userData.isPiercing) {
                    // Piercing arrow logic
                    const hitRadius = 0.8;
                    gameState.enemies.forEach(enemy => {
                        if (!proj.userData.hitEnemies.includes(enemy) && 
                            proj.position.distanceTo(enemy.position) < hitRadius) {
                            // Do 30 damage after first hit to incentivize lining up shots
                            const damage = proj.userData.pierceCount > 0 ? 30 : proj.userData.damage;
                            damageEnemy(enemy, damage);
                            proj.userData.hitEnemies.push(enemy);
                            proj.userData.pierceCount++;
                            effectsManager.createExplosion(enemy.position, 0x8b4513);
                            
                            // Track shared hit count for multi-projectile abilities
                            if (proj.userData.sharedHitCount) {
                                proj.userData.sharedHitCount.count++;
                                if (proj.userData.sharedHitCount.count >= proj.userData.hitThreshold && proj.userData.abilityRef) {
                                    const reduction = proj.userData.abilityRef.cooldown * proj.userData.cooldownReduction;
                                    proj.userData.abilityRef.lastUsed -= reduction;
                                    reduceCooldownDisplay(proj.userData.abilityId, reduction);
                                    proj.userData.sharedHitCount.count = -999; // Prevent multiple triggers
                                }
                            } else if (proj.userData.pierceCount >= proj.userData.hitThreshold && proj.userData.abilityRef) {
                                // Single projectile abilities
                                const reduction = proj.userData.abilityRef.cooldown * proj.userData.cooldownReduction;
                                proj.userData.abilityRef.lastUsed -= reduction;
                                reduceCooldownDisplay(proj.userData.abilityId, reduction);
                                proj.userData.hitThreshold = 999; // Prevent multiple triggers
                            }
                            
                            // Pierce arrows never stop from hitting enemies
                            // (infinite pierce)
                        }
                    });
                } else if (proj.userData.isAllyProjectile) {
                    // Ally projectile hitting enemies
                    const hitRadius = 0.8;
                    gameState.enemies.forEach(enemy => {
                        if (proj.position.distanceTo(enemy.position) < hitRadius) {
                            damageEnemy(enemy, proj.userData.damage);
                            effectsManager.createExplosion(enemy.position, 0x10b981);
                            hit = true;
                        }
                    });
                } else {
                    // Regular single-target projectile damage
                    const hitRadius = 0.8;
                    gameState.enemies.forEach(enemy => {
                        if (proj.position.distanceTo(enemy.position) < hitRadius) {
                            damageEnemy(enemy, proj.userData.damage);
                            hit = true;
                        }
                    });
                }
                
                // Remove if hit or expired
                if (hit || now - proj.userData.created > proj.userData.lifetime) {
                    scene.remove(proj);
                    gameState.projectiles.splice(i, 1);
                }
            }
        }
        
        // Update turrets
        function updateTurrets(deltaTime) {
            const now = Date.now();
            
            for (let i = gameState.turrets.length - 1; i >= 0; i--) {
                const turret = gameState.turrets[i];
                
                // Check if turret destroyed
                if (turret.userData.hp <= 0) {
                    effectsManager.createDeathExplosion(turret.position, 0xffa500);
                    scene.remove(turret);
                    gameState.turrets.splice(i, 1);
                    continue;
                }
                
                // Find nearest enemy
                let nearestEnemy = null;
                let nearestDist = Infinity;
                
                gameState.enemies.forEach(enemy => {
                    if (!isEnemyOnScreen(enemy)) return;
                    const dist = turret.position.distanceTo(enemy.position);
                    if (dist < nearestDist && dist <= turret.userData.range) {
                        nearestDist = dist;
                        nearestEnemy = enemy;
                    }
                });
                
                if (nearestEnemy) {
                    // Rotate turret to face enemy
                    const angle = Math.atan2(
                        nearestEnemy.position.x - turret.position.x,
                        nearestEnemy.position.y - turret.position.y
                    );
                    turret.rotation.z = -angle;
                    
                    // Shoot at enemy
                    if (now - turret.userData.attackCooldown > turret.userData.attackInterval) {
                        turret.userData.attackCooldown = now;
                        
                        const direction = new THREE.Vector3()
                            .subVectors(nearestEnemy.position, turret.position)
                            .normalize();
                        
                        const bullet = effectsManager.createFireball(turret.position.clone(), direction, 0.3);
                        bullet.userData = {
                            direction: direction,
                            speed: 0.3,
                            damage: turret.userData.damage,
                            created: now,
                            lifetime: 3000
                        };
                        
                        gameState.projectiles.push(bullet);
                    }
                }
            }
        }
        
        // Update minions
        function updateMinions(deltaTime) {
            const now = Date.now();
            
            for (let i = gameState.minions.length - 1; i >= 0; i--) {
                const minion = gameState.minions[i];
                
                // Check if minion expired
                if (now > minion.userData.expiresAt) {
                    effectsManager.createDeathExplosion(minion.position, minion.userData.isCube ? 0xfbbf24 : 0x9333ea);
                    scene.remove(minion);
                    gameState.minions.splice(i, 1);
                    continue;
                }

                // Ensure HP UI exists for minions (so players can see minion health)
                try {
                    if (!minion.userData.hpUI || !minion.userData.hpUI.el) {
                        createAllyHPUI(minion);
                    }
                    // Update minion HP UI immediately
                    const ui = minion.userData.hpUI;
                    if (ui && ui.el) {
                        const fg = ui.el.querySelector('.bar-fg');
                        if (fg) {
                            const hp = (minion.userData.hp != null) ? minion.userData.hp : (minion.userData.maxHp || 0);
                            const maxHp = (minion.userData.maxHp != null) ? minion.userData.maxHp : hp;
                            const ratio = maxHp > 0 ? Math.max(0, Math.min(1, hp / maxHp)) : 0;
                            fg.style.width = Math.round(ratio * 100) + '%';
                            if (ratio > 0.5) fg.style.background = 'linear-gradient(90deg,#3b82f6,#2563eb)';
                            else if (ratio > 0.25) fg.style.background = 'linear-gradient(90deg,#f59e0b,#d97706)';
                            else fg.style.background = 'linear-gradient(90deg,#ef4444,#dc2626)';
                        }
                    }
                } catch (e) {}

                // If minion HP drops to 0, don't remove â€” stun and persist as an ally-like downed unit
                if (minion.userData.hp <= 0) {
                    handleAllyDown(minion);
                    continue;
                }
                
                // Find nearest enemy
                let nearestEnemy = null;
                let nearestDist = Infinity;
                
                gameState.enemies.forEach(enemy => {
                    if (!isEnemyOnScreen(enemy)) return;
                    const dist = minion.position.distanceTo(enemy.position);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = enemy;
                    }
                });
                
                if (nearestEnemy) {
                    // Move toward enemy
                    const direction = new THREE.Vector3()
                        .subVectors(nearestEnemy.position, minion.position)
                        .normalize();
                    
                    minion.position.x += direction.x * minion.userData.speed;
                    minion.position.z += direction.z * minion.userData.speed;
                    
                    // Rotate minion
                    if (minion.userData.isCube) {
                        minion.rotation.x += 0.02;
                        minion.rotation.y += 0.02;
                    } else {
                        minion.rotation.y += 0.05;
                    }
                    
                    // Attack if close enough
                    if (nearestDist < 1.5 && now - minion.userData.attackCooldown > minion.userData.attackInterval) {
                        minion.userData.attackCooldown = now;
                        damageEnemy(nearestEnemy, minion.userData.damage);
                        effectsManager.createExplosion(nearestEnemy.position, minion.userData.isCube ? 0xfbbf24 : 0x9333ea);
                    }
                }
            }
        }
        
        // Update allies
        function updateAllies(deltaTime) {
            const now = Date.now();
            
            // Clean up expired allies and update active ones
            for (let i = gameState.allies.length - 1; i >= 0; i--) {
                const ally = gameState.allies[i];
                
                // Check if ally expired
                if (now > ally.userData.allyUntil) {
                    // Kill the ally when duration expires
                    handleAllyDown(ally);
                    continue;
                }
                
                // Find nearest enemy for ally to attack
                let nearestEnemy = null;
                let nearestDist = Infinity;
                
                gameState.enemies.forEach(enemy => {
                    if (!isEnemyOnScreen(enemy)) return;
                    const dist = ally.position.distanceTo(enemy.position);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = enemy;
                    }
                });
                
                if (nearestEnemy) {
                    // Record current target for this ally (used by CMD)
                    ally.userData.currentTarget = nearestEnemy;

                    // Move toward enemy (or keep distance if ranged)
                    const direction = new THREE.Vector3()
                        .subVectors(nearestEnemy.position, ally.position)
                        .normalize();
                    
                    const isRanged = ally.userData.isRanged;
                    const preferredRange = isRanged ? 8 : 1.5;
                    
                    if (nearestDist > preferredRange + 1) {
                        ally.position.x += direction.x * 0.04;
                        ally.position.y += direction.y * 0.04;
                    } else if (isRanged && nearestDist < preferredRange - 1) {
                        // Back away if too close for ranged
                        ally.position.x -= direction.x * 0.02;
                        ally.position.y -= direction.y * 0.02;
                    }
                    
                    // Rotate ally
                    const rotSpeed = ally.userData.rotationSpeed || 0.02;
                    ally.rotation.x += rotSpeed;
                    ally.rotation.y += rotSpeed * 1.5;
                    
                    // Attack based on type
                    if (now - ally.userData.attackCooldown > ally.userData.attackInterval) {
                        const attackRange = isRanged ? 12 : 1.5;
                        if (nearestDist < attackRange) {
                            ally.userData.attackCooldown = now;
                            // Weaken allies: lower damage outputs
                            const damage = ally.userData.isGuardian ? 18 : (isRanged ? 10 : 10);
                            
                            if (isRanged) {
                                // Shoot projectile
                                const projectile = effectsManager.createFireball(ally.position.clone(), direction, 0.3);
                                projectile.userData = {
                                    direction: direction,
                                    speed: 0.3,
                                    damage: damage,
                                    created: now,
                                    lifetime: 3000,
                                    isAllyProjectile: true
                                };
                                gameState.projectiles.push(projectile);
                            } else {
                                // Melee attack
                                damageEnemy(nearestEnemy, damage);
                                effectsManager.createExplosion(nearestEnemy.position, 0x3b82f6);
                            }
                        }
                    }
                }
                else {
                    ally.userData.currentTarget = null;
                }
            }
        }

        // Player melee for Miner passive and drill buff
        function updatePlayerMelee(deltaTime) {
            if (!selectedClass || selectedClass.name !== 'Miner') return;
            const now = Date.now();
            if (!player.userData) player.userData = {};
            const meleeInterval = player.userData.meleeInterval || 700;
            const baseDamage = player.userData.meleeDamage || 20;
            const drillActive = player.userData.drillUntil && now < player.userData.drillUntil;
            const damage = drillActive ? Math.max(baseDamage * 4, 80) : baseDamage;

            if (now - (player.userData.meleeCooldown || 0) < meleeInterval) return;

            // Find nearest enemy within melee range
            let nearest = null;
            let nd = Infinity;
            gameState.enemies.forEach(enemy => {
                const d = player.position.distanceTo(enemy.position);
                if (d < 1.6 && d < nd) {
                    nd = d; nearest = enemy;
                }
            });

            if (nearest) {
                player.userData.meleeCooldown = now;
                // Hit effect
                effectsManager.createDamageNumber(nearest.position, damage);
                console.log(`Player melee hit enemy id=${nearest.id} dmg=${damage}`);
                damageEnemy(nearest, damage);
                // small shove
                const knock = new THREE.Vector3().subVectors(nearest.position, player.position).normalize().multiplyScalar(0.6);
                nearest.position.add(knock);
                screenShake(0.15, 80);
            }
        }
        
        // Update enemies
        function updateEnemies(deltaTime) {
            const now = Date.now();
            
            // Clear any stale claimedBy references on player (if the claiming enemy no longer exists)
            try {
                if (gameState.player && gameState.player.userData && gameState.player.userData.claimedBy) {
                    const claimerId = gameState.player.userData.claimedBy;
                    const exists = gameState.enemies.some(e => e.id === claimerId);
                    if (!exists) {
                        gameState.player.userData.claimedBy = null;
                        gameState.player.userData.claimedAt = null;
                    } else {
                        // Also clear overly long or distant claims to prevent a single distant enemy
                        try {
                            const claimer = gameState.enemies.find(e => e.id === claimerId);
                            const maxClaimDistance = Math.max(window.innerWidth, window.innerHeight) / 8; // heuristic
                            const claimAge = gameState.player.userData.claimedAt ? (Date.now() - gameState.player.userData.claimedAt) : Infinity;
                            if (!claimer || (claimer && gameState.player.position.distanceTo(claimer.position) > maxClaimDistance) || claimAge > 7000) {
                                gameState.player.userData.claimedBy = null;
                                gameState.player.userData.claimedAt = null;
                            }
                        } catch (e) {}
                    }
                }
            } catch (e) {}
            // Also clear stale claims on allies, minions, and turrets
            try {
                const maxClaimDistance = Math.max(window.innerWidth, window.innerHeight) / 8;
                if (gameState.allies) gameState.allies.forEach(a => {
                    if (a.userData && a.userData.claimedBy) {
                        const claimer = gameState.enemies.find(e => e.id === a.userData.claimedBy);
                        const claimAge = a.userData.claimedAt ? (Date.now() - a.userData.claimedAt) : Infinity;
                        if (!claimer || (claimer && a.position.distanceTo(claimer.position) > maxClaimDistance) || claimAge > 7000) {
                            a.userData.claimedBy = null; a.userData.claimedAt = null;
                        }
                    }
                });
                if (gameState.minions) gameState.minions.forEach(m => {
                    if (m.userData && m.userData.claimedBy) {
                        const claimer = gameState.enemies.find(e => e.id === m.userData.claimedBy);
                        const claimAge = m.userData.claimedAt ? (Date.now() - m.userData.claimedAt) : Infinity;
                        if (!claimer || (claimer && m.position.distanceTo(claimer.position) > maxClaimDistance) || claimAge > 7000) {
                            m.userData.claimedBy = null; m.userData.claimedAt = null;
                        }
                    }
                });
                if (gameState.turrets) gameState.turrets.forEach(t => {
                    if (t.userData && t.userData.claimedBy) {
                        const claimer = gameState.enemies.find(e => e.id === t.userData.claimedBy);
                        const claimAge = t.userData.claimedAt ? (Date.now() - t.userData.claimedAt) : Infinity;
                        if (!claimer || (claimer && t.position.distanceTo(claimer.position) > maxClaimDistance) || claimAge > 7000) {
                            t.userData.claimedBy = null; t.userData.claimedAt = null;
                        }
                    }
                });
            } catch (e) {}

            gameState.enemies.forEach(enemy => {
                // Process burn damage over time
                if (enemy.userData.burning) {
                    if (now > enemy.userData.burnEnd) {
                        enemy.userData.burning = false;
                    } else {
                        // Apply burn damage every second
                        if (now - enemy.userData.lastBurnTick >= 1000) {
                            enemy.userData.lastBurnTick = now;
                            damageEnemy(enemy, enemy.userData.burnDamage);
                            effectsManager.createDamageNumber(enemy.position, enemy.userData.burnDamage);
                        }
                        
                        // Visual burn effect
                        if (Math.random() < 0.1) {
                            const originalColor = enemy.userData.type === 'ranged' ? 0xa855f7 : 
                                                   enemy.userData.type === 'tank' ? 0xef4444 : 0x4ade80;
                            enemy.material.color.setHex(0xff6600);
                            setTimeout(() => {
                                if (enemy.material) {
                                    enemy.material.color.setHex(originalColor);
                                }
                            }, 100);
                        }
                    }
                }
                
                // Check if this enemy is frozen by an ability. If frozen, we'll skip movement
                // but still allow attack logic to run so melee enemies can hit if in range.
                let isFrozen = false;
                if (enemy.userData && enemy.userData.frozenUntil && now < enemy.userData.frozenUntil) {
                    isFrozen = true;
                    if (gameState.debugAI) console.log(`updateEnemies: enemy id=${enemy.id} frozen until ${enemy.userData.frozenUntil} (now ${now})`);
                }
                
                // Enemies should always know where the player is (player is always a valid target).
                // We do not use `claimedBy` for the player so many enemies can target the player simultaneously.
                const canSeePlayer = !!gameState.player;
                let canSeeAlly = false;
                let closestVisibleAlly = null;
                let closestAllyDist = Infinity;

                // Consider both persistent allies and temporary minions as valid ally targets
                const allyCandidates = [];
                if (gameState.allies && gameState.allies.length > 0) allyCandidates.push(...gameState.allies);
                if (gameState.minions && gameState.minions.length > 0) allyCandidates.push(...gameState.minions);

                allyCandidates.forEach(ally => {
                    if (!isEnemyOnScreen(ally)) return;
                    // Skip allies already claimed by another enemy
                    if (ally.userData && ally.userData.claimedBy && ally.userData.claimedBy !== enemy.id) return;
                    canSeeAlly = true;
                    const allyDist = enemy.position.distanceTo(ally.position);
                    if (allyDist < closestAllyDist) {
                        closestVisibleAlly = ally;
                        closestAllyDist = allyDist;
                    }
                });
                
                // Check for turrets
                let canSeeTurret = false;
                let closestVisibleTurret = null;
                let closestTurretDist = Infinity;
                
                if (gameState.turrets && gameState.turrets.length > 0) {
                    gameState.turrets.forEach(turret => {
                        // Skip turrets claimed by others
                        if (turret.userData && turret.userData.claimedBy && turret.userData.claimedBy !== enemy.id) return;
                        const turretDist = enemy.position.distanceTo(turret.position);
                        if (turretDist < closestTurretDist) {
                            closestVisibleTurret = turret;
                            closestTurretDist = turretDist;
                            canSeeTurret = true;
                        }
                    });
                }
                
                // Check for tycoons
                let canSeeTycoon = false;
                let closestVisibleTycoon = null;
                let closestTycoonDist = Infinity;
                
                if (gameState.tycoons && gameState.tycoons.length > 0) {
                    gameState.tycoons.forEach(tycoon => {
                        if (!tycoon || !tycoon.userData) return;
                        // Skip tycoons claimed by others
                        if (tycoon.userData.claimedBy && tycoon.userData.claimedBy !== enemy.id) return;
                        const tycoonDist = enemy.position.distanceTo(tycoon.position);
                        if (tycoonDist < closestTycoonDist) {
                            closestVisibleTycoon = tycoon;
                            closestTycoonDist = tycoonDist;
                            canSeeTycoon = true;
                        }
                    });
                }
                
                // Choose target: nearest turret, tycoon, ally, or player
                let target = gameState.player;
                let targetIsAlly = false;
                let targetIsTurret = false;
                let targetIsTycoon = false;
                let hasTarget = canSeePlayer;
                
                if (canSeeAlly) {
                    const playerDist = enemy.position.distanceTo(gameState.player.position);
                    if (closestVisibleAlly && closestAllyDist < playerDist) {
                        target = closestVisibleAlly;
                        targetIsAlly = true;
                        hasTarget = true;
                    }
                }
                
                // Prioritize turrets if they're closest
                if (canSeeTurret && closestTurretDist < 15) {
                    const currentTargetDist = enemy.position.distanceTo(target.position);
                    if (closestTurretDist < currentTargetDist) {
                        target = closestVisibleTurret;
                        targetIsTurret = true;
                        targetIsAlly = false;
                        hasTarget = true;
                    }
                }
                
                // Prioritize tycoons if they're closest
                if (canSeeTycoon && closestTycoonDist < 15) {
                    const currentTargetDist = enemy.position.distanceTo(target.position);
                    if (closestTycoonDist < currentTargetDist) {
                        target = closestVisibleTycoon;
                        targetIsTycoon = true;
                        targetIsTurret = false;
                        targetIsAlly = false;
                        hasTarget = true;
                    }
                }
                
                let direction;

                if (hasTarget) {
                    // Move toward visible target
                    direction = new THREE.Vector3()
                        .subVectors(target.position, enemy.position)
                        .normalize();

                    // Release previous claim if switching targets (don't clear player's claimed state because player isn't claimed)
                    const prevTarget = enemy.userData && enemy.userData.currentTarget ? enemy.userData.currentTarget : null;
                    if (prevTarget && prevTarget !== gameState.player && prevTarget.userData && prevTarget.userData.claimedBy === enemy.id && prevTarget !== target) {
                        prevTarget.userData.claimedBy = null;
                        prevTarget.userData.claimedAt = null;
                    }

                    // Claim this target for this enemy if possible (don't claim the player)
                    if (target && target.userData && target !== gameState.player) {
                        if (!target.userData.claimedBy || target.userData.claimedBy === enemy.id) {
                            target.userData.claimedBy = enemy.id;
                            target.userData.claimedAt = Date.now();
                        }
                    }

                    // Record current target on enemy
                    if (!enemy.userData) enemy.userData = {};
                    enemy.userData.currentTarget = target;
                } else {
                    // Release any previous target claim when losing sight (don't modify player)
                    const prevTarget = enemy.userData && enemy.userData.currentTarget ? enemy.userData.currentTarget : null;
                    if (prevTarget && prevTarget !== gameState.player && prevTarget.userData && prevTarget.userData.claimedBy === enemy.id) {
                        prevTarget.userData.claimedBy = null;
                        prevTarget.userData.claimedAt = null;
                    }
                    if (enemy.userData) enemy.userData.currentTarget = null;

                    // No wandering: move toward arena center so enemies enter the play area predictably
                    const center = new THREE.Vector3(0, 0, 0);
                    direction = new THREE.Vector3().subVectors(center, enemy.position).normalize();
                    if (gameState.debugAI) console.log(`updateEnemies: enemy id=${enemy.id} no-target -> moving to center from (${enemy.position.x.toFixed(1)},${enemy.position.y.toFixed(1)}) claimedBy=${enemy.userData && enemy.userData.claimedBy}`);
                }
                
                // Check for barrier collisions before moving
                const newX = enemy.position.x + direction.x * enemy.userData.speed;
                const newY = enemy.position.y + direction.y * enemy.userData.speed;
                const newPos = new THREE.Vector3(newX, newY, 0);
                
                let blockedByBarrier = false;
                let closestBarrier = null;
                let closestBarrierDist = Infinity;
                
                if (abilities.e && abilities.e.barriers) {
                    abilities.e.barriers.forEach(barrier => {
                        if (barrier.userData.active) {
                            const dist = barrier.position.distanceTo(newPos);
                            if (dist <= 2.5) {
                                blockedByBarrier = true;
                                if (dist < closestBarrierDist) {
                                    closestBarrier = barrier;
                                    closestBarrierDist = dist;
                                }
                            }
                        }
                    });
                }
                
                if (!isFrozen) {
                    if (blockedByBarrier && closestBarrier) {
                    // Try to break through the barrier instead of navigating around it.
                    // Move toward the barrier and attack it when in range.
                    const toBarrierVec = new THREE.Vector3().subVectors(closestBarrier.position, enemy.position);
                    const distToBarrier = toBarrierVec.length();
                    const dirToBarrier = toBarrierVec.clone().normalize();
                    const barrierHalfWidth = (closestBarrier.userData && closestBarrier.userData.width) ? (closestBarrier.userData.width/2) : 2;
                    const barrierAttackRange = (enemy.userData.attackRange || 1.5) + barrierHalfWidth;
                    const nowAtk = Date.now();

                    // If within effective attack range, perform an attack on the barrier (respect attackInterval)
                    if (distToBarrier <= barrierAttackRange) {
                        if (!enemy.userData.attackCooldown) enemy.userData.attackCooldown = 0;
                        if (nowAtk - enemy.userData.attackCooldown > (enemy.userData.attackInterval || 800)) {
                            enemy.userData.attackCooldown = nowAtk;
                            const dmgToBarrier = enemy.userData.damage || 6;
                            try {
                                if (!closestBarrier.userData.hp) closestBarrier.userData.hp = closestBarrier.userData.maxHp || 40;
                                closestBarrier.userData.hp -= dmgToBarrier;
                                try { effectsManager.createDamageNumber(closestBarrier.position, dmgToBarrier); } catch(e){}
                                try { effectsManager.createWave(closestBarrier.position, 0.6); } catch(e){}
                                if (gameState && gameState.debugAI) console.log(`enemy id=${enemy.id} hit barrier hp=${closestBarrier.userData.hp}`);
                                if (closestBarrier.userData.hp <= 0) {
                                    // Destroy barrier
                                    closestBarrier.userData.active = false;
                                    try { scene.remove(closestBarrier); } catch(e) {}
                                    try { if (gameState && Array.isArray(gameState.barriers)) { const idx = gameState.barriers.indexOf(closestBarrier); if (idx > -1) gameState.barriers.splice(idx,1); } } catch(e) {}
                                }
                            } catch (e) { /* ignore */ }
                        }

                        // Slightly push into the barrier (visual persistence) so enemies keep applying pressure
                        enemy.position.x += dirToBarrier.x * (enemy.userData.speed * 0.25);
                        enemy.position.y += dirToBarrier.y * (enemy.userData.speed * 0.25);
                    } else {
                        // Move toward the barrier to get into attack range
                        enemy.position.x += dirToBarrier.x * enemy.userData.speed;
                        enemy.position.y += dirToBarrier.y * enemy.userData.speed;
                    }
                    } else if (!blockedByBarrier) {
                        enemy.position.x = newX;
                        enemy.position.y = newY;
                    }
                } else {
                    // Enemy is frozen: skip movement but keep position for attack checks
                    if (gameState.debugAI) {
                        // Log occasionally to avoid spamming
                        if (now % 1000 < 50) console.log(`updateEnemies: skipping movement for frozen enemy id=${enemy.id}`);
                    }
                }
                
                // Rotate enemy
                if (!enemy.userData.dying) {
                    enemy.rotation.x += enemy.userData.rotationSpeed;
                    enemy.rotation.y += enemy.userData.rotationSpeed * 1.5;
                }
                
                // Flash invisible enemies between 0% and 50% opacity
                if (enemy.userData.type === 'invisible' && !enemy.userData.dying) {
                    enemy.userData.invisFlashTimer += deltaTime;
                    // Flash every 800ms
                    const flashCycle = enemy.userData.invisFlashTimer % 800;
                    if (flashCycle < 400) {
                        // Fade from 0 to 0.5
                        enemy.material.opacity = (flashCycle / 400) * 0.5;
                    } else {
                        // Fade from 0.5 to 0
                        enemy.material.opacity = ((800 - flashCycle) / 400) * 0.5;
                    }
                }
                
                // Attack based on type and range
                const dist = enemy.position.distanceTo(target.position);
                const attackRange = enemy.userData.attackRange || 1.5;

                // Throttled debug for melee/tank types to trace why attacks may not fire
                try {
                    if (enemy.userData && (enemy.userData.type === 'melee' || enemy.userData.type === 'tank')) {
                        const last = enemy.userData._lastDbg || 0;
                        if (now - last > 1000) {
                            enemy.userData._lastDbg = now;
                            const dbg = `ENEMYDBG id=${enemy.id} type=${enemy.userData.type} pos=(${enemy.position.x.toFixed(2)},${enemy.position.y.toFixed(2)}) distToPlayer=${dist.toFixed(2)} attackCooldown=${enemy.userData.attackCooldown} attackInterval=${enemy.userData.attackInterval}`;
                        }
                    }
                } catch (e) {}

                // Special behaviors for new enemy types
                try {
                    // Suicide enemies explode on contact
                    if (enemy.userData.type === 'suicide' && !enemy.userData.exploded && dist <= 1.2) {
                        enemy.userData.exploded = true;
                        const pos = enemy.position.clone();
                        effectsManager.createExplosion(pos, 0xff0000);
                        const range = enemy.userData.explodeRange || 3.5;
                        const dmg = enemy.userData.explodeDamage || 50;
                        // Damage player if in range
                        if (gameState.player && pos.distanceTo(gameState.player.position) <= range && !gameState.isInvulnerable) {
                            hpManager.damage(dmg);
                            gameState.lastDamageTime = Date.now();
                            if (hpManager.isDead()) gameOver();
                        }
                        // Kill self
                        damageEnemy(enemy, enemy.userData.hp);
                        return;
                    }

                    // Healer: periodic heal nearby enemies
                    if (enemy.userData.type === 'healer') {
                        const last = enemy.userData.lastHeal || 0;
                        if (Date.now() - last >= (enemy.userData.healInterval || 3000)) {
                            enemy.userData.lastHeal = Date.now();
                            const healRange = 4;
                            gameState.enemies.forEach(other => {
                                if (other && other.userData && other.userData.hp > 0) {
                                    const d = other.position.distanceTo(enemy.position);
                                    if (d <= healRange && other.userData.hp < other.userData.maxHp) {
                                        other.userData.hp = Math.min(other.userData.maxHp, other.userData.hp + (enemy.userData.healAmount || 8));
                                        effectsManager.createDamageNumber(other.position, -(enemy.userData.healAmount || 8));
                                    }
                                }
                            });
                        }
                    }

                    // Summoner: periodically spawn a weak minion near the summoner
                    if (enemy.userData.type === 'summoner') {
                        const last = enemy.userData.lastSummon || 0;
                        const nowT = Date.now();
                        if (nowT - last >= (enemy.userData.summonInterval || 4500)) {
                            enemy.userData.lastSummon = nowT;
                            try {
                                const spawnPos = enemy.position.clone();
                                spawnPos.x += (Math.random() - 0.5) * 1.2;
                                spawnPos.y += (Math.random() - 0.5) * 1.2;
                                const geom = new THREE.SphereGeometry(0.28, 8, 8);
                                const mat = new THREE.MeshStandardMaterial({ color: 0x0a0a12, emissive: 0xffdd99, emissiveIntensity: 0.45, transparent: true, opacity: 0.95 });
                                const minion = new THREE.Mesh(geom, mat);
                                minion.position.copy(spawnPos);
                                minion.userData = { type: 'minion', hp: Math.floor(10 * (1 + (gameState.currentWave-1)*0.05)), maxHp: Math.floor(10 * (1 + (gameState.currentWave-1)*0.05)), speed: 0.035 + (gameState.currentWave * 0.0008), damage: Math.floor(6 * (1 + (gameState.currentWave-1)*0.05)), attackCooldown: 0, attackInterval: 900, attackRange: 1.0, rotationSpeed: 0.02, collisionRadius: 0.45 };
                                scene.add(minion);
                                gameState.enemies.push(minion);
                                if (gameState.debugAI) console.log(`summoner: spawned minion at (${minion.position.x.toFixed(1)},${minion.position.y.toFixed(1)})`);
                            } catch (e) {}
                        }
                    }

                    // Phaser: teleport toward player occasionally
                    if (enemy.userData.type === 'phaser' && gameState.player) {
                        const nowTime = Date.now();
                        if (!enemy.userData.lastTeleport) enemy.userData.lastTeleport = 0;
                        if (nowTime - enemy.userData.lastTeleport >= (enemy.userData.teleportCooldown || 4000) && dist > 5) {
                            enemy.userData.lastTeleport = nowTime;
                                // Teleport near player but keep a safe distance to avoid instant contact
                                const angle = Math.random() * Math.PI * 2;
                                const minOffset = 4; // minimum distance from player after teleport
                                const maxOffset = 7; // maximum distance
                                const offset = minOffset + Math.random() * (maxOffset - minOffset);
                                const nx = gameState.player.position.x + Math.cos(angle) * offset;
                                const ny = gameState.player.position.y + Math.sin(angle) * offset;
                            enemy.position.x = Math.max(-window.innerWidth/40+1, Math.min(window.innerWidth/40-1, nx));
                            enemy.position.y = Math.max(-window.innerHeight/40+1, Math.min(window.innerHeight/40-1, ny));
                            if (gameState.debugAI) console.log(`phaser: teleported enemy id=${enemy.id} near player to (${enemy.position.x.toFixed(1)},${enemy.position.y.toFixed(1)})`);
                        }
                    }
                } catch (e) {}
                
                if (enemy.userData.type === 'ranged' || enemy.userData.type === 'sniper') {
                    // Ranged enemies stop at range and shoot
                    if (dist <= attackRange && dist > 3 && now - enemy.userData.attackCooldown > enemy.userData.attackInterval) {
                        enemy.userData.attackCooldown = now;
                        
                        // Create projectile
                        const projGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                        const projMaterial = new THREE.MeshBasicMaterial({ color: 0xa855f7 });
                        const projectile = new THREE.Mesh(projGeometry, projMaterial);
                        projectile.position.copy(enemy.position);
                        
                        const direction = new THREE.Vector3()
                            .subVectors(target.position, enemy.position)
                            .normalize();
                        
                        projectile.userData = {
                            direction: direction,
                            speed: 0.15,
                            damage: enemy.userData.damage,
                            created: now,
                            lifetime: 5000,
                            isEnemyProjectile: true,
                            targetIsAlly: targetIsAlly,
                            target: target
                        };
                        
                        scene.add(projectile);
                        gameState.projectiles.push(projectile);
                    }
                } else if (now - (enemy.userData.attackCooldown || 0) > (enemy.userData.attackInterval || 800)) {
                    // Determine an effective melee hit range that accounts for player collision radius
                    const playerRadius = (gameState.player && gameState.player.userData && gameState.player.userData.collisionRadius) ? gameState.player.userData.collisionRadius : 0.9;
                    const effectiveMeleeRange = attackRange + playerRadius;
                    if (dist <= effectiveMeleeRange) {
                        // Perform attack and set cooldown
                        enemy.userData.attackCooldown = now;

                        if (targetIsTycoon) {
                            // Tycoons take damage but are not destroyed; floor HP at 1 so they persist
                            try {
                                target.userData.hp -= enemy.userData.damage;
                                effectsManager.createDamageNumber(target.position, enemy.userData.damage);
                                if (target.userData.hp <= 0) {
                                    target.userData.hp = 1;
                                }
                                // Update hp bar if present
                                try { if (target.userData && target.userData.hpBar) target.userData.hpBar.style.width = Math.max(0, (target.userData.hp / target.userData.maxHp) * 100) + '%'; } catch(e){}
                            } catch (e) {}
                        } else if (targetIsTurret) {
                            target.userData.hp -= enemy.userData.damage;
                            effectsManager.createDamageNumber(target.position, enemy.userData.damage);
                            if (target.userData.hp <= 0) {
                                scene.remove(target);
                                const turretIndex = gameState.turrets.indexOf(target);
                                if (turretIndex > -1) gameState.turrets.splice(turretIndex, 1);
                                effectsManager.createExplosion(target.position, 0xffa500);
                            }
                        } else if (targetIsAlly) {
                            target.userData.hp -= enemy.userData.damage;
                            effectsManager.createDamageNumber(target.position, enemy.userData.damage);
                            if (target.userData.hp <= 0) handleAllyDown(target);
                        } else {
                            // Damage player (respect invulnerability)
                            if (!gameState.isInvulnerable) {
                                // Show damage number at player
                                try { effectsManager.createDamageNumber(gameState.player.position, enemy.userData.damage); } catch (e) {}
                                hpManager.damage(enemy.userData.damage);
                                gameState.lastDamageTime = Date.now();
                                if (hpManager.isDead()) gameOver();
                                if (gameState.debugAI) console.log(`updateEnemies: enemy id=${enemy.id} hit player dmg=${enemy.userData.damage} playerHp=${hpManager.currentHp}`);
                            } else {
                                if (gameState.debugAI) console.log(`updateEnemies: enemy id=${enemy.id} tried to damage player (${enemy.userData.damage}) but invulnerable`);
                            }
                        }
                    }
                }
            });
        }
        
        // Game over
        function gameOver() {
            gameState.isGameOver = true;
            gameState.highestWaveReached = Math.max(gameState.highestWaveReached, gameState.currentWave);
            
            // Award EXP based on progression (wave reached + kills)
            if (selectedClass) {
                const className = Object.keys(classes).find(key => classes[key] === selectedClass);
                if (className && classExp[className]) {
                    const expGained = (gameState.currentWave - 1) * 20 + gameState.killCount * 2;
                    classExp[className].exp += expGained;
                    
                    // Level up if needed
                    while (classExp[className].exp >= classExp[className].maxExp && classExp[className].level < 15) {
                        classExp[className].exp -= classExp[className].maxExp;
                            classExp[className].level++;
                        
                        // Evolution at level 15 - max out at 15 and increase evolution tier
                        if (classExp[className].level === 15) {
                            classExp[className].evolution++;
                            classExp[className].exp = 0; // Clear excess exp
                        } else {
                            classExp[className].maxExp = Math.floor(classExp[className].maxExp * 1.5);
                        }
                            // Apply bonuses for this level change
                            applyClassLevelBonuses(className);
                    }

                        // Record last wave reached for this class as a checkpoint
                        try { gameState.globalCheckpoint = gameState.currentWave; localStorage.setItem('globalCheckpoint', String(gameState.currentWave)); if (typeof updateCheckpointHUD === 'function') updateCheckpointHUD(); } catch(e) {}
                    
                    updateExpDisplays();
                    // If at max level (15), convert any leftover EXP into coins at 1:2 rate
                    if (classExp[className].level >= 15 && classExp[className].exp > 0) {
                        const overflow = classExp[className].exp;
                        const coinsFromExp = Math.floor(overflow * 2);
                        gameState.coins = (gameState.coins || 0) + coinsFromExp;
                        classExp[className].exp = 0;
                        if (typeof updateCoinDisplay === 'function') updateCoinDisplay();
                        if (typeof showToast === 'function') showToast(`Converted ${overflow} EXP to ${coinsFromExp} coins`);
                    }
                }
            }
            
            document.getElementById('finalScore').textContent = `Wave: ${gameState.currentWave}`;
            // Show EXP and coin gains summary
            try {
                const className = selectedClass ? Object.keys(classes).find(key => classes[key] === selectedClass) : null;
                let expGained = 0;
                let coinsGained = 0;
                if (className && classExp[className]) {
                    expGained = (gameState.currentWave - 1) * 20 + gameState.killCount * 2;
                    if (classExp[className].level >= 15) {
                        coinsGained = Math.floor((expGained) * 2);
                        // note: conversion already applied in leveling code above if needed
                    }
                }
                const gainsEl = document.getElementById('gameOverGains');
                if (gainsEl) {
                    let txt = '';
                    if (expGained) txt += `EXP Gained: ${expGained}`;
                    if (coinsGained) txt += (txt ? ' â€” ' : '') + `Coins: ${coinsGained}`;
                    gainsEl.textContent = txt;
                }
            } catch (e) {}
            document.getElementById('gameOver').style.display = 'block';
            triggerImmediateSave(); // Save progress after game over
        }
        
        // Restart game
        function restartGame() {
            // If player hits Home during an active run, award EXP as if the run ended
            if (!gameState.isGameOver && selectedClass) {
                try {
                    const className = Object.keys(classes).find(key => classes[key] === selectedClass);
                    if (className && classExp[className]) {
                        const expGained = (gameState.currentWave - 1) * 20 + (gameState.killCount || 0) * 2;
                        classExp[className].exp += expGained;

                        // Level up if needed
                        while (classExp[className].exp >= classExp[className].maxExp && classExp[className].level < 15) {
                            classExp[className].exp -= classExp[className].maxExp;
                            classExp[className].level++;
                            if (classExp[className].level === 15) {
                                classExp[className].evolution++;
                                classExp[className].exp = 0;
                            } else {
                                classExp[className].maxExp = Math.floor(classExp[className].maxExp * 1.5);
                            }
                            applyClassLevelBonuses(className);
                        }

                        // Record last wave reached for this class when the player returns to Home
                        try { gameState.globalCheckpoint = gameState.currentWave; localStorage.setItem('globalCheckpoint', String(gameState.currentWave)); if (typeof updateCheckpointHUD === 'function') updateCheckpointHUD(); } catch(e) {}

                        updateExpDisplays();
                        // If at max level (15), convert any leftover EXP into coins at 1:2 rate
                        if (classExp[className].level >= 15 && classExp[className].exp > 0) {
                            const overflow = classExp[className].exp;
                            const coinsFromExp = Math.floor(overflow * 2);
                            gameState.coins = (gameState.coins || 0) + coinsFromExp;
                            classExp[className].exp = 0;
                            if (typeof updateCoinDisplay === 'function') updateCoinDisplay();
                            if (typeof showToast === 'function') showToast(`Converted ${overflow} EXP to ${coinsFromExp} coins`);
                        }
                        updateBuyButtons();
                    }
                } catch (e) { console.warn('Error awarding EXP on Home', e); }
            }
            // Clear all entities
            gameState.enemies.forEach(enemy => scene.remove(enemy));
            gameState.projectiles.forEach(proj => scene.remove(proj));
            gameState.allies.forEach(ally => scene.remove(ally));
            gameState.turrets.forEach(turret => scene.remove(turret));
            gameState.minions.forEach(minion => scene.remove(minion));
            // Also clear tycoons so they don't persist when returning to home
            try { if (gameState.tycoons && gameState.tycoons.length) gameState.tycoons.forEach(t => { try { scene.remove(t); if (t.userData && t.userData.hpContainer) t.userData.hpContainer.remove(); if (t.userData && t.userData.levelDiv) t.userData.levelDiv.remove(); } catch(e){} }); } catch(e) {}
            
            // Reset game state
            gameState.enemies = [];
            gameState.projectiles = [];
            gameState.allies = [];
            gameState.turrets = [];
            gameState.minions = [];
            gameState.tycoons = [];
            gameState.killCount = 0;
            gameState.isGameOver = false;
            gameState.spawnTimer = 0;
            gameState.isInvulnerable = false;
            gameState.isInvisible = false;
            gameState.machineGunAmmo = 0;
            gameState.machineGunLastFired = 0;
            gameState.currentWave = 1;
            gameState.enemiesThisWave = 0;
            gameState.enemiesPerWave = 10;
            gameState.waveInProgress = false;
            gameState.classSelected = false;
            gameState.enemiesKilledThisWave = 0;
            
            // Reset player
            hpManager.currentHp = hpManager.maxHp;
            hpManager.updateUI();
            player.position.set(0, 0, 0);
            try {
                // Restore the gradient texture map on restart instead of forcing a flat color
                const defaultMap = createGradientTexture(baseColor, accentColor, true, 256);
                if (defaultMap) defaultMap.encoding = THREE.sRGBEncoding;
                player.material.map = defaultMap;
                player.material.color.setHex(0xffffff);
                player.material.emissive.setHex(baseColor);
                player.material.emissiveIntensity = 0.08;
                player.material.needsUpdate = true;
            } catch (e) { console.warn('Failed to restore player gradient on restart', e); }
            
            // Reset UI
            document.getElementById('waveCount').textContent = '1';
            document.getElementById('waveProgress').style.width = '0%';
            document.getElementById('waveProgressText').textContent = '0 / 10';
            document.getElementById('gameOver').style.display = 'none';
            
            // Clear ability cooldowns
            ['ability1', 'ability2', 'ability3'].forEach(id => {
                const abilityEl = document.getElementById(id);
                abilityEl.classList.remove('disabled');
                abilityEl.querySelector('.cooldown-overlay').style.height = '0%';
                abilityEl.querySelector('.cooldown-text').textContent = '';
            });
            // Also clear mobile ability overlays if present
            try {
                ['mAbility1','mAbility2','mAbility3'].forEach(mid => {
                    const mb = document.getElementById(mid);
                    if (!mb) return;
                    const mo = mb.querySelector('.mobile-cooldown-overlay');
                    const mt = mb.querySelector('.mobile-cooldown-text');
                    if (mo) mo.style.height = '0%';
                    if (mt) mt.textContent = '';
                });
            } catch (e) {}
            
            // Clear cooldown intervals
            Object.keys(cooldownIntervals).forEach(key => {
                clearInterval(cooldownIntervals[key].interval);
                delete cooldownIntervals[key];
            });
            
            // Reset selected class
            selectedClass = null;
            abilities = {};

            // Show home screen instead of class selection
            document.getElementById('classSelection').style.display = 'none';
            document.getElementById('homeScreen').style.display = 'flex';

            // Hide HUD when returning to home
            try { const hudEl = document.getElementById('hud'); if (hudEl) hudEl.style.display = 'none'; } catch (e) {}

            // Hide HUD Home button while on the home screen
            const hb = document.getElementById('homeButton');
            if (hb) hb.style.display = 'none';
            // Hide ability UI and mobile controls when returning to home
            try { const ab = document.getElementById('abilities'); if (ab) ab.style.display = 'none'; } catch (e) {}
            try { const mc = document.getElementById('mobileControls'); if (mc) mc.style.display = 'none'; } catch (e) {}
            // Remove any remaining enemy HP UI elements immediately
            try {
                const layer = document.getElementById('enemyHpLayer');
                if (layer) {
                    layer.remove();
                }
            } catch (e) {}
            // Remove any remaining ally HP UI elements
            try {
                const allyLayer = document.getElementById('allyHpLayer');
                if (allyLayer) {
                    allyLayer.remove();
                }
            } catch (e) {}
            // Remove any barriers created by abilities
            try {
                if (gameState.barriers && gameState.barriers.length) {
                    gameState.barriers.forEach(b => { try { scene.remove(b); } catch (e) {} });
                    gameState.barriers = [];
                }
            } catch (e) {}
            triggerImmediateSave(); // Save progress when returning home
        }

            // Download offline version of the game
            function downloadOfflineVersion() {
                const htmlContent = document.documentElement.outerHTML;
                const blob = new Blob(['<!DOCTYPE html>\n' + htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'ShapeBattles_Offline.html';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            function showClassSelection() {
                document.getElementById('homeScreen').style.display = 'none';
                document.getElementById('classSelection').style.display = 'flex';

                // Hide HUD Home button while showing class selection
                const hb = document.getElementById('homeButton');
                if (hb) hb.style.display = 'none';
                // Hide HUD while browsing classes
                try { const hudEl = document.getElementById('hud'); if (hudEl) hudEl.style.display = 'none'; } catch (e) {}
                // Hide ability UI and mobile controls while in menus to avoid layout/stacking issues
                try { const ab = document.getElementById('abilities'); if (ab) ab.style.display = 'none'; } catch (e) {}
                try { const mc = document.getElementById('mobileControls'); if (mc) mc.style.display = 'none'; } catch (e) {}
                    // Clear any lingering invisibility/claims while in menus (only if gameState exists)
                    if (typeof gameState !== 'undefined') {
                        try {
                            gameState.isInvisible = false;
                            if (gameState.player && gameState.player.userData) gameState.player.userData.claimedBy = null;
                            if (gameState.allies) gameState.allies.forEach(a => { if (a.userData) a.userData.claimedBy = null; });
                            if (gameState.turrets) gameState.turrets.forEach(t => { if (t.userData) t.userData.claimedBy = null; });
                        } catch (e) {}
                    }
            }

                // Play again (restart run immediately, keep selected class)
                function playAgain() {
                    try {
                        // Remove entities
                        gameState.enemies.forEach(e => scene.remove(e));
                        gameState.projectiles.forEach(p => scene.remove(p));
                        gameState.allies.forEach(a => scene.remove(a));
                        gameState.turrets.forEach(t => scene.remove(t));
                        gameState.minions.forEach(m => scene.remove(m));
                        // Clear barriers
                        try { if (gameState.barriers) { gameState.barriers.forEach(b=>scene.remove(b)); gameState.barriers = []; } } catch(e){}

                        // Reset arrays and counters but keep selectedClass and abilities intact
                        gameState.enemies = [];
                        gameState.projectiles = [];
                        gameState.allies = [];
                        gameState.turrets = [];
                        gameState.minions = [];
                        gameState.killCount = 0;
                        gameState.isGameOver = false;
                        gameState.spawnTimer = 0;
                        gameState.isInvulnerable = false;
                        gameState.isInvisible = false;
                        gameState.machineGunAmmo = 0;
                        gameState.machineGunLastFired = 0;
                        gameState.currentWave = 1;
                        gameState.enemiesThisWave = 0;
                        gameState.enemiesPerWave = 10;
                        gameState.waveInProgress = false;
                        gameState.enemiesKilledThisWave = 0;

                        // Reset player HP and UI
                        try { hpManager.currentHp = hpManager.maxHp; hpManager.updateUI(); } catch(e){}
                        try { player.position.set(0,0,0); } catch(e){}

                        // Reset UI
                        try { document.getElementById('waveCount').textContent = '1'; } catch(e){}
                        try { document.getElementById('waveProgress').style.width = '0%'; document.getElementById('waveProgressText').textContent = '0 / 10'; } catch(e){}
                        try { document.getElementById('gameOver').style.display = 'none'; } catch(e){}

                        // Clear cooldown overlays
                        ['ability1','ability2','ability3'].forEach(id => {
                            try {
                                const abilityEl = document.getElementById(id);
                                if (abilityEl) { abilityEl.classList.remove('disabled'); abilityEl.querySelector('.cooldown-overlay').style.height = '0%'; abilityEl.querySelector('.cooldown-text').textContent = ''; }
                            } catch(e){}
                        });

                        // Clear mobile cooldown overlays
                        try {
                            ['mAbility1','mAbility2','mAbility3'].forEach(mid => {
                                const mb = document.getElementById(mid);
                                if (!mb) return;
                                const mo = mb.querySelector('.mobile-cooldown-overlay');
                                const mt = mb.querySelector('.mobile-cooldown-text');
                                if (mo) mo.style.height = '0%';
                                if (mt) mt.textContent = '';
                            });
                        } catch(e){}

                        // Clear cooldown intervals
                        try { Object.keys(cooldownIntervals).forEach(key => { clearInterval(cooldownIntervals[key].interval); delete cooldownIntervals[key]; }); } catch(e){}

                        // Ensure classSelected is cleared so startGame actually starts a fresh run
                        try { gameState.classSelected = false; startGame(); } catch(e){}
                    } catch (e) { console.warn('playAgain error', e); }
                }

            function startGame() {
                // If a run is already active, just hide UI. Otherwise start a run.
                if (gameState.classSelected) {
                    document.getElementById('homeScreen').style.display = 'none';
                    document.getElementById('classSelection').style.display = 'none';
                    const hb = document.getElementById('homeButton');
                    if (hb) hb.style.display = 'inline-block';
                    return;
                }

                // If no class has been chosen in this session, try to restore last selection,
                // otherwise default to Electric and select it.
                if (!selectedClass) {
                    let restored = null;
                    try { restored = localStorage.getItem('lastSelectedClass'); } catch (e) { restored = null; }
                    if (restored && typeof classes !== 'undefined' && classes[restored] && isClassUnlocked(restored)) {
                        selectClass(restored);
                    } else {
                        selectClass('electric');
                    }
                }

                // Clear invisibility and any lingering claims so enemies can detect targets immediately
                gameState.isInvisible = false;
                try {
                    if (gameState.player && gameState.player.userData) gameState.player.userData.claimedBy = null;
                    if (gameState.allies) gameState.allies.forEach(a => { if (a.userData) a.userData.claimedBy = null; });
                    if (gameState.turrets) gameState.turrets.forEach(t => { if (t.userData) t.userData.claimedBy = null; });
                } catch (e) {}

                // At this point a class is chosen (either previously or just defaulted).
                // Hide menus and actually enable the wave system to begin the run.
                document.getElementById('homeScreen').style.display = 'none';
                document.getElementById('classSelection').style.display = 'none';
                gameState.classSelected = true;

                // Apply global checkpoint: restore the last saved wave (persisted in localStorage)
                try {
                    let saved = parseInt(localStorage.getItem('globalCheckpoint'), 10);
                    if (isNaN(saved) || saved < 1) saved = (gameState && gameState.globalCheckpoint) ? parseInt(gameState.globalCheckpoint, 10) || 1 : 1;
                    gameState.currentWave = Math.max(1, saved);
                    gameState.enemiesThisWave = 0;
                    gameState.enemiesKilledThisWave = 0;
                    gameState.waveInProgress = false;
                    try { const wc = document.getElementById('waveCount'); if (wc) wc.textContent = gameState.currentWave; } catch(e) {}
                    try { if (typeof updateCheckpointHUD === 'function') updateCheckpointHUD(); } catch(e) {}
                } catch (e) { console.warn('Could not apply global checkpoint', e); }

                // Track a played game for miner quest
                try { trackQuestProgress('gamesPlayed', 1); } catch (e) {}

                // Show HUD when the game actually starts
                const hudEl = document.getElementById('hud');
                if (hudEl) hudEl.style.display = 'block';
                // Show abilities and mobile controls for gameplay
                // Keep the legacy bottom-center ability bar hidden; mobile buttons are the visible indicators
                try { const ab = document.getElementById('abilities'); if (ab) ab.style.display = 'none'; } catch (e) {}
                try { const mc = document.getElementById('mobileControls'); if (mc) mc.style.display = 'flex'; } catch (e) {}

                // Show HUD Home button when in-game
                const hb2 = document.getElementById('homeButton');
                if (hb2) hb2.style.display = 'inline-block';
            }
        
        // Update checkpoint HUD
        function updateCheckpointHUD() {
            try {
                const el = document.getElementById('checkpointNote');
                if (!el) return;
                // Prefer in-memory value, fallback to localStorage
                let saved = (gameState && gameState.globalCheckpoint) ? parseInt(gameState.globalCheckpoint, 10) : NaN;
                try {
                    const ls = parseInt(localStorage.getItem('globalCheckpoint'), 10);
                    if (!isNaN(ls) && ls >= 1) saved = ls;
                } catch (e) {}
                if (!saved || isNaN(saved) || saved < 1) {
                    el.textContent = 'Checkpoint: None';
                    return;
                }
                el.textContent = 'Checkpoint: Wave ' + saved;
            } catch (e) {}
        }

        // Animation loop
        function animate() {
            const now = Date.now();
            // Miner passive: throw shovels or shoot drill
            if (selectedClass && selectedClass.name === 'Miner' && !gameState.isGameOver) {
                if (!player.userData.lastMinerPassive) player.userData.lastMinerPassive = 0;
                const minerLevel = (classExp.miner && classExp.miner.level) ? classExp.miner.level : 1;
                // Fire rate: faster with level (base 1800ms, min 600ms)
                const passiveInterval = Math.max(600, 1800 - (minerLevel - 1) * 80);
                if (now - player.userData.lastMinerPassive > passiveInterval) {
                    player.userData.lastMinerPassive = now;
                    // Alternate: every 4th shot is a drill, others are shovels
                    if (!player.userData.minerPassiveCount) player.userData.minerPassiveCount = 0;
                    player.userData.minerPassiveCount++;
                    // Find nearest enemy for auto-aim
                    let target = null;
                    let minDist = Infinity;
                    for (const enemy of gameState.enemies) {
                        if (!isEnemyOnScreen(enemy)) continue;
                        const dist = player.position.distanceTo(enemy.position);
                        if (dist < minDist) {
                            minDist = dist;
                            target = enemy;
                        }
                    }
                    // If no enemies, fire forward
                    let aimDir;
                    if (target) {
                        aimDir = target.position.clone().sub(player.position).setZ(0).normalize();
                    } else {
                        aimDir = new THREE.Vector3(0, 1, 0).applyQuaternion(player.quaternion);
                    }
                    if (player.userData.minerPassiveCount % 4 === 0) {
                        // Shoot drill: fast, piercing, high damage
                        const drillGeom = new THREE.CylinderGeometry(0.13, 0.13, 1.2, 8);
                        const drillMat = new THREE.MeshStandardMaterial({ color: 0xd1b000, metalness: 0.6, roughness: 0.3 });
                        const drill = new THREE.Mesh(drillGeom, drillMat);
                        drill.position.copy(player.position);
                        drill.position.z += 0.2;
                        drill.rotation.x = Math.PI / 2;
                        drill.userData = {
                            velocity: aimDir.clone().multiplyScalar(0.55 + 0.02 * minerLevel),
                            damage: 32 + 4 * minerLevel,
                            pierce: 2 + Math.floor(minerLevel / 5),
                            owner: 'player',
                            isDrill: true,
                            createdAt: now
                        };
                        scene.add(drill);
                        gameState.projectiles.push(drill);
                    } else {
                        // Throw shovel: moderate speed, moderate damage
                        const shovelGeom = new THREE.BoxGeometry(0.5, 0.12, 0.08);
                        const shovelMat = new THREE.MeshStandardMaterial({ color: 0xd1b000, metalness: 0.3, roughness: 0.4 });
                        const shovel = new THREE.Mesh(shovelGeom, shovelMat);
                        shovel.position.copy(player.position);
                        shovel.position.z += 0.18;
                        shovel.userData = {
                            velocity: aimDir.clone().multiplyScalar(0.38 + 0.01 * minerLevel),
                            damage: 18 + 2 * minerLevel,
                            pierce: 1,
                            owner: 'player',
                            isShovel: true,
                            createdAt: now
                        };
                        scene.add(shovel);
                        gameState.projectiles.push(shovel);
                    }
                }
            }
            requestAnimationFrame(animate);
            
            if (gameState.isGameOver) {
                renderer.render(scene, camera);
                return;
            }
            
            const deltaTime = now - gameState.lastTime;
            gameState.lastTime = now;
            
            // Auto-fire machine gun when R is held
            if (keys.r && abilities.r && selectedClass && selectedClass.name === 'Engineer') {
                const result = abilities.r.execute();
                if (result === 'reload') {
                    updateAbilityCooldown('ability3', abilities.r.cooldown);
                }
                if (result) {
                    document.getElementById('ability3').style.transform = 'scale(0.9)';
                    setTimeout(() => {
                        document.getElementById('ability3').style.transform = 'scale(1)';
                    }, 100);
                }
            }
            
            // Check if wave is completed FIRST (killed enough enemies)
            if (gameState.classSelected && gameState.enemiesKilledThisWave >= gameState.enemiesPerWave) {
                console.log(`Wave ${gameState.currentWave} COMPLETED! Killed ${gameState.enemiesKilledThisWave}/${gameState.enemiesPerWave} enemies. Advancing to Wave ${gameState.currentWave + 1}`);
                gameState.currentWave++;
                try { gameState.globalCheckpoint = gameState.currentWave; localStorage.setItem('globalCheckpoint', String(gameState.currentWave)); if (typeof updateCheckpointHUD === 'function') updateCheckpointHUD(); } catch(e) {}
                // Track quest progress: highest wave reached
                if (typeof trackQuestProgress === 'function') trackQuestProgress('highestWave', gameState.currentWave);
                gameState.enemiesKilledThisWave = 0;
                gameState.waveInProgress = false; // End current wave
                document.getElementById('waveCount').textContent = gameState.currentWave;
                // Reset boss coin reward for new wave
                gameState.bossCoinAwardedThisWave = false;

                // Clear any lingering target claims from previous wave
                try {
                    if (gameState.player && gameState.player.userData) gameState.player.userData.claimedBy = null;
                    if (gameState.allies) gameState.allies.forEach(a => { if (a.userData) a.userData.claimedBy = null; });
                    if (gameState.turrets) gameState.turrets.forEach(t => { if (t.userData) t.userData.claimedBy = null; });
                } catch (e) {
                    // ignore
                }
            }
            
            // Wave-based spawning (only if class selected and ready for new wave)
            if (gameState.classSelected && !gameState.waveInProgress && gameState.enemiesKilledThisWave === 0) {
                // Start new wave
                gameState.waveInProgress = true;
                gameState.enemiesThisWave = 0;
                gameState.enemiesPerWave = 10 * gameState.currentWave; // 10 * wave number
                document.getElementById('waveProgress').style.width = '0%';
                document.getElementById('waveProgressText').textContent = '0 / ' + gameState.enemiesPerWave;
                
                // Reset boss coin reward for new wave
                gameState.bossCoinAwardedThisWave = false;

                // Spawn wave message
                console.log(`Wave ${gameState.currentWave} STARTING! Need to kill ${gameState.enemiesPerWave} enemies.`);
                // Reset yellow (boss) spawn flag each wave
                gameState.yellowSpawnedThisWave = false;
            }
            
            // Spawn enemies for current wave
            if (gameState.waveInProgress && gameState.enemiesThisWave < gameState.enemiesPerWave) {
                gameState.spawnTimer += deltaTime;
                const spawnRate = Math.max(500, 2000 - (gameState.currentWave * 100));
                
                if (gameState.spawnTimer >= spawnRate) {
                    gameState.spawnTimer = 0;
                    createEnemy();
                    gameState.enemiesThisWave++;
                    
                    // End wave spawning
                    if (gameState.enemiesThisWave >= gameState.enemiesPerWave) {
                        gameState.waveInProgress = false;
                    }
                }
            }
            
            // Update systems
            movementManager.update();
            updateProjectiles(deltaTime);
            updateTurrets(deltaTime);
            updateMinions(deltaTime);
            updateAllies(deltaTime);
            updatePlayerMelee(deltaTime);
            updateEnemies(deltaTime);
            updateMines(deltaTime);
            // Ensure entities behave as solids after movement
            resolveEntityCollisions();
            // Eject player if overlapping a barrier/enemy (prevents getting stuck inside walls)
            try {
                const wasEjected = ejectPlayerFromBarriers();
                // If player is not inside blocked geometry now, update last safe pos
                if (!pointIsBlocked(player.position.x, player.position.y)) {
                    try { gameState._lastSafePlayerPos = player.position.clone(); } catch (e) {}
                } else {
                    // If still blocked after ejection, fallback teleport to last safe position or center
                    try {
                        let fallback = (gameState._lastSafePlayerPos && gameState._lastSafePlayerPos.clone) ? gameState._lastSafePlayerPos.clone() : null;
                            if (!fallback || pointIsBlocked(fallback.x, fallback.y)) {
                            // try finding nearest safe from origin (search whole map)
                            fallback = findNearestSafePoint(new THREE.Vector3(0,0,0));
                        }
                        if (fallback) safeTeleportTo(fallback);
                    } catch (e) {
                        try { safeTeleportTo(new THREE.Vector3(0,0,0)); } catch (e) {}
                    }
                }
            } catch (e) { /* ignore */ }
            // If player is touching map borders, immediately relocate to nearest safe spot
            try { ensurePlayerNotOnBorder(0.6); } catch (e) { /* ignore */ }
            effectsManager.update();
            updateCameraShake();
            
            // Passive healing (all classes except Life, after 3 seconds without damage)
            if (selectedClass && selectedClass.name !== 'Life' && !gameState.isGameOver) {
                const timeSinceLastDamage = now - gameState.lastDamageTime;
                const timeSinceLastHeal = now - gameState.lastHealTime;
                
                // Heal 1 HP every 2 seconds after 3 seconds of not taking damage
                if (timeSinceLastDamage >= 3000 && timeSinceLastHeal >= 2000) {
                    if (hpManager.currentHp < hpManager.maxHp) {
                        hpManager.heal(1);
                        gameState.lastHealTime = now;
                    }
                }
            }
            
            // Player idle animation
            player.rotation.y += player.userData.rotationSpeed;
            const time = Date.now() * 0.001;
            player.position.z = Math.sin(time * 2) * 0.1;
            
            // Animate player glow ring
            if (player.children[0]) {
                player.children[0].rotation.z += 0.03;
                player.children[0].material.opacity = 0.3 + Math.sin(time * 3) * 0.1;
            }

            // Auto-collect tycoons when player moves near them (avoid immediate collection on spawn)
            try {
                if (gameState.tycoons && gameState.tycoons.length > 0 && gameState.player) {
                    for (let i = gameState.tycoons.length - 1; i >= 0; i--) {
                        const tycoon = gameState.tycoons[i];
                        if (!tycoon || !tycoon.userData) continue;
                        const created = tycoon.userData.createdAt || tycoon.userData.created || 0;
                        // require at least 800ms after spawn before auto-collect to avoid instant pickup
                        if (Date.now() - created < 800) continue;
                        const dist = tycoon.position.distanceTo(gameState.player.position);
                        const collectRange = 1.6; // proximity pickup radius
                        if (dist <= collectRange) {
                            const coinsCollected = Math.max(1, Math.round((tycoon.userData.level || 1) * (tycoon.userData.coinMultiplier || 1)));
                            gameState.coins = (gameState.coins || 0) + coinsCollected;
                            try { if (typeof updateCoinDisplay === 'function') updateCoinDisplay(); else document.getElementById('coinCount').textContent = gameState.coins; } catch(e){}
                            try { if (typeof trackQuestProgress === 'function') trackQuestProgress('totalCoinsEarned', coinsCollected); } catch(e) {}
                            try { effectsManager.createDamageNumber(tycoon.position, -coinsCollected); } catch(e) {}
                            try { effectsManager.createExplosion(tycoon.position, 0xffd700); } catch(e) {}
                            // remove tycoon and its UI
                            try { scene.remove(tycoon); } catch(e) {}
                            try { if (tycoon.userData.hpContainer) tycoon.userData.hpContainer.remove(); } catch(e) {}
                            try { if (tycoon.userData.levelDiv) tycoon.userData.levelDiv.remove(); } catch(e) {}
                            gameState.tycoons.splice(i, 1);
                        }
                    }
                }
            } catch (e) {}

            // Update enemy HP UI (screen-space DOM)
            try {
                if (Array.isArray(gameState.enemies)) {
                    for (const enemy of gameState.enemies) {
                        if (!enemy || !enemy.userData) continue;
                        // remove UI if enemy removed from scene
                        if (!enemy.parent) {
                            if (enemy.userData.hpUI && enemy.userData.hpUI.el) {
                                try { enemy.userData.hpUI.el.remove(); } catch (e) {}
                                delete enemy.userData.hpUI;
                            }
                            continue;
                        }
                        // If enemy is an invisible type, do not show an HP bar (prevents giveaway)
                        if (enemy.userData && enemy.userData.type === 'invisible') {
                            if (enemy.userData.hpUI && enemy.userData.hpUI.el) {
                                try { enemy.userData.hpUI.el.style.display = 'none'; } catch (e) {}
                            }
                            continue;
                        }
                        // If no HP UI yet, create it only when the enemy is fully on-screen
                        if (!enemy.userData.hpUI || !enemy.userData.hpUI.el) {
                            if (isEnemyFullyOnScreen(enemy)) {
                                createEnemyHPUI(enemy);
                            } else {
                                continue;
                            }
                        }
                        const ui = enemy.userData.hpUI;
                        if (!ui || !ui.el) continue;
                        const fg = ui.el.querySelector('.bar-fg');
                        if (!fg) continue;
                        const hp = (enemy.userData.hp != null) ? enemy.userData.hp : (enemy.userData.maxHp || 0);
                        const maxHp = (enemy.userData.maxHp != null) ? enemy.userData.maxHp : hp;
                        const ratio = maxHp > 0 ? Math.max(0, Math.min(1, hp / maxHp)) : 0;
                        // project world pos to screen
                        const pos = enemy.position.clone();
                        pos.project(camera);
                        const sx = (pos.x + 1) / 2 * window.innerWidth;
                        const sy = (-pos.y + 1) / 2 * window.innerHeight;
                        // vertical offset above enemy head (further reduced multiplier and clamp)
                        let yOffset = Math.round((ui.radius || 1) * 10 + 2);
                        yOffset = Math.max(8, Math.min(32, yOffset));
                        // clamp to screen so hud isn't accidentally covered
                        let leftPx = Math.round(sx);
                        let topPx = Math.round(sy - yOffset);
                        leftPx = Math.max(8, Math.min(window.innerWidth - 8, leftPx));
                        topPx = Math.max(8, Math.min(window.innerHeight - 8, topPx));
                        ui.el.style.left = leftPx + 'px';
                        ui.el.style.top = topPx + 'px';
                        // update foreground width
                        fg.style.width = Math.round(ratio * 100) + '%';
                        // color change
                        if (ratio > 0.6) fg.style.background = 'linear-gradient(90deg,#4ade80,#22c55e)';
                        else if (ratio > 0.3) fg.style.background = 'linear-gradient(90deg,#fbbf24,#f59e0b)';
                        else fg.style.background = 'linear-gradient(90deg,#ff3b3b,#dc2626)';
                    }
                }
            } catch (e) {}

            // Update ally HP UI (screen-space DOM)
            try {
                if (Array.isArray(gameState.allies)) {
                    for (const ally of gameState.allies) {
                        if (!ally || !ally.userData) continue;
                        // remove UI if ally removed from scene
                        if (!ally.parent) {
                            if (ally.userData.hpUI && ally.userData.hpUI.el) {
                                try { ally.userData.hpUI.el.remove(); } catch (e) {}
                                delete ally.userData.hpUI;
                            }
                            continue;
                        }
                        // If no HP UI yet, create it
                        if (!ally.userData.hpUI || !ally.userData.hpUI.el) {
                            createAllyHPUI(ally);
                        }
                        const ui = ally.userData.hpUI;
                        if (!ui || !ui.el) continue;
                        const fg = ui.el.querySelector('.bar-fg');
                        if (!fg) continue;
                        const hp = (ally.userData.hp != null) ? ally.userData.hp : 50;
                        const maxHp = (ally.userData.maxHp != null) ? ally.userData.maxHp : 50;
                        const ratio = maxHp > 0 ? Math.max(0, Math.min(1, hp / maxHp)) : 0;
                        // project world pos to screen
                        const pos = ally.position.clone();
                        pos.project(camera);
                        const sx = (pos.x + 1) / 2 * window.innerWidth;
                        const sy = (-pos.y + 1) / 2 * window.innerHeight;
                        let yOffset = Math.round((ui.radius || 0.8) * 10 + 2);
                        yOffset = Math.max(8, Math.min(24, yOffset));
                        let leftPx = Math.round(sx);
                        let topPx = Math.round(sy - yOffset);
                        leftPx = Math.max(8, Math.min(window.innerWidth - 8, leftPx));
                        topPx = Math.max(8, Math.min(window.innerHeight - 8, topPx));
                        ui.el.style.left = leftPx + 'px';
                        ui.el.style.top = topPx + 'px';
                        fg.style.width = Math.round(ratio * 100) + '%';
                        // Blue color for allies
                        if (ratio > 0.5) fg.style.background = 'linear-gradient(90deg,#3b82f6,#2563eb)';
                        else if (ratio > 0.25) fg.style.background = 'linear-gradient(90deg,#f59e0b,#d97706)';
                        else fg.style.background = 'linear-gradient(90deg,#ef4444,#dc2626)';
                    }
                }
            } catch (e) {}

            // Miner shovel passive spin (if present)
            try {
                if (player.userData && player.userData.shovelMesh) {
                    const shovel = player.userData.shovelMesh;
                    const baseRadius = player.userData.shovelRadius || 1.2;
                    // If drill is active, make shovel larger and faster
                    const nowMs = Date.now();
                    const drillActive = player.userData.drillUntil && nowMs < player.userData.drillUntil;
                    const targetRadius = drillActive ? baseRadius * 1.6 : baseRadius;
                    const targetScale = drillActive ? 1.6 : 1.0;
                    const speedFactor = player.userData.shovelSpeed || 0.16;
                    // Smoothly approach target radius and scale
                    player.userData.shovelRadius = player.userData.shovelRadius + (targetRadius - player.userData.shovelRadius) * 0.08;
                    shovel.scale.x += (targetScale - shovel.scale.x) * 0.12;
                    shovel.scale.y = shovel.scale.x;
                    shovel.scale.z = shovel.scale.x;
                    // Advance angle based on deltaTime-ish feel
                    const angleInc = speedFactor * (deltaTime / 16);
                    player.userData.shovelAngle = (player.userData.shovelAngle || 0) + angleInc;
                    const a = player.userData.shovelAngle;
                    shovel.position.x = Math.cos(a) * player.userData.shovelRadius;
                    shovel.position.y = Math.sin(a) * player.userData.shovelRadius;
                    shovel.position.z = 0.12 + (drillActive ? 0.06 : 0);
                    shovel.rotation.z = a + Math.PI / 6;
                }
            } catch (e) {}
            
            renderer.render(scene, camera);
            try {
                if (gameState.debugAI) {
                    if (_prevInvulnerable !== gameState.isInvulnerable) {
                        console.log(`gameState.isInvulnerable changed: ${_prevInvulnerable} -> ${gameState.isInvulnerable}`);
                        _prevInvulnerable = gameState.isInvulnerable;
                    }
                    if (_prevInvisible !== gameState.isInvisible) {
                        console.log(`gameState.isInvisible changed: ${_prevInvisible} -> ${gameState.isInvisible}`);
                        _prevInvisible = gameState.isInvisible;
                    }
                }
            } catch (e) {}
        }
        
        // Window resize
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = window.innerWidth / -40;
            camera.right = window.innerWidth / 40;
            camera.top = window.innerHeight / 40;
            camera.bottom = window.innerHeight / -40;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            movementManager.updateBounds();
        });
        
        // Enemies will spawn after class selection
        // Initial spawn is handled in selectClass() function
        
        // Animation loop interval placeholder
        
        // Start
        animate();
        
        // Developer Console Commands
        window.devGiveExp = function(amount = 1000) {
            if (!selectedClass) {
                console.log('No class selected!');
                return;
            }
            const className = Object.keys(classes).find(key => classes[key] === selectedClass);
            if (className && classExp[className]) {
                classExp[className].exp += amount;
                while (classExp[className].exp >= classExp[className].maxExp && classExp[className].level < 15) {
                    classExp[className].exp -= classExp[className].maxExp;
                    classExp[className].level++;
                    if (classExp[className].level === 15) {
                        classExp[className].evolution++;
                        classExp[className].exp = 0; // Clear excess exp
                    } else {
                        classExp[className].maxExp = Math.floor(classExp[className].maxExp * 1.5);
                    }
                    applyClassLevelBonuses(className);
                }
                updateExpDisplays();
                updateBuyButtons();
                console.log(`Added ${amount} exp to ${className}. Now Level ${classExp[className].level} Evolution ${classExp[className].evolution}`);
                // If at max level (15), convert any leftover EXP into coins at 1:2 rate
                if (classExp[className].level >= 15 && classExp[className].exp > 0) {
                    const overflow = classExp[className].exp;
                    const coinsFromExp = Math.floor(overflow * 2);
                    gameState.coins = (gameState.coins || 0) + coinsFromExp;
                    classExp[className].exp = 0;
                    if (typeof updateCoinDisplay === 'function') updateCoinDisplay();
                    console.log(`Converted ${overflow} EXP to ${coinsFromExp} coins (devGiveExp)`);
                }
            }
        };
        
        window.devSetLevel = function(level) {
            if (!selectedClass) {
                console.log('No class selected!');
                return;
            }
            const className = Object.keys(classes).find(key => classes[key] === selectedClass);
            if (className && classExp[className]) {
                classExp[className].level = Math.max(1, Math.min(15, level));
                classExp[className].exp = 0;
                applyClassLevelBonuses(className);
                updateExpDisplays();
                updateBuyButtons();
                console.log(`Set ${className} to level ${classExp[className].level}`);
            }
        };
        
        window.devEvolve = function() {
            if (!selectedClass) {
                console.log('No class selected!');
                return;
            }
            const className = Object.keys(classes).find(key => classes[key] === selectedClass);
            if (className && classExp[className]) {
                classExp[className].evolution++;
                classExp[className].level = 15;
                classExp[className].exp = 0;
                updateExpDisplays();
                console.log(`${className} evolved! Evolution tier ${classExp[className].evolution}`);
            }
        };
        
        window.devKillAll = function() {
            const count = gameState.enemies.length;
            gameState.enemies.forEach(enemy => {
                scene.remove(enemy);
            });
            gameState.enemies = [];
            gameState.enemiesKilledThisWave += count;
            console.log(`Killed ${count} enemies`);
        };
        
        window.devSpawnEnemies = function(count = 10) {
            for (let i = 0; i < count; i++) {
                createEnemy();
            }
            console.log(`Spawned ${count} enemies`);
        };
        
        window.devSetWave = function(wave) {
            gameState.currentWave = Math.max(1, wave);
            gameState.enemiesKilledThisWave = 0;
            gameState.waveInProgress = false;
            document.getElementById('waveCount').textContent = gameState.currentWave;
            console.log(`Set wave to ${gameState.currentWave}`);
        };

        window.devToggleAI = function(val) {
            if (typeof val === 'undefined') gameState.debugAI = !gameState.debugAI;
            else gameState.debugAI = !!val;
            console.log('gameState.debugAI =', gameState.debugAI);
        };
        
        window.devGodMode = function() {
            gameState.isInvulnerable = !gameState.isInvulnerable;
            console.log(`God mode: ${gameState.isInvulnerable ? 'ON' : 'OFF'}`);
        };
        
        window.devMaxHP = function() {
            hpManager.heal(9999);
            console.log('HP restored to max');
        };
        
        window.devResetCooldowns = function() {
            if (abilities.q) abilities.q.lastUsed = 0;
            if (abilities.e) abilities.e.lastUsed = 0;
            if (abilities.r) abilities.r.lastUsed = 0;
            console.log('All cooldowns reset');
        };

        // Grant test coins for development
        window.devGiveCoins = function(amount = 1000) {
            try {
                const n = Number(amount) || 0;
                gameState.coins = (gameState.coins || 0) + n;
                try { if (typeof updateCoinDisplay === 'function') updateCoinDisplay(); } catch (e) {}
                try { saveToLocalStorage(); } catch (e) {}
                console.log(`Gave ${n} coins. Total now: ${gameState.coins}`);
            } catch (e) { console.error('devGiveCoins failed', e); }
        };

        // Set coins to an exact value
        window.devSetCoins = function(amount = 0) {
            try {
                const n = Math.max(0, Number(amount) || 0);
                gameState.coins = n;
                try { if (typeof updateCoinDisplay === 'function') updateCoinDisplay(); } catch (e) {}
                try { saveToLocalStorage(); } catch (e) {}
                console.log(`Set coins to ${gameState.coins}`);
            } catch (e) { console.error('devSetCoins failed', e); }
        };

        // Unlock a specific class by key (e.g. 'thief' or 'miner')
        window.devUnlockClass = function(classKey) {
            try {
                if (!classKey) {
                    console.log('Usage: devUnlockClass("classKey"). Available keys:');
                    console.log(Object.keys(classes || {}));
                    return;
                }
                if (!classes || !classes[classKey]) {
                    console.log('Invalid class key:', classKey);
                    return;
                }
                // Support unlockedClasses being either Set or Array
                if (!unlockedClasses) unlockedClasses = new Set();
                if (Array.isArray(unlockedClasses)) {
                    if (!unlockedClasses.includes(classKey)) unlockedClasses.push(classKey);
                } else {
                    unlockedClasses.add(classKey);
                }
                try { updateClassCardLockState && updateClassCardLockState(); } catch (e) {}
                try { updateBuyButtons && updateBuyButtons(); } catch (e) {}
                try { saveToLocalStorage && saveToLocalStorage(); } catch (e) {}
                console.log('Unlocked class:', classKey);
            } catch (e) { console.error('devUnlockClass failed', e); }
        };

        // Unlock all classes
        window.devUnlockAllClasses = function() {
            try {
                const keys = Object.keys(classes || {});
                if (!unlockedClasses) unlockedClasses = new Set();
                if (Array.isArray(unlockedClasses)) {
                    for (const k of keys) if (!unlockedClasses.includes(k)) unlockedClasses.push(k);
                } else {
                    for (const k of keys) unlockedClasses.add(k);
                }
                try { updateClassCardLockState && updateClassCardLockState(); } catch (e) {}
                try { updateBuyButtons && updateBuyButtons(); } catch (e) {}
                try { saveToLocalStorage && saveToLocalStorage(); } catch (e) {}
                console.log('Unlocked all classes:', keys.length);
            } catch (e) { console.error('devUnlockAllClasses failed', e); }
        };
        
        window.devShowState = function() {
            const className = selectedClass ? Object.keys(classes).find(key => classes[key] === selectedClass) : 'None';
            console.log('=== GAME STATE ===');
            console.log('Class:', className);
            if (className && classExp[className]) {
                console.log(`Level: ${classExp[className].level} | Evolution: ${classExp[className].evolution}`);
                console.log(`Exp: ${classExp[className].exp}/${classExp[className].maxExp}`);
            }
            console.log(`HP: ${hpManager ? hpManager.getHP() + '/' + hpManager.getMaxHP() : 'N/A'}`);
            console.log(`Wave: ${gameState.currentWave}`);
            console.log(`Enemies: ${gameState.enemies.length}`);
            console.log(`Killed this wave: ${gameState.enemiesKilledThisWave}/${gameState.enemiesPerWave}`);
            console.log(`Total kills: ${gameState.killCount}`);
            console.log(`God mode: ${gameState.isInvulnerable ? 'ON' : 'OFF'}`);
            console.log(`Allies: ${gameState.allies.length}`);
            console.log(`Turrets: ${gameState.turrets.length}`);
            console.log('==================');
        };
        
        window.devHelp = function() {
            console.log('=== DEVELOPER COMMANDS ===');
            console.log('devGiveExp(amount) - Add exp to current class (default: 1000)');
            console.log('devSetLevel(level) - Set current class level (1-14)');
            console.log('devEvolve() - Force evolve current class');
            console.log('devKillAll() - Kill all enemies');
            console.log('devSpawnEnemies(count) - Spawn enemies (default: 10)');
            console.log('devSetWave(wave) - Jump to specific wave');
            console.log('devGodMode() - Toggle invulnerability');
            console.log('devMaxHP() - Restore HP to max');
            console.log('devResetCooldowns() - Reset all ability cooldowns');
            console.log('devGiveCoins(amount) - Add coins to player (default: 1000)');
            console.log('devSetCoins(amount) - Set player coins to exact value');
            console.log('devUnlockClass(classKey) - Unlock a single class (shows available keys if omitted)');
            console.log('devUnlockAllClasses() - Unlock every class');
            console.log('devShowState() - Display current game state');
            console.log('devHelp() - Show this help message');
            console.log('==========================');
        };
        
        console.log('%c[DEV] Developer commands loaded! Type devHelp() for list of commands.', 'color: #00ff00; font-weight: bold;');
    </script>
    <script>
    (function(){
        function initLogout(){
            const btn = document.getElementById('logoutBtn');
            if(!btn) return;
            const apiBase = (typeof API_BASE !== 'undefined' && API_BASE) ? API_BASE : (window.API_BASE || '');
            btn.style.display = 'block';
            btn.addEventListener('click', function(){
                const base = apiBase.replace(/\/$/, '');
                const url = base ? base + '/logout' : '/logout';
                window.location.href = url;
            });
        }
        if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initLogout);
        else initLogout();
    })();
    </script>
</body>
</html>