<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Combat Arena - Full Version</title>
    <script>
    // Inlined from classCardAutoSize.js â€” restructures `.class-card` into left/right columns
    window.addEventListener('DOMContentLoaded', function () {
        function ensureCardLayout() {
            document.querySelectorAll('.class-card').forEach(card => {
                if (card.dataset.restructured) return; // already done

                // create containers
                const left = document.createElement('div');
                left.className = 'card-left';
                const right = document.createElement('div');
                right.className = 'card-right';

                // find primary nodes: .class-icon, h2, first p, .ability-list, .class-exp-container
                const icon = card.querySelector('.class-icon');
                const title = card.querySelector('h2');
                const desc = card.querySelector('p');
                const abilities = card.querySelector('.ability-list');
                const exp = card.querySelector('.class-exp-container');

                // left: title + abilities (static)
                if (title) left.appendChild(title);
                if (abilities) left.appendChild(abilities);

                // right: description + exp/buttons (tangible)
                if (desc) right.appendChild(desc);
                if (exp) right.appendChild(exp);

                // move any remaining children not moved into right
                Array.from(card.childNodes).forEach(node => {
                    if (node === left || node === right) return;
                    // skip nodes we already moved
                    if (node.nodeType === 1 && (node.classList.contains('card-left') || node.classList.contains('card-right'))) return;
                    // append remaining interactive/content nodes to right
                    if (node.nodeType === 1) right.appendChild(node);
                });

                // clear card and append left + right
                card.innerHTML = '';
                card.appendChild(left);
                card.appendChild(right);
                card.dataset.restructured = '1';

                // ensure consistent sizing
                card.style.boxSizing = 'border-box';
                card.style.flex = '0 0 420px';
                card.style.width = '420px';
            });
        }

        ensureCardLayout();
        // make all cards equal height (match tallest) and recalc on resize
        function equalizeCardHeights() {
            const cards = Array.from(document.querySelectorAll('.class-card'));
            if (!cards.length) return;
            // reset heights to natural
            cards.forEach(c => { c.style.height = 'auto'; });
            // allow layout to settle then measure
            requestAnimationFrame(() => {
                let maxH = 0;
                cards.forEach(c => {
                    const h = c.getBoundingClientRect().height;
                    if (h > maxH) maxH = h;
                });
                if (maxH > 0) cards.forEach(c => { c.style.height = Math.ceil(maxH) + 'px'; });
            });
        }

        equalizeCardHeights();
        window.addEventListener('resize', () => { ensureCardLayout(); equalizeCardHeights(); });
        window.addEventListener('load', () => { ensureCardLayout(); equalizeCardHeights(); });
    });
    </script>
    <style>
        * {
            box-sizing: border-box;
        }
        
        /* Loading Screen */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 99999;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }
        #loadingScreen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }
        #loadingScreen h1 {
            color: #4ade80;
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(74, 222, 128, 0.5);
            letter-spacing: 8px;
        }
        #loadingBarContainer {
            width: 300px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid rgba(74, 222, 128, 0.3);
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }
        #loadingBar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #22d3ee);
            border-radius: 8px;
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(74, 222, 128, 0.5);
        }
        #loadingText {
            color: rgba(255, 255, 255, 0.7);
            margin-top: 15px;
            font-size: 14px;
            letter-spacing: 2px;
        }
        
        /* Custom Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            border: 1px solid rgba(74, 222, 128, 0.1);
        }
        
        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, rgba(74, 222, 128, 0.6), rgba(74, 222, 128, 0.4));
            border-radius: 10px;
            border: 2px solid rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, rgba(74, 222, 128, 0.9), rgba(74, 222, 128, 0.7));
            box-shadow: 0 0 10px rgba(74, 222, 128, 0.5);
        }
        
        ::-webkit-scrollbar-thumb:active {
            background: linear-gradient(180deg, rgba(74, 222, 128, 1), rgba(74, 222, 128, 0.8));
        }
        
        ::-webkit-scrollbar-corner {
            background: rgba(0, 0, 0, 0.3);
        }
        
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
        }
        
        canvas {
            display: block;
        }
        
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            border-radius: 12px;
            border: 2px solid rgba(255, 59, 59, 0.5);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
            z-index: 1100;
        }
        
        .hp-bar-container {
            width: 200px;
            height: 25px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            overflow: hidden;
            margin-top: 8px;
            position: relative;
        }
        
        .hp-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff3b3b 0%, #ff6b6b 100%);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(255, 59, 59, 0.6);
        }
        
        .hp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        /* Desktop ability bar kept in DOM for keyboard users, but hidden visually
           so mobile players only see the mobile buttons as the ability indicators. */
        #abilities {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            visibility: hidden !important;
            pointer-events: none !important;
        }
        
        .ability {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.6));
            backdrop-filter: blur(10px);
            border: 2px solid rgba(74, 222, 128, 0.5);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }
        
        .ability::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(74, 222, 128, 0.3), transparent);
            transition: left 0.5s;
        }
        
        .ability:hover:not(.disabled)::before {
            left: 100%;
        }
        
        .ability:hover:not(.disabled) {
            border-color: rgba(74, 222, 128, 1);
            box-shadow: 0 0 30px rgba(74, 222, 128, 0.6), 0 4px 15px rgba(0, 0, 0, 0.3);
            transform: scale(1.05);
        }
        
        .ability:active:not(.disabled) {
            transform: scale(1.02);
        }
        
        .ability.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: rgba(100, 100, 100, 0.5);
        }
        
        .ability-icon {
            font-size: 16px;
            margin-bottom: 5px;
            font-weight: bold;
            color: #4ade80;
        }

        /* Enemy HP UI (screen-space DOM) */
        #enemyHpLayer { position: absolute; left: 0; top: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        .enemy-hp { position: absolute; transform: translate(-50%, -100%); pointer-events: none; font-family: inherit; }
        .enemy-hp .bar-bg { width: 100%; height: 12px; background: rgba(0,0,0,0.6); border-radius: 8px; border: 1px solid rgba(255,255,255,0.06); overflow: hidden; }
        .enemy-hp .bar-fg { height: 100%; width: 100%; background: linear-gradient(90deg,#4ade80,#22c55e); transform-origin: left center; transition: width 120ms linear; }
        /* Ally HP UI (screen-space DOM) */
        #allyHpLayer { position: absolute; left: 0; top: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        .ally-hp { position: absolute; transform: translate(-50%, -100%); pointer-events: none; font-family: inherit; }
        .ally-hp .bar-bg { width: 100%; height: 10px; background: rgba(0,0,0,0.6); border-radius: 6px; border: 1px solid rgba(59,130,246,0.3); overflow: hidden; }
        .ally-hp .bar-fg { height: 100%; width: 100%; background: linear-gradient(90deg,#3b82f6,#2563eb); transform-origin: left center; transition: width 120ms linear; }
        
        .ability-key {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            font-weight: bold;
        }
        
        .cooldown-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            transition: height 0.1s linear;
            height: 0;
        }
        
        .cooldown-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }
        
        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            border-radius: 12px;
            border: 2px solid rgba(74, 222, 128, 0.5);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
            font-size: 18px;
            font-weight: bold;
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            padding: 40px 60px;
            border-radius: 20px;
            border: 3px solid rgba(255, 59, 59, 0.8);
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            text-align: center;
            display: none;
            z-index: 100;
        }
        
        #gameOver h1 {
            margin: 0 0 20px 0;
            font-size: 48px;
            color: #ff3b3b;
        }
        
        #gameOver button {
            margin-top: 20px;
            padding: 12px 30px;
            font-size: 18px;
            background: rgba(74, 222, 128, 0.3);
            border: 2px solid rgba(74, 222, 128, 0.8);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        #gameOver button:hover {
            background: rgba(74, 222, 128, 0.5);
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.5);
        }
        
        #homeScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 300;
        }

        #homeScreen h1 {
            color: white;
            font-size: 72px;
            margin-bottom: 60px;
            text-shadow: 0 0 40px rgba(74, 222, 128, 0.8);
            font-weight: bold;
            letter-spacing: 8px;
        }

        /* Home / Play / Select shared pill button style */
        #playButton, #selectButton, #homeButton, #summonHomeButton, .home-action {
            padding: 18px 48px;
            font-size: 20px;
            font-weight: 800;
            border-radius: 16px;
            border: 0;
            color: white;
            cursor: pointer;
            transition: transform 0.16s ease, box-shadow 0.16s ease, filter 0.12s ease;
            box-shadow: 0 14px 34px -10px rgba(6,7,20,0.6), inset 0 -2px 8px rgba(255,255,255,0.03);
            backdrop-filter: blur(4px);
            text-shadow: 0 1px 6px rgba(0,0,0,0.25);
            min-width: 260px;
            text-align: center;
        }

        /* Play button green */
        #playButton {
            background: linear-gradient(90deg, #3fe1a4 0%, #2cc6f2 100%);
            color: #071122;
            padding: 22px 64px;
            font-size: 28px;
        }
        .home-action {
            background: linear-gradient(90deg, #eef2ff 0%, #e0f2fe 100%);
            color: #071122;
            padding: 18px 48px;
            font-weight: 800;
            box-shadow: 0 10px 30px rgba(0,0,0,0.25);
        }
        .home-action:hover { transform: translateY(-3px); }
        /* Make Summon button match the main Select button gradient for consistency */
        #summonHomeButton.home-action {
            background: linear-gradient(90deg, #60a5fa 0%, #7c3aed 100%);
            color: #081827 !important;
            text-shadow: none !important;
            border: 0;
        }
        #playButton:hover { transform: translateY(-4px); box-shadow: 0 22px 48px -18px rgba(44,211,238,0.25); }
        #playButton:focus { outline: 3px solid rgba(44,211,238,0.18); outline-offset: 3px; }

        #classSelection {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #181a2b 0%, #1a1a2e 60%, #2e1065 100%);
            backdrop-filter: blur(20px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* align to top so cards aren't clipped */
            padding-top: 40px;
            z-index: 200;
        }
        
        #classSelection h1 {
            color: #fff;
            font-size: 38px;
            margin-bottom: 20px;
            background: linear-gradient(90deg, #4ade80 0%, #22d3ee 40%, #a78bfa 80%, #f472b6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 24px #fff6, 0 0 8px #4ade80a0;
        }
        
        /* Thin scrollbars for page and containers */
        html, body, .class-container {
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: rgba(255,255,255,0.12) transparent;
        }

        /* WebKit browsers */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: transparent;
        }
        ::-webkit-scrollbar-thumb {
            background-color: rgba(255,255,255,0.08);
            border-radius: 8px;
            border: 2px solid transparent;
            background-clip: padding-box;
        }
        ::-webkit-scrollbar-thumb:hover {
            background-color: rgba(255,255,255,0.14);
        }

        .class-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            max-width: 96vw;
            height: calc(80vh - 120px); /* fixed height so cards can size to container */
            overflow-x: auto;
            overflow-y: hidden; /* no vertical scrolling on container */
            align-items: stretch; /* ensure all cards share the same height */
            padding: 12px 20px 20px 20px; /* bottom padding so card bottoms aren't clipped */
            -webkit-overflow-scrolling: touch;
            scroll-snap-type: x mandatory;
        }
        
        .class-card {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 16px;
            flex: 0 0 380px; /* slightly narrower cards to fit without vertical overflow */
            width: 380px;
            min-width: 320px;
            height: 100%; /* stretch to container height so bottoms are visible */
            min-height: 320px;
            scroll-snap-align: start;
            padding: 14px; /* reduce padding so card content fits vertically */
            position: relative;
            background: linear-gradient(120deg, #232946 0%, #2e1065 100%);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            color: white;
            cursor: pointer;
            transition: box-shadow 0.3s, border-color 0.3s, transform 0.18s cubic-bezier(.4,1.3,.6,1);
            box-shadow: 0 0 24px #4ade8033, 0 2px 16px #0008;
            overflow: hidden;
            background-clip: padding-box;
            isolation: isolate;
            border: 2px solid #a78bfa;
            z-index: 0;
        }

        /* Make right column scroll internally if content overflows the fixed card height */
        .card-right {
            overflow-y: auto;
            padding-right: 6px; /* room for scrollbar */
        }

        /* Small custom scrollbar for card internals */
        .card-right::-webkit-scrollbar { width: 8px; }
        .card-right::-webkit-scrollbar-track { background: transparent; }
        .card-right::-webkit-scrollbar-thumb { background: rgba(167,139,250,0.14); border-radius: 6px; }
        .class-card::before {
            content: none;
        }
        .class-card:hover {
            /* keep visual emphasis without scaling */
            box-shadow: 0 0 32px #a78bfa88, 0 6px 30px rgba(0,0,0,0.45);
            border-color: #f472b6;
            z-index: 1;
        }
        
        .class-card h2 {
            font-size: 24px;
            margin: 0 0 10px 0;
            text-align: center;
        }
        
        /* hide the large duplicate name badge inside cards; keep `.class-icon` available globally */
        .class-card .class-icon {
            display: none;
        }
        
        .class-card p {
            font-size: 12px;
            margin: 10px 0;
        }
        
        .class-card .ability-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
        }
        .class-card .ability-list li {
            white-space: normal;
            overflow-wrap: anywhere;
            max-width: 100%;
            box-sizing: border-box;
        }

        /* internal left/right columns inside each card */
        .card-left {
            flex: 0 0 140px;
            max-width: 140px;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
        }
        .card-right {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .card-left h2 { font-size: 18px; margin: 0; }
        /* keep any `.class-icon` hidden inside cards to avoid duplicate names */
        .card-left .class-icon { display:none; }
        
        .class-card .ability-list li {
            padding: 8px;
            background: linear-gradient(90deg, #22d3ee11 0%, #a78bfa22 100%);
            margin-bottom: 6px;
            border-radius: 6px;
            border-left: 3px solid #f472b6;
            font-size: 11px;
            word-wrap: break-word;
            overflow-wrap: break-word;
            line-height: 1.4;
        }
        
        .class-card .ability-list li strong {
            color: #f472b6;
            text-shadow: 0 0 6px #fff6;
        }
        
        .class-exp-container {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(74, 222, 128, 0.3);
        }
        
        .class-exp-bar {
            width: 100%;
            height: 20px;
            background: linear-gradient(90deg, #232946 0%, #2e1065 100%);
            border: 2px solid #a78bfa;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
            margin-top: 5px;
            box-shadow: 0 0 8px #a78bfa44;
        }
        
        .class-exp-fill {
            height: 100%;
            background: linear-gradient(90deg, #f472b6 0%, #a78bfa 50%, #22d3ee 100%);
            transition: width 0.3s ease;
            box-shadow: 0 0 10px #a78bfa99;
        }
        
        .class-exp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }
        
        .class-level {
            font-size: 15px;
            color: #a78bfa;
            font-weight: bold;
            text-align: center;
            text-shadow: 0 0 8px #fff8;
        }
        
        #progressionWindow {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 600px;
            max-height: 80vh;
            background: rgba(0, 0, 0, 0.95);
            backdrop-filter: blur(20px);
            border: 3px solid rgba(74, 222, 128, 0.8);
            border-radius: 20px;
            padding: 30px;
            z-index: 300;
            display: none;
            box-shadow: 0 0 50px rgba(74, 222, 128, 0.5);
        }
        
        #progressionContent {
            max-height: calc(80vh - 120px);
            overflow-y: auto;
            padding-right: 10px;
        }
        
        .progression-header {
            color: #4ade80;
            font-size: 28px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(74, 222, 128, 0.5);
        }
        
        .upgrade-tier {
            background: rgba(74, 222, 128, 0.1);
            border: 2px solid rgba(74, 222, 128, 0.3);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }
        
        .upgrade-tier.unlocked {
            border-color: rgba(74, 222, 128, 0.8);
            background: rgba(74, 222, 128, 0.2);
            box-shadow: 0 0 20px rgba(74, 222, 128, 0.3);
        }
        
        .upgrade-tier.locked {
            opacity: 0.5;
        }
        
        .upgrade-tier h3 {
            color: #4ade80;
            margin: 0 0 10px 0;
            font-size: 18px;
        }
        
        .upgrade-tier p {
            color: rgba(255, 255, 255, 0.9);
            margin: 5px 0;
            font-size: 14px;
        }
        
        .close-progression {
            position: absolute;
            top: 15px;
            right: 20px;
            background: rgba(255, 59, 59, 0.3);
            border: 2px solid rgba(255, 59, 59, 0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }
        
        .close-progression:hover {
            background: rgba(255, 59, 59, 0.5);
            box-shadow: 0 0 15px rgba(255, 59, 59, 0.5);
        }
        
        .class-card-btn-row {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }
        /* Modern pill-style buttons */
        .view-progression-btn, .buy-exp-btn {
            width: 50%;
            padding: 12px 18px;
            font-size: 16px;
            font-weight: 800;
            border-radius: 14px;
            border: 0;
            box-sizing: border-box;
            cursor: pointer;
            text-align: center;
            transition: transform 0.16s ease, box-shadow 0.16s ease, opacity 0.12s ease;
            min-width: 0;
            line-height: 1.1;
            display: inline-block;
            letter-spacing: 0.6px;
            box-shadow: 0 8px 20px -8px rgba(10,10,14,0.6), inset 0 -2px 6px rgba(255,255,255,0.03);
            backdrop-filter: blur(4px);
        }
        .view-progression-btn {
            background: linear-gradient(90deg, #3fe1a4 0%, #2cc6f2 100%);
            color: #071122;
        }
        .view-progression-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 18px 40px -16px rgba(44,211,238,0.25), inset 0 -2px 8px rgba(255,255,255,0.04);
            color: #fff;
        }
        .view-progression-btn:focus {
            outline: 3px solid rgba(44,211,238,0.22);
            outline-offset: 2px;
        }
        .buy-exp-btn {
            background: linear-gradient(90deg, #ffd47a 0%, #ff80c4 100%);
            color: #201525;
        }
        .buy-exp-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 18px 40px -16px rgba(255,107,203,0.22), inset 0 -2px 8px rgba(255,255,255,0.04);
            color: #fff;
        }
        .buy-exp-btn:focus {
            outline: 3px solid rgba(255,107,203,0.18);
            outline-offset: 2px;
        }
        /* Global colorful polish */
        body {
            background: radial-gradient(circle at 10% 10%, #0f172a 0%, #081827 25%, #071122 60%, #020617 100%);
            color: #eef2ff;
        }

        /* Class cards colorful style */
        .class-card.wide-card {
            min-width: 340px;
            max-width: 520px;
        }
        .class-card.skinny-card {
            min-width: 120px;
            max-width: 220px;
        }

        .class-card:hover {
            /* subtle glow only; no scale to avoid size change */
            border-color: rgba(74, 222, 128, 0.9);
            box-shadow: 0 14px 48px rgba(74,222,128,0.08), 0 8px 24px rgba(0,0,0,0.45);
        }

        /* Locked class styling: default full-overlay for fully locked cards */
        .class-card.locked {
            opacity: 0.45;
            filter: grayscale(0.8);
            pointer-events: auto; /* allow interaction for shard unlock UI */
            position: relative;
        }
        /* Uniform small badge for locked cards (top-right) */
        .class-card.locked::after {
            content: 'LOCKED';
            position: absolute;
            top: 12px;
            right: 12px;
            transform: none;
            font-size: 13px;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 0 8px rgba(0,0,0,0.7);
            background: rgba(0,0,0,0.45);
            padding: 6px 8px;
            border-radius: 8px;
            z-index: 12;
        }
        /* Buttons and exp container remain visible on locked cards so shard UI can be used */
        /* If a locked card is the next one unlockable, show its buttons but keep a locked overlay */
        .class-card.locked.unlockable {
            opacity: 0.65;
            filter: grayscale(0.6);
            pointer-events: auto;
        }
        .class-card.locked.unlockable .class-card-btn-row { display: block; }
        /* Always hide right-side exp container for locked/unlockable cards */
        .class-card.locked .class-exp-container,
        .class-card.locked.unlockable .class-exp-container { display: none !important; }

        /* Layout tweaks for unlockable cards: stack buttons vertically and make them full-width */
        .class-card.unlockable .class-card-btn-row { display:flex; flex-direction: column; gap:12px; align-items: stretch; }
        .class-card.unlockable .view-progression-btn,
        .class-card.unlockable .buy-exp-btn { width: 100%; }

        /* Inline unlock button for a locked card (prominent, inline at bottom of card) */
        .unlock-class-btn {
            background: linear-gradient(90deg, #ffd47a 0%, #ff80c4 100%);
            color: #201525;
            border-radius: 12px;
            padding: 12px 14px;
            font-weight: 800;
            cursor: pointer;
            border: 0;
            width: 100%;
            box-shadow: 0 8px 24px rgba(0,0,0,0.45);
            pointer-events: auto; /* allow clicking while card is otherwise disabled */
            text-align: center;
        }
        .unlock-class-btn.disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(0.05); }

        /* Shard progress shown on locked class cards */
        .card-shard-progress { width: 100%; display:block; font-family: inherit; }
        .card-shard-progress > div:first-child { display:flex; justify-content:space-between; align-items:center; margin-bottom:6px; }
        .card-shard-progress .bar-bg { height:8px; background:rgba(255,255,255,0.08); border-radius:6px; overflow:hidden; }
        .card-shard-progress .bar-fg { height:100%; width:0%; background:linear-gradient(90deg,#a78bfa,#7c3aed); transition: width 0.25s ease; }

        /* Previously the right column was hidden for locked/unlockable cards; keep layout intact so shard progress displays */
        .class-card.locked .card-left,
        .class-card.locked.unlockable .card-left {
            flex: 1 1 100% !important;
            max-width: none !important;
            align-items: flex-start;
            padding-right: 18px;
        }

        /* Center primary title and make left content use full width when right hidden */
        .class-card.locked .card-left h2,
        .class-card.locked.unlockable .card-left h2 { text-align: left; }
        /* Buy next class button */
        #buyNextClassBtn {
            margin-top: 18px;
            padding: 16px 32px;
            font-size: 18px;
            font-weight: 800;
            border-radius: 14px;
            border: 0;
            background: linear-gradient(90deg, #ffd47a 0%, #ff80c4 100%);
            color: #071122;
            cursor: pointer;
            box-shadow: 0 8px 24px -8px rgba(255,128,196,0.4);
            transition: transform 0.16s ease, box-shadow 0.16s ease;
        }
        #buyNextClassBtn:hover {
            transform: translateY(-3px);
            box-shadow: 0 14px 36px -10px rgba(255,128,196,0.5);
        }
        #buyNextClassBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .class-icon {
            font-weight: bold;
            background: linear-gradient(90deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
            padding: 8px 10px;
            border-radius: 8px;
            display: inline-block;
            margin-bottom: 8px;
            color: #fff;
            box-shadow: inset 0 -6px 16px rgba(0,0,0,0.25);
        }

        /* Home screen visuals */
        #homeScreen {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 18px;
            height: 100vh;
            background: linear-gradient(180deg, rgba(19,21,45,0.85), rgba(6,7,20,0.95));
            color: #fff;
            z-index: 1000;
        }

        #playButton {
            padding: 18px 32px;
            font-size: 20px;
            font-weight: 800;
            color: #081827;
            background: linear-gradient(90deg, #7c3aed 0%, #22d3ee 100%);
            border: none;
            border-radius: 14px;
            cursor: pointer;
            box-shadow: 0 12px 36px rgba(124,58,237,0.18), 0 6px 18px rgba(34,211,238,0.08);
            transition: transform 0.12s ease, box-shadow 0.12s ease;
        }

        #playButton:hover {
            transform: scale(1.03);
            box-shadow: 0 18px 48px rgba(124,58,237,0.22), 0 8px 28px rgba(34,211,238,0.12);
            filter: brightness(1.05) saturate(1.05);
        }

        /* Select button purple/blue */
        #selectButton {
            background: linear-gradient(90deg, #60a5fa 0%, #7c3aed 100%);
            color: #081827;
        }
        #selectButton:hover { transform: translateY(-3px); box-shadow: 0 18px 40px -12px rgba(96,165,250,0.22); }
        #selectButton:focus { outline: 3px solid rgba(96,165,250,0.12); outline-offset: 3px; }

        /* HUD Home button (accent) */
        #homeButton {
            display: none; /* Hidden on the home screen by default */
            position: absolute;
            top: 18px;
            right: 18px; /* restored to top-right */
            left: auto;
            z-index: 1200;
            padding: 10px 14px; /* reduced padding to make button less wide */
            background: linear-gradient(90deg, #ff7b7b 0%, #ffb86b 100%);
            color: #071122;
            border-radius: 10px;
            font-weight: 700;
            min-width: unset !important; /* override global min-width so button isn't excessively wide */
        }
        #homeButton:hover { transform: translateY(-2px); box-shadow: 0 14px 36px -12px rgba(255,107,107,0.22); }
        #homeButton:focus { outline: 3px solid rgba(255,107,107,0.12); outline-offset: 2px; }

        /* Abilities color variants */
        .ability .ability-icon { color: #e6fffa; }
        #ability1 { border-image-slice: 1; border-image-source: linear-gradient(90deg,#f43f5e,#fb7185); }
        #ability2 { border-image-slice: 1; border-image-source: linear-gradient(90deg,#60a5fa,#7c3aed); }
        #ability3 { border-image-slice: 1; border-image-source: linear-gradient(90deg,#34d399,#06b6d4); }

        /* Game over style */
        #gameOver { 
            display: none; 
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
            background: linear-gradient(135deg, rgba(12,12,32,0.95), rgba(4,4,10,0.95));
            padding: 28px; border-radius: 14px; border: 2px solid rgba(255,59,59,0.24); z-index: 1500; text-align:center;
            color: #fff;
        }
        #gameOver button { padding: 10px 18px; border-radius: 10px; background: linear-gradient(90deg,#f97316,#fb923c); border:none; font-weight:bold; cursor:pointer; }

        /* Progression window polish */
        #progressionWindow { background: linear-gradient(180deg, rgba(2,6,23,0.95), rgba(6,7,20,0.95)); border: 2px solid rgba(124,58,237,0.12); box-shadow: 0 10px 30px rgba(0,0,0,0.6); }

        /* Top-right widget container (coins / home) */
        #widgetContainer {
            position: fixed;
            top: 18px;
            right: 18px;
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 2200;
            pointer-events: auto;
        }

        /* Generic widget styling */
        .widget {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 14px;
            border-radius: 14px;
            min-width: 64px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.45);
            font-weight: 800;
            color: #071122;
        }

        .widget-coins {
            background: rgba(255,255,255,0.03);
            color: #ddd;
            flex-direction: column;
            align-items: flex-start;
            padding: 8px 12px;
            box-shadow: 0 6px 18px rgba(0,0,0,0.35);
        }

        .widget-coins .coin-main {
            font-size: 16px;
            line-height: 1;
            color: #e6e6e6;
            text-shadow: none;
        }
        .widget-coins .coin-label {
            font-size: 12px;
            color: rgba(255,255,255,0.75);
            opacity: 0.9;
            margin-top: 2px;
        }

        .widget-home {
            background: linear-gradient(90deg, #ff7b7b 0%, #ffb86b 100%);
            color: #071122;
            padding: 8px 10px;
            font-size: 14px;
            border-radius: 12px;
            min-width: 0;
        }

        /* Ensure existing absolute styles don't conflict once moved into container */
        #coinDisplay, #homeButton { position: static !important; right: auto !important; left: auto !important; top: auto !important; }
        
        /* Auth Screen Styles */
        #authScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 99998;
        }
        #authScreen.hidden { display: none; }
        #authScreen h1 {
            color: #4ade80;
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(74, 222, 128, 0.5);
            letter-spacing: 8px;
        }
        .auth-container {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(74, 222, 128, 0.3);
            border-radius: 15px;
            padding: 2rem;
            width: 350px;
            max-width: 90%;
        }
        .auth-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 1.5rem;
        }
        .auth-tab {
            flex: 1;
            padding: 0.75rem;
            background: rgba(255,255,255,0.1);
            border: none;
            border-radius: 8px;
            color: #aaa;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s;
        }
        .auth-tab.active {
            background: linear-gradient(135deg, #4ade80 0%, #22d3ee 100%);
            color: #1a1a2e;
            font-weight: bold;
        }
        .auth-form { display: none; }
        .auth-form.active { display: block; }
        .auth-input {
            width: 100%;
            padding: 0.875rem;
            margin-bottom: 1rem;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(74, 222, 128, 0.3);
            border-radius: 10px;
            color: white;
            font-size: 16px;
        }
        .auth-input:focus {
            outline: none;
            border-color: #4ade80;
        }
        .auth-btn {
            width: 100%;
            padding: 1rem;
            background: linear-gradient(135deg, #4ade80 0%, #22d3ee 100%);
            border: none;
            border-radius: 10px;
            color: #1a1a2e;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .auth-btn:hover { transform: scale(1.02); }
        .auth-btn:disabled { opacity: 0.7; cursor: not-allowed; }
        .auth-error {
            background: rgba(239, 68, 68, 0.2);
            color: #f87171;
            padding: 0.75rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            text-align: center;
            display: none;
        }
        .auth-error.visible { display: block; }
        .auth-user-info {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.5);
            padding: 8px 15px;
            border-radius: 20px;
            color: #4ade80;
            font-size: 14px;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .auth-user-info.hidden { display: none; }
        .auth-logout-btn {
            background: rgba(239, 68, 68, 0.3);
            border: none;
            color: #f87171;
            padding: 4px 10px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 12px;
        }
        .auth-logout-btn:hover { background: rgba(239, 68, 68, 0.5); }
        .play-guest-btn {
            width: 100%;
            margin-top: 1rem;
            padding: 0.75rem;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            color: #aaa;
            cursor: pointer;
            font-size: 0.9rem;
        }
        .play-guest-btn:hover { background: rgba(255,255,255,0.15); }
        
        /* Server Wake-up Screen */
        #serverWakeScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 999999;
        }
        #serverWakeScreen.hidden { display: none; }
        #serverWakeScreen h1 {
            color: #4ade80;
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 0 0 20px rgba(74, 222, 128, 0.5);
            letter-spacing: 8px;
        }
        .wake-status {
            color: rgba(255,255,255,0.8);
            font-size: 18px;
            margin-bottom: 20px;
        }
        .wake-progress {
            width: 300px;
            height: 6px;
            background: rgba(255,255,255,0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 15px;
        }
        .wake-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #4ade80, #22d3ee);
            border-radius: 3px;
            width: 0%;
            transition: width 0.3s ease;
        }
        .wake-tip {
            color: rgba(255,255,255,0.5);
            font-size: 14px;
            text-align: center;
            max-width: 350px;
        }
        .wake-retry-btn {
            margin-top: 20px;
            padding: 12px 30px;
            background: linear-gradient(135deg, #4ade80 0%, #22d3ee 100%);
            border: none;
            border-radius: 25px;
            color: #1a1a2e;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            display: none;
        }
        .wake-retry-btn:hover { transform: scale(1.05); }
        /* Logout button - always visible top-center */
        #logoutBtn {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100000;
            background: rgba(255,255,255,0.06);
            color: #fff;
            border: 1px solid rgba(255,255,255,0.08);
            padding: 6px 12px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            backdrop-filter: blur(6px);
        }
        #logoutBtn:hover { opacity: 0.95; }
    </style>
</head>
<body>
    <button id="logoutBtn" style="display:none;">Logout</button>
    <!-- Server Wake-up Screen -->
    <div id="serverWakeScreen">
        <h1>TBD</h1>
        <div class="wake-status" id="wakeStatus">Connecting to server...</div>
        <div class="wake-progress">
            <div class="wake-progress-bar" id="wakeProgressBar"></div>
        </div>
        <div class="wake-tip" id="wakeTip">Free servers sleep after inactivity. Waking up usually takes 10-30 seconds.</div>
        <button class="wake-retry-btn" id="wakeRetryBtn" onclick="startServerWake()">Retry Connection</button>
        <button class="wake-retry-btn" id="offlineVersionBtn" onclick="downloadOfflineVersion()" style="background:linear-gradient(90deg,#6366f1,#8b5cf6); margin-top:10px;">ðŸ“¥ Download Offline Version</button>
    </div>

    <!-- Auth Screen -->
    <div id="authScreen">
        <h1>TBD</h1>
        <div class="auth-container">
            <div class="auth-tabs">
                <button class="auth-tab active" onclick="showAuthTab('login')">Login</button>
                <button class="auth-tab" onclick="showAuthTab('register')">Register</button>
            </div>
            <div id="authError" class="auth-error"></div>
            
            <!-- Login Form -->
            <div id="loginForm" class="auth-form active">
                <input type="text" class="auth-input" id="loginUsername" placeholder="Username">
                <input type="password" class="auth-input" id="loginPassword" placeholder="Password">
                <button class="auth-btn" onclick="doLogin()">Login</button>
            </div>
            
            <!-- Register Form -->
            <div id="registerForm" class="auth-form">
                <input type="text" class="auth-input" id="regUsername" placeholder="Username">
                <input type="text" class="auth-input" id="regDisplayName" placeholder="Display Name">
                <input type="email" class="auth-input" id="regEmail" placeholder="Email">
                <input type="password" class="auth-input" id="regPassword" placeholder="Password">
                <button class="auth-btn" onclick="doRegister()">Register</button>
            </div>
            
            <button class="play-guest-btn" onclick="playAsGuest()">Play as Guest (no save)</button>
        </div>
    </div>

    <!-- User Info Display -->
    <div id="userInfo" class="auth-user-info hidden">
        <span id="userDisplayName">Player</span>
        <button class="auth-logout-btn" onclick="doLogout()">Logout</button>
    </div>

    <!-- Loading Screen -->
    <div id="loadingScreen">
        <h1>TBD</h1>
        <div id="loadingBarContainer">
            <div id="loadingBar"></div>
        </div>
        <div id="loadingText">Loading...</div>
    </div>
    
    <div id="homeScreen">
        <h1>TBD</h1>
        <!-- Home buttons: Select Class, Play, Summon, Events -->
        <div class="home-buttons" style="display:flex; flex-direction:column; gap:10px; align-items:center; max-width:280px; margin:0 auto;">
            <button id="playButton" onclick="startGame()">PLAY</button>
            <button id="selectButton" onclick="showClassSelection()">Select Class</button>
            <div style="display:flex; gap:10px; width:100%;">
                <button id="summonHomeButton" class="home-action" onclick="showSummonScreen()" style="flex:1;">Summon</button>
                <button id="eventsHomeButton" class="home-action" onclick="showEventsScreen()" style="flex:1; background:linear-gradient(90deg,#f59e0b,#ef4444); color:#fff;"><span id="eventsFireIcon"></span> Events</button>
            </div>
        </div>
    </div>
    <div id="classSelection">
        <h1>SELECT YOUR CLASS</h1>
        <div class="class-container">
            <div class="class-card" onclick="selectClass('electric')">
                <div class="class-icon">ELECTRIC</div>
                <h2>Electric</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">Master of lightning and chain attacks</p>
                <ul class="ability-list">
                    <li><strong>Q - Zap:</strong> Chain lightning that bounces to 3 enemies</li>
                    <li><strong>E - Lightning Strike:</strong> Strikes 3 random enemies instantly</li>
                    <li><strong>R - Super Zap:</strong> Long range lightning with unlimited bounces</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="electric-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="electric-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="electric-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('electric')">View Upgrades</button>
                        <button class="buy-exp-btn" onclick="event.stopPropagation(); buyExp('electric')">Buy EXP</button>
                    </div>
                </div>
            </div>
            <div class="class-card" onclick="selectClass('fire')">
                <div class="class-icon">FIRE</div>
                <h2>Fire</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">Pyromancer with DoT and healing mechanics</p>
                <ul class="ability-list">
                    <li><strong>Q - Singe:</strong> Burn nearby enemies with DoT (instant damage if already burned)</li>
                    <li><strong>E - Healing Fire:</strong> Heal 1 HP per burned enemy, then damage them</li>
                    <li><strong>R - Fireballs:</strong> Launch 3 giant fireballs that burn and damage</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="fire-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="fire-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="fire-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('fire')">View Upgrades</button>
                        <button class="buy-exp-btn" onclick="event.stopPropagation(); buyExp('fire')">Buy EXP</button>
                    </div>
                </div>
            </div>
            <div class="class-card" onclick="selectClass('pierce')">
                <div class="class-icon">PIERCE</div>
                <h2>Pierce</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">Master of piercing projectiles</p>
                <ul class="ability-list">
                    <li><strong>Q - Pierce Shot:</strong> Arrow that pierces through 5 enemies</li>
                    <li><strong>E - Multi Shot:</strong> Fire 5 auto-aimed arrows</li>
                    <li><strong>R - Arrow Storm:</strong> Rain piercing arrows on all enemies</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="pierce-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="pierce-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="pierce-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('pierce')">View Upgrades</button>
                        <button class="buy-exp-btn" onclick="event.stopPropagation(); buyExp('pierce')">Buy EXP</button>
                    </div>
                </div>
            </div>
            <div class="class-card" onclick="selectClass('engineer')">
                <div class="class-icon">ENGINEER</div>
                <h2>Engineer</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">Turret builder with machine gun</p>
                <ul class="ability-list">
                    <li><strong>Q - Deploy Turret:</strong> Place a turret that shoots enemies</li>
                    <li><strong>E - Heal Turret:</strong> Heal and upgrade nearest turret</li>
                    <li><strong>R - Machine Gun:</strong> Pull out machine gun (200 ammo)</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="engineer-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="engineer-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="engineer-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('engineer')">View Upgrades</button>
                        <button class="buy-exp-btn" onclick="event.stopPropagation(); buyExp('engineer')">Buy EXP</button>
                    </div>
                </div>
            </div>
            <div class="class-card" onclick="selectClass('life')">
                <div class="class-icon">LIFE</div>
                <h2>Life</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">High risk lifesteal warrior</p>
                <ul class="ability-list">
                    <li><strong>Q - Kill:</strong> 100 dmg, on kill: gain target's HP, teleport + AoE</li>
                    <li><strong>E - Life Burst:</strong> AoE damage with lifesteal</li>
                    <li><strong>R - Blood Frenzy:</strong> Rapid attacks with lifesteal</li>
                    <li><strong>Passive:</strong> Lose 5 HP every second</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="life-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="life-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="life-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('life')">View Upgrades</button>
                        <button class="buy-exp-btn" onclick="event.stopPropagation(); buyExp('life')">Buy EXP</button>
                    </div>
                </div>
            </div>
            <div class="class-card" onclick="selectClass('summoner')">
                <div class="class-icon">SUMMON</div>
                <h2>Summoner</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">Command minions and guardian to fight for you</p>
                <ul class="ability-list">
                    <li><strong>Q - Attack Command (CMD):</strong> All allies attack the nearest enemies to the player, dealing 30 dmg (75 for guardian)</li>
                    <li><strong>E - Summon Squad+:</strong> Summon 4 minions (22s duration, 60 HP, faster attacks)</li>
                    <li><strong>R - Summon Guardian+:</strong> Summon 1 powerful guardian (35s duration, 150 HP, very fast attacks)</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="summoner-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="summoner-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="summoner-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('summoner')">View Upgrades</button>
                        <button class="buy-exp-btn" onclick="event.stopPropagation(); buyExp('summoner')">Buy EXP</button>
                    </div>
                </div>
            </div>
            <div class="class-card" onclick="selectClass('water')">
                <div class="class-icon">WATER</div>
                <h2>Water</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">Master of knockback and control</p>
                <ul class="ability-list">
                    <li><strong>Q - Water Blast:</strong> Knockback enemies in front</li>
                    <li><strong>E - Tidal Wave:</strong> Push all enemies away</li>
                    <li><strong>R - Whirlpool:</strong> Pull enemies in then launch away</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="water-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="water-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="water-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('water')">View Upgrades</button>
                        <button class="buy-exp-btn" onclick="event.stopPropagation(); buyExp('water')">Buy EXP</button>
                    </div>
                </div>
            </div>
            <div class="class-card" onclick="selectClass('miner')">
                <div class="class-icon">MINER</div>
                <h2>Miner</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">Digs, buries mines, and passively throws shovels/drills</p>
                <ul class="ability-list">
                    <li><strong>Q - Dig:</strong> Burrow and teleport to mouse position</li>
                    <li><strong>E - Drill:</strong> Upgrade shovel to a powerful drill for a short time</li>
                    <li><strong>R - Mine:</strong> Bury a mine at mouse position that explodes when enemies step on it</li>
                    <li><strong>Passive:</strong> Automatically throws shovels and drills that home in on the nearest enemy</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="miner-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="miner-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="miner-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('miner')">View Upgrades</button>
                        <button class="buy-exp-btn" onclick="event.stopPropagation(); buyExp('miner')">Buy EXP</button>
                    </div>
                </div>
            </div>
            <div class="class-card" onclick="selectClass('thief')">
                <div class="class-icon">THIEF</div>
                <h2>Thief</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">Swift assassin with stealth and daggers</p>
                <ul class="ability-list">
                    <li><strong>Q - Throw Daggers:</strong> Launch damaging daggers</li>
                    <li><strong>E - Vanish:</strong> Become invisible briefly</li>
                    <li><strong>R - Shadow Strike:</strong> Dash to farthest enemy, execute, leave bomb</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="thief-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="thief-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="thief-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('thief')">View Upgrades</button>
                        <button class="buy-exp-btn" onclick="event.stopPropagation(); buyExp('thief')">Buy EXP</button>
                    </div>
                </div>
            </div>
            <div class="class-card" onclick="selectClass('trapper')">
                <div class="class-icon">TRAP</div>
                <h2>Trapper</h2>
                <p style="text-align: center; color: rgba(255, 255, 255, 0.7);">Strategic bomber with traps and barriers</p>
                <ul class="ability-list">
                    <li><strong>Q - Place Bomb:</strong> Drop explosives around the map</li>
                    <li><strong>E - Spike Barrier:</strong> Create barriers that slow and damage</li>
                    <li><strong>R - C4 Detonation:</strong> Massive remote explosion</li>
                </ul>
                <div class="class-exp-container">
                    <div class="class-level" id="trapper-level">Level 1</div>
                    <div class="class-exp-bar">
                        <div class="class-exp-fill" id="trapper-exp-fill" style="width: 0%;"></div>
                        <div class="class-exp-text" id="trapper-exp-text">0 / 100</div>
                    </div>
                    <div class="class-card-btn-row">
                        <button class="view-progression-btn" onclick="event.stopPropagation(); viewProgression('trapper')">View Upgrades</button>
                        <button class="buy-exp-btn" onclick="event.stopPropagation(); buyExp('trapper')">Buy EXP</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="hud" style="display:none;">
        <div><strong>HP:</strong></div>
        <div class="hp-bar-container">
            <div class="hp-bar" id="hpBar" style="width: 100%;"></div>
            <div class="hp-text" id="hpText">100 / 100</div>
        </div>
        <div style="margin-top: 10px; font-size: 12px;">
            <strong>Wave:</strong> <span id="waveCount">1</span>
        </div>
        <div style="margin-top: 10px;">
            <strong style="font-size: 12px;">Wave Progress:</strong>
            <div class="hp-bar-container" style="margin-top: 5px;">
                <div class="hp-bar" id="waveProgress" style="width: 0%; background: linear-gradient(90deg, #4ade80 0%, #22c55e 100%);"></div>
                <div class="hp-text" id="waveProgressText">0 / 10</div>
            </div>
        </div>
        <div id="ammoCounter" style="margin-top: 10px; font-size: 12px; display: none;">
            <strong>Ammo:</strong> <span id="ammoCount">200</span> / 200
        </div>
    </div>
    <div id="coinDisplay" style="position: absolute; top: 18px; right: 18px; left: auto; font-size: 16px; color: #ddd; font-weight: normal; z-index: 80; display:flex; align-items:center; gap:8px;">
        <span id="coinIcon" style="font-size:18px; opacity:0.8;"></span>
        <span id="coinAmount">0</span>
        <span style="font-size:13px; color:#ccc; opacity:0.9; margin-left:4px;">Coins</span>
    </div>
    <button id="homeButton" onclick="restartGame()">Home</button>
    <script>
        // Swap positions: keep Home at far-right and move Coins to its left.
        function positionHomeAndCoins() {
            try {
                const coin = document.getElementById('coinDisplay');
                const home = document.getElementById('homeButton');
                if (!coin || !home) return;
                const gap = 12; // px between home button and coin display
                // place home at right:18px
                home.style.right = '18px';
                home.style.left = 'auto';
                // measure home width after ensuring it's laid out
                const homeW = Math.ceil(home.getBoundingClientRect().width) || 0;
                // place coin to the left of home (home is at right:18px)
                coin.style.right = (18 + homeW + gap) + 'px';
                coin.style.left = 'auto';
            } catch (e) { /* ignore */ }
        }
        window.addEventListener('DOMContentLoaded', positionHomeAndCoins);
        window.addEventListener('resize', positionHomeAndCoins);
        setTimeout(positionHomeAndCoins, 300);
    </script>
    <script>
        // Create a compact widget container and move HUD elements into it
        (function setupWidgets() {
            function createContainerAndMove() {
                if (document.getElementById('widgetContainer')) return;
                const container = document.createElement('div');
                container.id = 'widgetContainer';
                document.body.appendChild(container);

                const coin = document.getElementById('coinDisplay');
                const home = document.getElementById('homeButton');

                if (coin) {
                    // Tidy up inline positioning added earlier and add widget class
                    coin.style.position = 'static';
                    coin.style.right = '';
                    coin.style.left = '';
                    coin.style.top = '';
                    coin.classList.add('widget', 'widget-coins');

                    // Wrap coin amount in a small structure for nicer display
                    const amount = document.getElementById('coinAmount');
                    if (amount) {
                        amount.classList.add('coin-main');
                    }
                    // keep the existing 'Coins' label but style it
                    const label = coin.querySelector('span[style]');
                    if (label) label.classList.add('coin-label');

                    container.appendChild(coin);
                }

                if (home) {
                    home.style.position = 'static';
                    home.style.right = '';
                    home.style.left = '';
                    home.style.top = '';
                    home.classList.add('widget', 'widget-home');
                    container.appendChild(home);
                }
            }

            if (document.readyState === 'loading') {
                window.addEventListener('DOMContentLoaded', () => setTimeout(createContainerAndMove, 40));
            } else {
                setTimeout(createContainerAndMove, 40);
            }

            // In case the old position script runs later, force the container layout after resize
            window.addEventListener('resize', () => setTimeout(() => {
                const container = document.getElementById('widgetContainer');
                if (!container) createContainerAndMove();
            }, 60));
        })();
    </script>
    
    <div id="abilities" style="display:none;">
        <div class="ability" id="ability1" data-key="1">
            <div class="ability-icon">Q</div>
            <div class="ability-key">Q</div>
            <div class="cooldown-overlay"></div>
            <div class="cooldown-text"></div>
        </div>
        <div class="ability" id="ability2" data-key="2">
            <div class="ability-icon">E</div>
            <div class="ability-key">E</div>
            <div class="cooldown-overlay"></div>
            <div class="cooldown-text"></div>
        </div>
        <div class="ability" id="ability3" data-key="3">
            <div class="ability-icon">R</div>
            <div class="ability-key">R</div>
            <div class="cooldown-overlay"></div>
            <div class="cooldown-text"></div>
        </div>
    </div>
    
    <!-- Mobile controls: joystick + ability buttons (bottom-right, touch-first) -->
    <style>
        #mobileControls { position: fixed; right: 18px; bottom: 18px; z-index: 10001; display: flex; gap: 12px; align-items: center; pointer-events: none; }
        #mobileJoystick { width: 120px; height: 120px; border-radius: 999px; background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.06); position: relative; touch-action: none; pointer-events: auto; }
        #mobileStick { width: 56px; height: 56px; border-radius: 999px; background: linear-gradient(180deg, rgba(255,255,255,0.95), rgba(220,220,220,0.95)); position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); box-shadow: 0 6px 18px rgba(0,0,0,0.4); }
        #mobileAbilities { display: flex; flex-direction: column; gap: 10px; pointer-events: auto; }
        .mobile-ability-btn { width: clamp(64px, 18vw, 110px); height: clamp(64px, 18vw, 110px); border-radius: 12px; background: linear-gradient(90deg,#ff6b6b,#ff3b3b); display:flex; align-items:center; justify-content:center; color:#fff; font-weight:700; box-shadow: 0 8px 20px rgba(0,0,0,0.45); border: none; }
        .mobile-ability-btn.secondary { background: linear-gradient(90deg,#60a5fa,#7c3aed); }
        .mobile-ability-btn.tertiary { background: linear-gradient(90deg,#34d399,#06b6d4); }
        .mobile-ability-btn:active { transform: scale(0.97); }
        .mobile-ability-btn { position: relative; overflow: hidden; }
        .mobile-ability-label { position: absolute; inset: 0; display:flex; align-items:center; justify-content:center; z-index: 4; pointer-events: none; font-size: clamp(12px, 3.5vw, 18px); font-weight:800; color:#fff; text-shadow: 0 2px 6px rgba(0,0,0,0.6); white-space: normal; padding:6px; text-align:center; word-break: break-word; text-transform: none; }
        .mobile-cooldown-overlay { position: absolute; inset: 0; z-index: 2; transition: height 0.12s linear; }
        .mobile-cooldown-text { position: absolute; inset: 0; display:flex; align-items:center; justify-content:center; z-index: 5; font-weight:800; font-size:18px; pointer-events:none; color:#fff; }
        @media (min-width: 900px) { #mobileControls { display: none; } }
        @media (max-width: 900px) { #abilities { display: none !important; } }
    </style>

    <div id="mobileControls" aria-hidden="false" style="display:none;">
        <div id="mobileJoystick" aria-label="Movement joystick" role="application">
            <div id="mobileStick"></div>
        </div>
        <div id="mobileAbilities">
            <button class="mobile-ability-btn" id="mAbility1">
                <div class="mobile-ability-label">Q</div>
                <div class="mobile-cooldown-overlay" style="background:rgba(0,0,0,0.35); height:0%; border-radius:12px;"></div>
                <div class="mobile-cooldown-text"></div>
            </button>
            <button class="mobile-ability-btn secondary" id="mAbility2">
                <div class="mobile-ability-label">E</div>
                <div class="mobile-cooldown-overlay" style="background:rgba(0,0,0,0.35); height:0%; border-radius:12px;"></div>
                <div class="mobile-cooldown-text"></div>
            </button>
            <button class="mobile-ability-btn tertiary" id="mAbility3">
                <div class="mobile-ability-label">R</div>
                <div class="mobile-cooldown-overlay" style="background:rgba(0,0,0,0.35); height:0%; border-radius:12px;"></div>
                <div class="mobile-cooldown-text"></div>
            </button>
        </div>
    </div>

    <script>
    (function(){
        // Wait for required globals to exist
        function ready(cb) {
            if (typeof movementManager !== 'undefined' && typeof abilities !== 'undefined') return cb();
            setTimeout(() => ready(cb), 80);
        }

        ready(() => {
            const joy = document.getElementById('mobileJoystick');
            const stick = document.getElementById('mobileStick');
            const maxRadius = 40; // pixels
            let activeId = null;

            function setVisual(dx, dy) {
                stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            }

            function updateJoystickFromPoint(clientX, clientY) {
                const rect = joy.getBoundingClientRect();
                const cx = rect.left + rect.width / 2;
                const cy = rect.top + rect.height / 2;
                let dx = clientX - cx;
                let dy = clientY - cy;
                // clamp
                const dist = Math.sqrt(dx*dx + dy*dy);
                const clamped = Math.min(dist, maxRadius);
                if (dist > 0) {
                    dx = dx / dist * clamped;
                    dy = dy / dist * clamped;
                }
                setVisual(dx, dy);
                // convert to normalized -1..1 with up = positive y (invert client Y)
                const nx = dx / maxRadius;
                const ny = -dy / maxRadius;
                // Movement manager expects y up positive
                movementManager.setJoystick(nx, ny);
            }

            function resetJoystick() {
                setVisual(0,0);
                movementManager.clearJoystick();
                activeId = null;
            }

            // Touch handlers
            joy.addEventListener('touchstart', (ev) => {
                const t = ev.changedTouches[0];
                activeId = t.identifier;
                updateJoystickFromPoint(t.clientX, t.clientY);
                ev.preventDefault();
            }, { passive: false });
            joy.addEventListener('touchmove', (ev) => {
                for (const t of ev.changedTouches) {
                    if (t.identifier === activeId) {
                        updateJoystickFromPoint(t.clientX, t.clientY);
                        ev.preventDefault();
                        break;
                    }
                }
            }, { passive: false });
            joy.addEventListener('touchend', (ev) => {
                for (const t of ev.changedTouches) {
                    if (t.identifier === activeId) {
                        resetJoystick();
                        ev.preventDefault();
                        break;
                    }
                }
            }, { passive: false });

            // Mouse fallback for joystick (desktop testing)
            let mouseDown = false;
            joy.addEventListener('mousedown', (ev) => { mouseDown = true; updateJoystickFromPoint(ev.clientX, ev.clientY); ev.preventDefault(); });
            window.addEventListener('mousemove', (ev) => { if (mouseDown) { updateJoystickFromPoint(ev.clientX, ev.clientY); ev.preventDefault(); }});
            window.addEventListener('mouseup', (ev) => { if (mouseDown) { mouseDown = false; resetJoystick(); ev.preventDefault(); }});

            // Ability buttons
            const m1 = document.getElementById('mAbility1');
            const m2 = document.getElementById('mAbility2');
            const m3 = document.getElementById('mAbility3');

            function triggerAbilityIndex(idx, startHold = false, endHold = false) {
                if (gameState.isGameOver) return;
                if (idx === 1 && abilities.q) {
                    if (abilities.q.execute()) {
                        updateAbilityCooldown('ability1', abilities.q.cooldown);
                        const el = document.getElementById('ability1'); if (el) { el.style.transform = 'scale(0.9)'; setTimeout(()=>el.style.transform='scale(1)',100); }
                        try { const mb = document.getElementById('mAbility1'); if (mb) { mb.style.transform='scale(0.9)'; setTimeout(()=>mb.style.transform='scale(1)',100); } } catch(e){}
                    }
                } else if (idx === 2 && abilities.e) {
                    if (abilities.e.execute()) {
                        updateAbilityCooldown('ability2', abilities.e.cooldown);
                        const el = document.getElementById('ability2'); if (el) { el.style.transform = 'scale(0.9)'; setTimeout(()=>el.style.transform='scale(1)',100); }
                        try { const mb = document.getElementById('mAbility2'); if (mb) { mb.style.transform='scale(0.9)'; setTimeout(()=>mb.style.transform='scale(1)',100); } } catch(e){}
                    }
                } else if (idx === 3 && abilities.r) {
                    // Engineer uses hold mechanic
                    if (selectedClass && selectedClass.name === 'Engineer') {
                        if (startHold) {
                            keys.r = true;
                        } else if (endHold) {
                            keys.r = false;
                        }
                    } else {
                        const result = abilities.r.execute();
                        if (result === 'reload') {
                            updateAbilityCooldown('ability3', abilities.r.cooldown);
                        } else if (result || result === true) {
                            updateAbilityCooldown('ability3', abilities.r.cooldown);
                            const el = document.getElementById('ability3'); if (el) { el.style.transform = 'scale(0.9)'; setTimeout(()=>el.style.transform='scale(1)',100); }
                            try { const mb = document.getElementById('mAbility3'); if (mb) { mb.style.transform='scale(0.9)'; setTimeout(()=>mb.style.transform='scale(1)',100); } } catch(e){}
                        }
                    }
                }
            }

            // Touch / pointer handlers for ability buttons
            function attachAbilityHandlers(btn, idx) {
                btn.addEventListener('touchstart', (ev) => { triggerAbilityIndex(idx, true, false); ev.preventDefault(); }, { passive:false });
                btn.addEventListener('touchend', (ev) => { triggerAbilityIndex(idx, false, true); ev.preventDefault(); }, { passive:false });
                btn.addEventListener('mousedown', (ev) => { triggerAbilityIndex(idx, true, false); ev.preventDefault(); });
                btn.addEventListener('mouseup', (ev) => { triggerAbilityIndex(idx, false, true); ev.preventDefault(); });
                btn.addEventListener('click', (ev) => { triggerAbilityIndex(idx, false, false); ev.preventDefault(); });
            }

            attachAbilityHandlers(m1, 1);
            attachAbilityHandlers(m2, 2);
            attachAbilityHandlers(m3, 3);
        });
    })();
    </script>

    <div id="gameOver">
        <h1>DEFEATED</h1>
        <p id="finalScore" style="font-size: 24px;"></p>
        <p id="gameOverGains" style="color:#ddd; margin:6px 0 12px 0;"></p>
        <div style="display:flex; gap:10px; justify-content:center;">
            <button onclick="playAgain()" style="padding:8px 12px; border-radius:8px;">Play Again</button>
            <button onclick="restartGame()" style="padding:8px 12px; border-radius:8px;">Home</button>
        </div>
    </div>
    
    <div id="progressionWindow">
        <button class="close-progression" onclick="closeProgression()">X</button>
        <div class="progression-header" id="progressionTitle">Class Progression</div>
        <div id="progressionContent"></div>
    </div>

    <!-- Events Screen -->
    <div id="eventsScreen" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.92); z-index:9998; align-items:center; justify-content:center; padding:20px; box-sizing:border-box; overflow:auto;">
        <div style="width:800px; max-width:95vw; max-height:90vh; background:linear-gradient(180deg, rgba(20,10,5,0.98), rgba(40,15,10,0.98)); border-radius:16px; padding:24px; position:relative; box-shadow:0 20px 80px rgba(239,68,68,0.3); overflow:auto; border:2px solid rgba(239,68,68,0.4);">
            <button onclick="closeEventsScreen()" aria-label="Close events" style="position:absolute; right:14px; top:14px; background:#3b2020; border:0; padding:10px 14px; color:#fff; border-radius:10px; z-index:20; box-shadow:0 6px 18px rgba(0,0,0,0.6); cursor:pointer;"><span id="eventsCloseIcon"></span></button>
            <h2 style="margin:0 0 20px 0; color:#fff; font-size:28px; text-align:center;"><span id="eventsTitleIcon"></span> <span style="background:linear-gradient(90deg,#f59e0b,#ef4444,#f97316); background-clip:text; -webkit-background-clip:text; -webkit-text-fill-color:transparent;">Events</span></h2>
            
            <!-- Main Quest Section -->
            <div style="background:linear-gradient(135deg,rgba(239,68,68,0.15),rgba(249,115,22,0.1)); border-radius:12px; padding:18px; margin-bottom:20px; border:1px solid rgba(239,68,68,0.3);">
                <h3 style="margin:0 0 12px 0; color:#f97316; font-size:20px;"><span id="mainQuestIcon"></span> Main Quest: Fire Class</h3>
                <p style="color:#ddd; margin-bottom:16px;">Complete 5 quests to earn a <span style="color:#4ade80; font-weight:700;">Free Basic Summon</span>. Complete all 10 to unlock <span style="color:#ef4444; font-weight:700;">Fire</span> and earn a <span style="color:#ffd700; font-weight:700;">FREE Gold Summon!</span></p>
                
                <div id="fireQuestProgress" style="margin-bottom:16px;">
                    <div style="display:flex; justify-content:space-between; margin-bottom:6px;">
                        <span style="color:#fff; font-weight:600;">Overall Progress</span>
                        <span id="fireQuestCount" style="color:#4ade80; font-weight:700;">0 / 10</span>
                    </div>
                    <div style="background:rgba(0,0,0,0.4); border-radius:8px; height:12px; overflow:hidden;">
                        <div id="fireQuestBar" style="height:100%; background:linear-gradient(90deg,#ef4444,#f97316); width:0%; transition:width 0.3s ease;"></div>
                    </div>
                </div>
                
                <div id="fireQuestList" style="display:flex; flex-direction:column; gap:10px;"></div>

                <div id="fireQuestReward" style="display:none; margin-top:16px; padding:14px; background:linear-gradient(90deg,rgba(74,222,128,0.2),rgba(34,211,238,0.2)); border-radius:10px; text-align:center;">
                    <p style="color:#4ade80; font-weight:800; font-size:18px; margin:0;"><span id="questCompleteIcon"></span> All Quests Complete!</p>
                    <p style="color:#ffd700; margin:8px 0 8px 0;">Fire class ready to unlock â€” claim your reward below.</p>
                    <button onclick="claimFireFinal()" style="padding:10px 16px; border-radius:10px; background:linear-gradient(90deg,#ffd700,#ffb347); border:0; font-weight:800; cursor:pointer;">Claim Unlock & Free Gold Summon</button>
                </div>
                <div id="fireQuestHalfReward" style="display:none; margin-top:12px; padding:10px; background:linear-gradient(90deg,rgba(148,163,184,0.08),rgba(74,222,128,0.06)); border-radius:8px; text-align:center;">
                    <p style="color:#a7f3d0; font-weight:700; margin:0;">Milestone reached â€” Free Basic Summon available!</p>
                    <div style="margin-top:8px;"><button onclick="claimFireHalf()" style="padding:8px 12px; border-radius:8px; background:linear-gradient(90deg,#4ade80,#22d3ee); border:0; color:#071122; font-weight:800; cursor:pointer;">Claim Free Basic Summon</button></div>
                </div>
            </div>
            
            <!-- Miner Event (separate box) -->
            <div style="background:rgba(255,255,255,0.05); border-radius:12px; padding:18px; border:1px solid rgba(255,255,255,0.06); margin-bottom:16px;">
                <h3 style="margin:0 0 8px 0; color:#8b5cf6;"><span id="minerEventIcon"></span> Miner Event</h3>
                <p style="color:#ccc; margin:0 0 12px 0;">Quick event: login or play a game to earn Miner shards.</p>
                <div id="minerQuestList" style="display:flex; flex-direction:column; gap:8px;"></div>
            </div>

            <!-- Future Events Placeholder -->
            <div style="background:rgba(255,255,255,0.05); border-radius:12px; padding:18px; border:1px solid rgba(255,255,255,0.1);">
                <h3 style="margin:0 0 8px 0; color:#a78bfa;"><span id="upcomingEventsIcon"></span> Upcoming Events</h3>
                <p style="color:#888; margin:0;">More events coming soon...</p>
            </div>

            <!-- Events Log (hidden; logging moved to console only) -->
            <div id="eventsLogBox" style="display:none; margin-top:14px; background:rgba(0,0,0,0.22); border-radius:12px; padding:12px; border:1px solid rgba(255,255,255,0.04); max-height:160px; overflow:hidden;">
                <h4 style="margin:0 0 8px 0; color:#c7b3ff; font-size:14px;">Event Log</h4>
                <div id="eventsLogList" style="max-height:120px; overflow-y:auto; display:flex; flex-direction:column-reverse; gap:6px; padding-right:6px;"></div>
            </div>
        </div>
    </div>

    <!-- Summon screen: 3D podium + summon animation -->
    <div id="summonScreen" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.85); z-index:9999; align-items:center; justify-content:center; padding:20px; box-sizing:border-box; overflow:auto;">
        <div style="width:920px; max-width:95vw; height:680px; max-height:calc(95vh - 40px); background:linear-gradient(180deg, rgba(6,7,20,0.95), rgba(12,12,32,0.95)); border-radius:16px; padding:18px; position:relative; box-shadow:0 20px 80px rgba(0,0,0,0.7); overflow:auto;">
            <div id="summonError" style="display:none; color:#ff9aa2; font-weight:700; text-align:center; padding:8px 12px; border-radius:8px; background:rgba(0,0,0,0.35); position:absolute; left:18px; right:18px; top:18px; z-index:12;"></div>
            <button onclick="closeSummonScreen()" aria-label="Close summon" style="position:absolute; right:14px; top:14px; background:#2b2b3a; border:0; padding:10px 14px; color:#fff; border-radius:10px; z-index:20; box-shadow:0 6px 18px rgba(0,0,0,0.6);">X</button>
            <!-- Summon Tabs -->
            <div id="summonTabs" style="display:flex; gap:8px; margin-bottom:12px;">
                <button id="tabGold" onclick="setSummonTab('gold')" style="flex:1; padding:12px 0; border-radius:10px 10px 0 0; border:0; font-weight:800; font-size:15px; cursor:pointer; background:linear-gradient(90deg,#ffd700,#ffb347); color:#1a1a2e;"><span id="tabGoldIcon"></span> Gold Summon</button>
                <button id="tabBasic" onclick="setSummonTab('basic')" style="flex:1; padding:12px 0; border-radius:10px 10px 0 0; border:0; font-weight:800; font-size:15px; cursor:pointer; background:rgba(255,255,255,0.1); color:#ccc;">Basic Summon</button>
            </div>
            <div style="display:flex; gap:18px; height:calc(100% - 56px);">
                <div style="flex:1; display:flex; flex-direction:column; gap:12px; align-items:center; justify-content:center;">
                    <div id="summonCanvasContainer" style="width:100%; height:400px; background:#07101a; border-radius:12px; overflow:hidden;"></div>
                    <div style="display:flex; gap:12px; align-items:center;">
                        <button id="doSummonBtn" onclick="doSummon()" style="background:linear-gradient(90deg,#ffd47a,#ff80c4); padding:14px 20px; min-width:140px; border-radius:12px; border:0; font-weight:800; text-align:center;">Summon</button>
                        <button id="doSummon10Btn" onclick="doSummonMultiple(10)" style="background:linear-gradient(90deg,#ffd47a,#ff80c4); padding:14px 20px; min-width:140px; border-radius:12px; border:0; font-weight:800; text-align:center;">Summon x10</button>
                        <div id="summonResult" style="color:#fff; font-weight:700; min-width:260px; text-align:left;"></div>
                    </div>
                </div>
                <div style="width:360px; padding:12px; color:#ddd; overflow:visible;">
                    <div id="summonInfoGold">
                        <h3 style="margin-top:8px; color:#ffd700;"><span id="goldSummonIcon"></span> Gold Summoning</h3>
                        <p style="color:#ddd;">Each summon costs <span style="color:#ffd700; font-weight:700;">2,000 coins</span>.</p>
                        <p style="color:#ddd; margin-top:4px;">Grants <span style="color:#ffd700; font-weight:700;">50 shards (75%)</span> or <span style="color:#4ade80; font-weight:700;">100 shards (25%)</span> for a random class.</p>
                        <p style="color:#7dd3fc; margin-top:6px; font-weight:600;">First Gold summon is FREE!</p>
                    </div>
                    <div id="summonInfoBasic" style="display:none;">
                        <h3 style="margin-top:8px">Basic Summoning</h3>
                        <p style="color:#ddd;">Each summon costs <span style="color:#ffd47a; font-weight:700;">500 coins</span> and grants <span style="color:#a78bfa; font-weight:700;">5-30 shards</span> for a random class.</p>
                    </div>
                    <p style="margin-top:10px; color:#ccc;">Collect <strong>100 shards</strong> to unlock a class.</p>
                    <h4 style="margin-top:16px; color:#e0e7ff;">Shard Progress</h4>
                    <div id="shardProgressList" style="max-height:250px; overflow-y:auto;"></div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // ========== LOADING SCREEN MANAGER ==========
        const LoadingManager = {
            progress: 0,
            steps: 0,
            totalSteps: 5, // Adjust based on initialization steps
            bar: null,
            text: null,
            screen: null,
            
            init() {
                this.bar = document.getElementById('loadingBar');
                this.text = document.getElementById('loadingText');
                this.screen = document.getElementById('loadingScreen');
            },
            
            setStatus(message) {
                if (this.text) this.text.textContent = message;
            },
            
            advance(message) {
                this.steps++;
                this.progress = Math.min(100, Math.round((this.steps / this.totalSteps) * 100));
                if (this.bar) this.bar.style.width = this.progress + '%';
                if (message) this.setStatus(message);
            },
            
            complete() {
                this.progress = 100;
                if (this.bar) this.bar.style.width = '100%';
                this.setStatus('Ready!');
                setTimeout(() => {
                    if (this.screen) this.screen.classList.add('hidden');
                }, 300);
            }
        };
        
        // Initialize loading manager immediately
        LoadingManager.init();
        LoadingManager.setStatus('Loading scripts...');
        
        // Check if Three.js loaded successfully
        if (typeof THREE !== 'undefined') {
            LoadingManager.advance('3D engine loaded...');
        }
        
        // ========== HP MANAGER ==========
        class HPManager {
            constructor(entity, maxHp) {
                this.entity = entity;
                this.maxHp = maxHp;
                this.currentHp = maxHp;
                
                this.hpBar = document.getElementById('hpBar');
                this.hpText = document.getElementById('hpText');
                
                this.updateUI();
            }
            
            damage(amount) {
                this.currentHp = Math.max(0, this.currentHp - amount);
                this.updateUI();
                this.flashRed();
            }
            
            heal(amount) {
                this.currentHp = Math.min(this.maxHp, this.currentHp + amount);
                this.updateUI();
            }
            
            updateUI() {
                const percentage = (this.currentHp / this.maxHp) * 100;
                this.hpBar.style.width = percentage + '%';
                this.hpText.textContent = `${Math.ceil(this.currentHp)} / ${this.maxHp}`;
                
                if (percentage > 60) {
                    this.hpBar.style.background = 'linear-gradient(90deg, #4ade80 0%, #22c55e 100%)';
                } else if (percentage > 30) {
                    this.hpBar.style.background = 'linear-gradient(90deg, #fbbf24 0%, #f59e0b 100%)';
                } else {
                    this.hpBar.style.background = 'linear-gradient(90deg, #ff3b3b 0%, #dc2626 100%)';
                }
            }
            
            flashRed() {
                const originalColor = this.entity.material.color.getHex();
                this.entity.material.color.setHex(0xff0000);
                
                setTimeout(() => {
                    this.entity.material.color.setHex(originalColor);
                }, 100);
            }
            
            isDead() {
                return this.currentHp <= 0;
            }
            
            reset() {
                this.currentHp = this.maxHp;
                this.updateUI();
            }

            // Accessors for dev utilities
            getHP() { return this.currentHp; }
            getMaxHP() { return this.maxHp; }
        }

        // ========== EFFECTS MANAGER ==========
        class EffectsManager {
            constructor(scene) {
                this.scene = scene;
                this.effects = [];
            }
            
            createLightningBolt(start, end) {
                const points = [];
                const segments = 8;
                
                for (let i = 0; i <= segments; i++) {
                    const t = i / segments;
                    const x = start.x + (end.x - start.x) * t + (Math.random() - 0.5) * 0.3;
                    const y = start.y + (end.y - start.y) * t + (Math.random() - 0.5) * 0.3;
                    const z = start.z + (end.z - start.z) * t;
                    points.push(new THREE.Vector3(x, y, z));
                }
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 3 });
                const lightning = new THREE.Line(geometry, material);
                
                this.scene.add(lightning);
                setTimeout(() => this.scene.remove(lightning), 150);
            }
            
            createFireball(position, direction, speed) {
                const geometry = new THREE.SphereGeometry(0.3, 16, 16);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0xff6600, emissive: 0xff3300, emissiveIntensity: 0.8 
                });
                const fireball = new THREE.Mesh(geometry, material);
                
                fireball.position.copy(position);
                fireball.userData.direction = direction;
                fireball.userData.speed = speed;
                fireball.userData.trail = [];
                
                const glowGeometry = new THREE.SphereGeometry(0.5, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.3 });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                fireball.add(glow);
                
                this.scene.add(fireball);
                return fireball;
            }
            
            createProjectileTrail(position, color) {
                const geometry = new THREE.SphereGeometry(0.15, 8, 8);
                const material = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.6 });
                const trail = new THREE.Mesh(geometry, material);
                trail.position.copy(position);
                trail.userData = { lifetime: 300, created: Date.now() };
                
                this.scene.add(trail);
                this.effects.push({ type: 'trail', trail });
            }
            
            createWave(position, radius) {
                const geometry = new THREE.RingGeometry(0.5, radius, 32);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x00bfff, transparent: true, opacity: 0.7, side: THREE.DoubleSide 
                });
                const wave = new THREE.Mesh(geometry, material);
                wave.position.copy(position);
                this.scene.add(wave);
                
                const startTime = Date.now();
                const duration = 500;
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = elapsed / duration;
                    if (progress < 1) {
                        wave.scale.set(1 + progress * 2, 1 + progress * 2, 1);
                        wave.material.opacity = 0.7 * (1 - progress);
                        requestAnimationFrame(animate);
                    } else {
                        this.scene.remove(wave);
                    }
                };
                animate();
            }
            
            createReverseWave(position, radius) {
                const geometry = new THREE.RingGeometry(0.5, radius, 32);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0x00bfff, transparent: true, opacity: 0.7, side: THREE.DoubleSide 
                });
                const wave = new THREE.Mesh(geometry, material);
                wave.position.copy(position);
                wave.scale.set(3, 3, 1);
                this.scene.add(wave);
                
                const startTime = Date.now();
                const duration = 500;
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = elapsed / duration;
                    if (progress < 1) {
                        wave.scale.set(3 - progress * 2, 3 - progress * 2, 1);
                        wave.material.opacity = 0.7 * (1 - progress);
                        requestAnimationFrame(animate);
                    } else {
                        this.scene.remove(wave);
                    }
                };
                animate();
            }
            
            createExplosion(position, color) {
                const particles = [];
                for (let i = 0; i < 12; i++) {
                    const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
                    const material = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.5 });
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.copy(position);
                    
                    const angle = (i / 12) * Math.PI * 2;
                    const speed = 0.1 + Math.random() * 0.1;
                    particle.userData = {
                        velocity: new THREE.Vector3(Math.cos(angle) * speed, Math.sin(angle) * speed, 0),
                        lifetime: 500,
                        created: Date.now()
                    };
                    
                    this.scene.add(particle);
                    particles.push(particle);
                }
                this.effects.push({ type: 'particles', particles });
            }
            
            createDeathExplosion(position, color) {
                const particles = [];
                const ringGeometry = new THREE.RingGeometry(0.1, 2, 32);
                const ringMaterial = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8, side: THREE.DoubleSide });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.position.copy(position);
                this.scene.add(ring);
                
                const ringStart = Date.now();
                const animateRing = () => {
                    const elapsed = Date.now() - ringStart;
                    const progress = elapsed / 400;
                    if (progress < 1) {
                        ring.scale.set(1 + progress * 2, 1 + progress * 2, 1);
                        ring.material.opacity = 0.8 * (1 - progress);
                        requestAnimationFrame(animateRing);
                    } else {
                        this.scene.remove(ring);
                    }
                };
                animateRing();
                
                for (let i = 0; i < 24; i++) {
                    const size = 0.15 + Math.random() * 0.15;
                    const geometry = new THREE.SphereGeometry(size, 8, 8);
                    const material = new THREE.MeshStandardMaterial({ 
                        color: color, emissive: color, emissiveIntensity: 0.8, transparent: true, opacity: 1 
                    });
                    const particle = new THREE.Mesh(geometry, material);
                    particle.position.copy(position);
                    
                    const angle = (i / 24) * Math.PI * 2;
                    const speed = 0.15 + Math.random() * 0.15;
                    particle.userData = {
                        velocity: new THREE.Vector3(Math.cos(angle) * speed, Math.sin(angle) * speed, (Math.random() - 0.5) * 0.1),
                        rotationSpeed: (Math.random() - 0.5) * 0.3,
                        lifetime: 600,
                        created: Date.now()
                    };
                    
                    this.scene.add(particle);
                    particles.push(particle);
                }
                this.effects.push({ type: 'particles', particles });
            }
            
            createClassEffect(position, className) {
                const effects = {
                    electric: { color: 0xffff00 }, fire: { color: 0xff6600 }, pierce: { color: 0x8b4513 },
                    engineer: { color: 0xffa500 }, life: { color: 0xff0000 }, summoner: { color: 0x9333ea },
                    water: { color: 0x00bfff }
                };
                const effect = effects[className];
                if (!effect) return;
                
                const auraGeometry = new THREE.RingGeometry(1, 1.5, 32);
                const auraMaterial = new THREE.MeshBasicMaterial({ color: effect.color, transparent: true, opacity: 0.5, side: THREE.DoubleSide });
                const aura = new THREE.Mesh(auraGeometry, auraMaterial);
                aura.position.copy(position);
                this.scene.add(aura);
                
                const startTime = Date.now();
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = elapsed / 800;
                    if (progress < 1) {
                        aura.scale.set(1 + progress, 1 + progress, 1);
                        aura.material.opacity = 0.5 * (1 - progress);
                        aura.rotation.z += 0.05;
                        requestAnimationFrame(animate);
                    } else {
                        this.scene.remove(aura);
                    }
                };
                animate();
            }
            
            createDamageNumber(position, damage) {
                const canvas = document.createElement('canvas');
                canvas.width = 128; canvas.height = 64;
                const context = canvas.getContext('2d');
                context.font = 'Bold 40px Arial';
                context.fillStyle = 'white';
                context.strokeStyle = 'black';
                context.lineWidth = 3;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                const text = Math.floor(damage).toString();
                context.strokeText(text, 64, 32);
                context.fillText(text, 64, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(material);
                sprite.position.copy(position);
                sprite.position.y += 0.5;
                sprite.scale.set(1, 0.5, 1);
                sprite.userData = { lifetime: 1000, created: Date.now(), velocity: new THREE.Vector3(0, 0.02, 0) };
                
                this.scene.add(sprite);
                this.effects.push({ type: 'sprite', sprite });
            }
            
            update() {
                const now = Date.now();
                for (let i = this.effects.length - 1; i >= 0; i--) {
                    const effect = this.effects[i];
                    if (effect.type === 'particles') {
                        let allExpired = true;
                        effect.particles.forEach(particle => {
                            if (now - particle.userData.created < particle.userData.lifetime) {
                                allExpired = false;
                                particle.position.add(particle.userData.velocity);
                                particle.userData.velocity.multiplyScalar(0.95);
                                if (particle.userData.rotationSpeed) {
                                    particle.rotation.x += particle.userData.rotationSpeed;
                                    particle.rotation.y += particle.userData.rotationSpeed * 0.7;
                                }
                                const progress = (now - particle.userData.created) / particle.userData.lifetime;
                                particle.material.opacity = 1 - progress;
                            }
                        });
                        if (allExpired) {
                            effect.particles.forEach(p => this.scene.remove(p));
                            this.effects.splice(i, 1);
                        }
                    } else if (effect.type === 'sprite') {
                        const sprite = effect.sprite;
                        const elapsed = now - sprite.userData.created;
                        if (elapsed < sprite.userData.lifetime) {
                            sprite.position.add(sprite.userData.velocity);
                            sprite.material.opacity = 1 - (elapsed / sprite.userData.lifetime);
                        } else {
                            this.scene.remove(sprite);
                            this.effects.splice(i, 1);
                        }
                    } else if (effect.type === 'trail') {
                        const trail = effect.trail;
                        const elapsed = now - trail.userData.created;
                        if (elapsed < trail.userData.lifetime) {
                            const progress = elapsed / trail.userData.lifetime;
                            trail.material.opacity = 0.6 * (1 - progress);
                            trail.scale.setScalar(1 - progress * 0.5);
                        } else {
                            this.scene.remove(trail);
                            this.effects.splice(i, 1);
                        }
                    }
                }
            }
        }

        // ========== MOVEMENT MANAGER ==========
        class MovementManager {
            constructor(entity, speed) {
                this.entity = entity;
                this.speed = speed;
                this.keys = { w: false, a: false, s: false, d: false, ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
                this.lastMovement = { x: 0, y: 1 }; // Default facing up (normalized direction)
                this.joystick = { x: 0, y: 0 };
                this.joystickActive = false;
                
                const viewHeight = window.innerHeight / 40;
                const viewWidth = window.innerWidth / 40;
                this.bounds = { minX: -viewWidth + 1, maxX: viewWidth - 1, minY: -viewHeight + 1, maxY: viewHeight - 1 };
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                window.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    if (this.keys.hasOwnProperty(key)) this.keys[key] = true;
                    if (this.keys.hasOwnProperty(e.key)) this.keys[e.key] = true;
                });
                window.addEventListener('keyup', (e) => {
                    const key = e.key.toLowerCase();
                    if (this.keys.hasOwnProperty(key)) this.keys[key] = false;
                    if (this.keys.hasOwnProperty(e.key)) this.keys[e.key] = false;
                });
            }

            setJoystick(x, y) {
                this.joystick.x = x;
                this.joystick.y = y;
                this.joystickActive = (Math.abs(x) > 0.001 || Math.abs(y) > 0.001);
            }

            clearJoystick() {
                this.joystick.x = 0; this.joystick.y = 0; this.joystickActive = false;
            }
            
            update() {
                let moveX = 0, moveY = 0;

                // If joystick active, prefer it over keyboard keys
                if (this.joystickActive) {
                    moveX = this.joystick.x * this.speed;
                    moveY = this.joystick.y * this.speed;
                } else {
                    if (this.keys.w || this.keys.ArrowUp) moveY += this.speed;
                    if (this.keys.s || this.keys.ArrowDown) moveY -= this.speed;
                    if (this.keys.a || this.keys.ArrowLeft) moveX -= this.speed;
                    if (this.keys.d || this.keys.ArrowRight) moveX += this.speed;
                }

                // Store normalized direction before applying speed
                let dirX = 0, dirY = 0;
                if (this.joystickActive) {
                    dirX = this.joystick.x; dirY = this.joystick.y;
                } else {
                    if (this.keys.w || this.keys.ArrowUp) dirY += 1;
                    if (this.keys.s || this.keys.ArrowDown) dirY -= 1;
                    if (this.keys.a || this.keys.ArrowLeft) dirX -= 1;
                    if (this.keys.d || this.keys.ArrowRight) dirX += 1;
                }

                // Normalize direction
                if (dirX !== 0 || dirY !== 0) {
                    const length = Math.sqrt(dirX * dirX + dirY * dirY);
                    dirX /= length;
                    dirY /= length;
                    this.lastMovement = { x: dirX, y: dirY };
                }

                if (moveX !== 0 && moveY !== 0) {
                    const length = Math.sqrt(moveX * moveX + moveY * moveY);
                    moveX /= length; moveY /= length;
                    moveX *= this.speed; moveY *= this.speed;
                }

                const newX = this.entity.position.x + moveX;
                const newY = this.entity.position.y + moveY;

                // Helper: check whether moving to (x,y) would put player within any enemy's damaging range
                const wouldBeInDanger = (x, y) => {
                    try {
                        const pr = (this.entity.userData && this.entity.userData.collisionRadius) ? this.entity.userData.collisionRadius : 0.9;
                        if (!window.gameState || !Array.isArray(window.gameState.enemies)) return false;
                        for (const enemy of window.gameState.enemies) {
                            if (!enemy || !enemy.userData) continue;
                            const er = (enemy.userData.attackRange != null) ? enemy.userData.attackRange : 1.5;
                            const ec = (enemy.userData.collisionRadius != null) ? enemy.userData.collisionRadius : 0.8;
                            const dx = enemy.position.x - x;
                            const dy = enemy.position.y - y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist <= (er + ec + pr)) return true;
                        }
                    } catch (e) { /* ignore errors */ }
                    return false;
                };

                // Apply axis-limited movement if safe
                if (newX >= this.bounds.minX && newX <= this.bounds.maxX) {
                    if (!wouldBeInDanger(newX, this.entity.position.y)) this.entity.position.x = newX;
                }
                if (newY >= this.bounds.minY && newY <= this.bounds.maxY) {
                    if (!wouldBeInDanger(this.entity.position.x, newY)) this.entity.position.y = newY;
                }

                if (moveX !== 0 || moveY !== 0) {
                    const targetRotation = Math.atan2(moveY, moveX) - Math.PI / 2;
                    let rotDiff = targetRotation - this.entity.rotation.z;
                    while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                    while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                    this.entity.rotation.z += rotDiff * 0.15;
                }
            }
            
            getLastMovement() {
                return this.lastMovement;
            }
            
            updateBounds() {
                const viewHeight = window.innerHeight / 40;
                const viewWidth = window.innerWidth / 40;
                this.bounds = { minX: -viewWidth + 1, maxX: viewWidth - 1, minY: -viewHeight + 1, maxY: viewHeight - 1 };
            }
        }
    </script>
    
    <script>
        // ==================== SERVER WAKE-UP ====================
        const API_BASE = 'https://twilight-lake-7d12.offshore-unk.workers.dev';
        let serverReady = false;
        
        async function startServerWake() {
            const statusEl = document.getElementById('wakeStatus');
            const progressBar = document.getElementById('wakeProgressBar');
            const tipEl = document.getElementById('wakeTip');
            const retryBtn = document.getElementById('wakeRetryBtn');
            
            retryBtn.style.display = 'none';
            statusEl.textContent = 'Connecting to server...';
            tipEl.textContent = 'Free servers sleep after inactivity. Waking up usually takes 10-30 seconds.';
            
            let progress = 0;
            const progressInterval = setInterval(() => {
                progress = Math.min(progress + 2, 90);
                progressBar.style.width = progress + '%';
            }, 500);
            
            const maxAttempts = 20;
            let attempts = 0;
            
            while (attempts < maxAttempts && !serverReady) {
                attempts++;
                statusEl.textContent = `Waking up server... (attempt ${attempts}/${maxAttempts})`;
                
                try {
                    const controller = new AbortController();
                    const timeout = setTimeout(() => controller.abort(), 8000);
                    
                    // Use health endpoint without credentials for iframe CORS compatibility
                    const res = await fetch(`${API_BASE}/api/health`, {
                        signal: controller.signal,
                        mode: 'cors'
                    });
                    clearTimeout(timeout);
                    
                    if (res.ok) {
                        serverReady = true;
                        clearInterval(progressInterval);
                        progressBar.style.width = '100%';
                        statusEl.textContent = 'Server ready!';
                        
                        setTimeout(() => {
                            document.getElementById('serverWakeScreen').classList.add('hidden');
                        }, 500);
                        return;
                    }
                } catch (e) {
                    // Server still waking up
                }
                
                await new Promise(r => setTimeout(r, 2000));
            }
            
            clearInterval(progressInterval);
            statusEl.textContent = 'Server is taking longer than usual...';
            tipEl.textContent = 'The server might be under heavy load. Click retry to try again.';
            retryBtn.style.display = 'block';
        }
        
        // Start wake-up on page load
        startServerWake();
    </script>
    
    <script>
        // ==================== API & AUTH CONFIGURATION ====================
        let currentUser = null;
        let isGuest = false;
        
        // Auth tab switching
        function showAuthTab(tab) {
            document.querySelectorAll('.auth-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.auth-form').forEach(f => f.classList.remove('active'));
            document.querySelector(`.auth-tab:nth-child(${tab === 'login' ? 1 : 2})`).classList.add('active');
            document.getElementById(tab === 'login' ? 'loginForm' : 'registerForm').classList.add('active');
            document.getElementById('authError').classList.remove('visible');
        }
        
        function showAuthError(msg) {
            const el = document.getElementById('authError');
            el.textContent = msg;
            el.classList.add('visible');
        }
        
        async function doLogin() {
            const username = document.getElementById('loginUsername').value.trim();
            const password = document.getElementById('loginPassword').value;
            
            if (!username || !password) {
                showAuthError('Please fill in all fields');
                return;
            }
            
            try {
                const res = await fetch(`${API_BASE}/api/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ username, password })
                });
                const data = await res.json();
                
                if (data.success) {
                    currentUser = {
                        id: data.user_id,
                        username: data.username,
                        display_name: data.display_name
                    };
                    isGuest = false;
                    onAuthSuccess();
                } else {
                    showAuthError(data.error || 'Login failed');
                }
            } catch (err) {
                showAuthError('Connection error. Please try again.');
            }
        }
        
        async function doRegister() {
            const username = document.getElementById('regUsername').value.trim();
            const displayName = document.getElementById('regDisplayName').value.trim();
            const email = document.getElementById('regEmail').value.trim();
            const password = document.getElementById('regPassword').value;
            
            if (!username || !displayName || !email || !password) {
                showAuthError('Please fill in all fields');
                return;
            }
            
            try {
                const res = await fetch(`${API_BASE}/api/register`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ username, display_name: displayName, email, password })
                });
                const data = await res.json();
                
                if (data.success) {
                    currentUser = {
                        id: data.user_id,
                        username: data.username,
                        display_name: data.display_name
                    };
                    isGuest = false;
                    onAuthSuccess();
                } else {
                    showAuthError(data.error || 'Registration failed');
                }
            } catch (err) {
                showAuthError('Connection error. Please try again.');
            }
        }
        
        function playAsGuest() {
            currentUser = null;
            isGuest = true;
            onAuthSuccess();
        }
        
        function doLogout() {
            currentUser = null;
            isGuest = false;
            document.getElementById('authScreen').classList.remove('hidden');
            document.getElementById('userInfo').classList.add('hidden');
            document.getElementById('homeScreen').style.display = 'none';
        }
        
        function onAuthSuccess() {
            document.getElementById('authScreen').classList.add('hidden');
            if (currentUser) {
                document.getElementById('userDisplayName').textContent = currentUser.display_name;
                document.getElementById('userInfo').classList.remove('hidden');
            } else {
                document.getElementById('userInfo').classList.add('hidden');
            }
            // Load game save if logged in
            if (currentUser && !isGuest) {
                loadGameFromServer();
            }
        }
        
        // ==================== CLOUD SAVE FUNCTIONS ====================
        async function saveGameToServer() {
            if (!currentUser || isGuest) return;
            
            try {
                const saveData = {
                    coins: gameState.coins,
                    highestWaveReached: gameState.highestWaveReached,
                    totalKills: questStats.totalKills || 0,
                    unlockedClasses: unlockedClasses,
                    classShards: classShards,
                    classLevels: classLevels,
                    classExp: classExp,
                    questStats: questStats,
                    freeBasicSummons: gameState.freeBasicSummons || 0,
                    freeGoldSummons: gameState.freeGoldSummons || 0,
                    firstSummonDone: firstSummonDone
                };
                
                await fetch(`${API_BASE}/api/game/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        user_id: currentUser.id,
                        game_data: saveData
                    })
                });
                console.log('Game saved to cloud');
            } catch (err) {
                console.error('Failed to save game:', err);
            }
        }
        
        async function loadGameFromServer() {
            if (!currentUser || isGuest) return;
            
            try {
                const res = await fetch(`${API_BASE}/api/game/load?user_id=${currentUser.id}`, {
                    credentials: 'include'
                });
                const data = await res.json();
                
                if (data.success && data.game_data) {
                    const save = data.game_data;
                    
                    // Restore game state
                    if (save.coins !== undefined) gameState.coins = save.coins;
                    if (save.highestWaveReached !== undefined) gameState.highestWaveReached = save.highestWaveReached;
                    if (save.unlockedClasses) unlockedClasses = save.unlockedClasses;
                    if (save.classShards) classShards = Object.assign(classShards, save.classShards);
                    if (save.classLevels) classLevels = Object.assign(classLevels, save.classLevels);
                    if (save.classExp) classExp = Object.assign(classExp, save.classExp);
                    if (save.questStats) questStats = Object.assign(questStats, save.questStats);
                    if (save.freeBasicSummons !== undefined) gameState.freeBasicSummons = save.freeBasicSummons;
                    if (save.freeGoldSummons !== undefined) gameState.freeGoldSummons = save.freeGoldSummons;
                    if (save.firstSummonDone !== undefined) firstSummonDone = save.firstSummonDone;
                    
                    // Update UI
                    updateCoinDisplay();
                    updateClassCardLockState();
                    updateAllExpBars();
                    console.log('Game loaded from cloud');
                }
            } catch (err) {
                console.error('Failed to load game:', err);
            }
        }
        
        // Debounced save - triggers save after data changes with 2 second delay
        let saveTimeout = null;
        function triggerSave() {
            if (!currentUser || isGuest) return;
            if (saveTimeout) clearTimeout(saveTimeout);
            saveTimeout = setTimeout(() => {
                saveGameToServer();
            }, 2000); // 2 second debounce
        }
        
        // Immediate save for critical changes (class unlocks, purchases)
        function triggerImmediateSave() {
            if (!currentUser || isGuest) return;
            if (saveTimeout) clearTimeout(saveTimeout);
            saveGameToServer();
        }
    </script>
    
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0f0f1e);
        
        const camera = new THREE.OrthographicCamera(
            window.innerWidth / -40,
            window.innerWidth / 40,
            window.innerHeight / 40,
            window.innerHeight / -40,
            0.1,
            1000
        );
        camera.position.set(0, 0, 20);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Ensure correct color space for canvas textures
        try { renderer.outputEncoding = THREE.sRGBEncoding; } catch (e) {}
        document.body.appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 5, 10);
        scene.add(directionalLight);
        
        // Class unlock order (start with electric unlocked)
        const classOrder = ['electric', 'fire', 'pierce', 'engineer', 'life', 'summoner', 'water', 'miner', 'thief', 'trapper'];
        const CLASS_UNLOCK_COST = 10000; // 10K coins per class (legacy, still used for direct unlock button)
        const SHARD_SUMMON_COST = 500; // Much cheaper shard summon
        const SHARDS_TO_UNLOCK = 100; // Need 100 shards to unlock a class

        // Shard tracking per class (0-100) - session only, no persistence
        let classShards = {};
        let firstSummonDone = false;
        let currentSummonTab = 'gold'; // 'gold' or 'basic'
        const GOLD_SUMMON_COST = 2000;
        // Initialize shards for all classes
        classOrder.forEach(c => { classShards[c] = 0; });

        // ========== FIRE QUEST SYSTEM ==========
        // Fire is excluded from normal summons and unlocked via quests only
        const fireQuests = [
            { id: 1, title: 'First Steps', description: 'Kill 10 enemies', target: 10, stat: 'totalKills', completed: false },
            { id: 2, title: 'Survivor', description: 'Reach Wave 3', target: 3, stat: 'highestWave', completed: false },
            { id: 3, title: 'Coin Collector', description: 'Earn 500 coins total', target: 500, stat: 'totalCoinsEarned', completed: false },
            { id: 4, title: 'Wave Crusher', description: 'Reach Wave 5', target: 5, stat: 'highestWave', completed: false },
            { id: 5, title: 'Slayer', description: 'Kill 50 enemies', target: 50, stat: 'totalKills', completed: false },
            { id: 6, title: 'Boss Hunter', description: 'Kill 3 bosses', target: 3, stat: 'bossKills', completed: false },
            { id: 7, title: 'Wealthy', description: 'Earn 2000 coins total', target: 2000, stat: 'totalCoinsEarned', completed: false },
            { id: 8, title: 'Veteran', description: 'Reach Wave 10', target: 10, stat: 'highestWave', completed: false },
            { id: 9, title: 'Exterminator', description: 'Kill 200 enemies', target: 200, stat: 'totalKills', completed: false },
            { id: 10, title: 'Champion', description: 'Reach Wave 15', target: 15, stat: 'highestWave', completed: false }
        ];
        // Miner event quests (2 simple quests)
        const minerQuests = [
            { id: 1, title: 'Welcome Back', description: 'Login to the game', target: 1, stat: 'loggedIn', completed: false, reward: 50 },
            { id: 2, title: 'First Run', description: 'Play a game', target: 1, stat: 'gamesPlayed', completed: false, reward: 25 }
        ];
        // Quest stats tracking
        let questStats = {
            totalKills: 0,
            highestWave: 0,
            gamesPlayed: 0,
            loggedIn: 0,
            totalCoinsEarned: 0,
            bossKills: 0
        };
        let fireQuestRewardClaimed = false;
        let freeGoldSummonAwarded = false;
        let fireQuestHalfRewardClaimed = false; // awarded at 5 quests: free basic summon

        // ========== SVG ICON HELPERS ==========
        function getFireSVG(color = '#ef4444', size = 18) {
            return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" style="vertical-align:middle; display:inline-block;"><path d="M12 23c-4.97 0-9-3.58-9-8 0-3.19 2.13-6.08 4-8 .35 2.5 2 4 4 4-.5-3 1-6 3-8 1 2 2.5 4 2.5 7 2-1 3-3 3-5 2.5 2.5 4.5 5.5 4.5 10 0 4.42-4.03 8-9 8h-3z" fill="${color}"/><ellipse cx="12" cy="17" rx="3" ry="4" fill="#fbbf24"/></svg>`;
        }
        function getStarSVG(color = '#ffd700', size = 18) {
            return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="${color}" style="vertical-align:middle; display:inline-block;"><polygon points="12,2 15.09,8.26 22,9.27 17,14.14 18.18,21.02 12,17.77 5.82,21.02 7,14.14 2,9.27 8.91,8.26"/></svg>`;
        }
        function getTargetSVG(color = '#f97316', size = 18) {
            return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="${color}" stroke-width="2" style="vertical-align:middle; display:inline-block;"><circle cx="12" cy="12" r="10"/><circle cx="12" cy="12" r="6"/><circle cx="12" cy="12" r="2" fill="${color}"/></svg>`;
        }
        function getPartySVG(color = '#4ade80', size = 18) {
            return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="${color}" style="vertical-align:middle; display:inline-block;"><path d="M4.5 21.5l3-9 6 6-9 3zm6.5-12.5a3 3 0 1 1 6 0 3 3 0 0 1-6 0zm6.5 1.5l2.5-5 1 4-4 1z"/><circle cx="6" cy="6" r="1.5"/><circle cx="18" cy="18" r="1"/></svg>`;
        }
        function getCalendarSVG(color = '#a78bfa', size = 18) {
            return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="${color}" stroke-width="2" style="vertical-align:middle; display:inline-block;"><rect x="3" y="4" width="18" height="18" rx="2"/><line x1="16" y1="2" x2="16" y2="6"/><line x1="8" y1="2" x2="8" y2="6"/><line x1="3" y1="10" x2="21" y2="10"/></svg>`;
        }
        function getCheckSVG(color = '#4ade80', size = 16) {
            return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="${color}" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" style="vertical-align:middle; display:inline-block;"><polyline points="20 6 9 17 4 12"/></svg>`;
        }
        function getCloseSVG(color = '#fff', size = 14) {
            return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" stroke="${color}" stroke-width="3" stroke-linecap="round" style="vertical-align:middle; display:inline-block;"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>`;
        }

        function setSummonTab(tab) {
            currentSummonTab = tab;
            const tabGold = document.getElementById('tabGold');
            const tabBasic = document.getElementById('tabBasic');
            const infoGold = document.getElementById('summonInfoGold');
            const infoBasic = document.getElementById('summonInfoBasic');
            if (tab === 'gold') {
                tabGold.style.background = 'linear-gradient(90deg,#ffd700,#ffb347)';
                tabGold.style.color = '#1a1a2e';
                tabBasic.style.background = 'rgba(255,255,255,0.1)';
                tabBasic.style.color = '#ccc';
                if (infoGold) infoGold.style.display = 'block';
                if (infoBasic) infoBasic.style.display = 'none';
            } else {
                tabBasic.style.background = 'linear-gradient(90deg,#a78bfa,#7c3aed)';
                tabBasic.style.color = '#fff';
                tabGold.style.background = 'rgba(255,255,255,0.1)';
                tabGold.style.color = '#ccc';
                if (infoGold) infoGold.style.display = 'none';
                if (infoBasic) infoBasic.style.display = 'block';
            }
            updateSummonButtons();
        }

        function saveClassShards() {
            triggerSave(); // Save to cloud on shard changes
        }

        // Save and load quest state (questStats, quest progress, claimable/completed/reward flags)
        function saveQuestState() {
            try {
                const payload = {
                    questStats: questStats,
                    fireQuests: fireQuests.map(q => ({ id: q.id, completed: !!q.completed, claimable: !!q.claimable, rewardGiven: q.rewardGiven || null })),
                    minerQuests: minerQuests.map(q => ({ id: q.id, completed: !!q.completed, claimable: !!q.claimable, rewardGiven: q.rewardGiven || null })),
                    fireQuestHalfRewardClaimed: !!fireQuestHalfRewardClaimed,
                    fireQuestRewardClaimed: !!fireQuestRewardClaimed,
                    freeGoldSummonAwarded: !!freeGoldSummonAwarded,
                    gameState: {
                        freeBasicSummons: gameState.freeBasicSummons || 0,
                        freeGoldSummons: gameState.freeGoldSummons || 0
                    }
                };
                localStorage.setItem('gg_questState_v1', JSON.stringify(payload));
                triggerSave(); // Also save to cloud
            } catch (e) { console.warn('saveQuestState failed', e); }
        }

        function loadQuestState() {
            try {
                const raw = localStorage.getItem('gg_questState_v1');
                if (!raw) return;
                const data = JSON.parse(raw);
                if (data.questStats) {
                    questStats = Object.assign(questStats || {}, data.questStats);
                }
                if (Array.isArray(data.fireQuests)) {
                    data.fireQuests.forEach(sq => {
                        const q = fireQuests.find(x => x.id === sq.id);
                        if (q) {
                            q.completed = !!sq.completed;
                            q.claimable = !!sq.claimable;
                            q.rewardGiven = sq.rewardGiven || null;
                        }
                    });
                }
                if (Array.isArray(data.minerQuests)) {
                    data.minerQuests.forEach(sq => {
                        const q = minerQuests.find(x => x.id === sq.id);
                        if (q) {
                            q.completed = !!sq.completed;
                            q.claimable = !!sq.claimable;
                            q.rewardGiven = sq.rewardGiven || null;
                        }
                    });
                }
                fireQuestHalfRewardClaimed = !!data.fireQuestHalfRewardClaimed;
                fireQuestRewardClaimed = !!data.fireQuestRewardClaimed;
                freeGoldSummonAwarded = !!data.freeGoldSummonAwarded;
                if (data.gameState) {
                    gameState.freeBasicSummons = data.gameState.freeBasicSummons || 0;
                    gameState.freeGoldSummons = data.gameState.freeGoldSummons || 0;
                }
            } catch (e) { console.warn('loadQuestState failed', e); }
        }

        function saveFirstSummonDone() {
            // No-op: persistence disabled for now
        }

        // SVG shard icon (inline, reusable)
        function getShardSVG(color = '#a78bfa', size = 18) {
            return `<svg width="${size}" height="${size}" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" style="vertical-align:middle;">
                <polygon points="12,2 20,9 16,22 8,22 4,9" fill="${color}" stroke="#fff" stroke-width="1"/>
                <polygon points="12,2 12,22 8,22 4,9" fill="${color}" opacity="0.7"/>
                <polygon points="12,6 16,10 14,18 10,18 8,10" fill="#fff" opacity="0.25"/>
            </svg>`;
        }

        // Unlocked classes - session only, no persistence for now
        let unlockedClasses = ['electric'];

        // Game state (declare early so it can be referenced by unlock UI)
        const gameState = {
            enemies: [],
            projectiles: [],
            allies: [],
            turrets: [],
            minions: [],
            mines: [],
            killCount: 0,
            isGameOver: false,
            spawnTimer: 0,
            spawnInterval: 2000,
            lastTime: Date.now(),
            player: null,
            isInvulnerable: false,
            isInvisible: false,
            machineGunAmmo: 0,
            maxMachineGunAmmo: 200,
            machineGunLastFired: 0,
            machineGunFireRate: 100,
            currentWave: 1,
            enemiesThisWave: 0,
            enemiesPerWave: 10,
            waveInProgress: false,
            classSelected: false,
            enemiesKilledThisWave: 0,
            highestWaveReached: 1,
            lastDamageTime: 0,
            lastHealTime: 0,
            coins: 0,
            summonTokens: 1, // start player with one free summon
            debugAI: false
        };

        function saveUnlockedClasses() {
            triggerImmediateSave(); // Immediately save to cloud on class unlock
        }

        function resetUnlocks() {
            if (!confirm('Reset unlocked classes to default (Electric only)?')) return;
            unlockedClasses = ['electric'];
            saveUnlockedClasses();
            updateClassCardLockState();
            updateBuyNextClassBtn();
            updateCoinDisplay();
            alert('Unlocks reset.');
        }

        function isClassUnlocked(className) {
            return unlockedClasses.includes(className);
        }

        function getNextLockedClass() {
            for (const cn of classOrder) {
                if (!unlockedClasses.includes(cn)) return cn;
            }
            return null; // all unlocked
        }

        // Unlock the next class. If `targetClass` is provided, ensure it is the next locked class.
        function buyNextClass(targetClass) {
            const nextClass = getNextLockedClass();
            const classToBuy = targetClass || nextClass;
            if (!classToBuy) {
                alert('All classes are already unlocked!');
                return;
            }
            // Enforce unlock order
            if (classToBuy !== nextClass) {
                alert('You must unlock classes in order. Next to unlock: ' + (nextClass ? nextClass.charAt(0).toUpperCase() + nextClass.slice(1) : 'none'));
                return;
            }
            if (gameState.coins < CLASS_UNLOCK_COST) {
                alert('Not enough coins! Need ' + CLASS_UNLOCK_COST.toLocaleString() + ' coins.');
                return;
            }
            gameState.coins -= CLASS_UNLOCK_COST;
            unlockedClasses.push(classToBuy);
            saveUnlockedClasses();
            updateCoinDisplay();
            updateClassCardLockState();
            updateBuyNextClassBtn();
            alert('Unlocked ' + classToBuy.charAt(0).toUpperCase() + classToBuy.slice(1) + '!');
        }

        function updateClassCardLockState() {
            const nextClass = getNextLockedClass();
            classOrder.forEach(cn => {
                const card = document.querySelector(`.class-card[onclick*="selectClass('${cn}')"]`);
                if (!card) return;

                // Remove any previous inline unlock button or shard progress
                const prevBtn = card.querySelector('.unlock-class-btn');
                if (prevBtn) prevBtn.remove();
                const prevShardBar = card.querySelector('.card-shard-progress');
                if (prevShardBar) prevShardBar.remove();

                if (isClassUnlocked(cn)) {
                    card.classList.remove('locked', 'unlockable');
                    card.style.pointerEvents = '';
                } else {
                    card.classList.add('locked');

                    // Show shard progress on locked cards
                    const shards = classShards[cn] || 0;
                    const pct = Math.min(100, Math.round((shards / SHARDS_TO_UNLOCK) * 100));
                    const color = summonColors[cn] ? '#' + summonColors[cn].toString(16).padStart(6, '0') : '#a78bfa';
                    
                    // Find or create a place for the shard bar. Prefer the right column so progress appears near the description/buttons.
                    let btnRow = card.querySelector('.class-card-btn-row');
                    const rightCol = card.querySelector('.card-right') || card.querySelector('.class-exp-container');
                    if (!btnRow) {
                        btnRow = document.createElement('div');
                        btnRow.className = 'class-card-btn-row';
                        if (rightCol) rightCol.appendChild(btnRow);
                        else {
                            const leftCol = card.querySelector('.card-left');
                            if (leftCol) leftCol.appendChild(btnRow);
                            else card.appendChild(btnRow);
                        }
                    }

                    // Add shard progress bar (use same visual style as summon screen)
                    const shardDiv = document.createElement('div');
                    shardDiv.className = 'card-shard-progress';
                    shardDiv.style.cssText = 'margin-top:8px; pointer-events:auto;';
                    const displayName = cn.charAt(0).toUpperCase() + cn.slice(1);
                    // Use the existing `.class-exp-bar` visual so it matches other bars and remains visible
                    shardDiv.innerHTML = `
                        <div class="class-level" style="font-size:13px; margin-bottom:6px; color:${color}; font-weight:700;">${displayName}</div>
                        <div class="class-exp-bar" style="height:12px; border-radius:8px; border-color:${color}; margin-top:4px;">
                            <div class="class-exp-fill" style="width:${pct}%; background:${color}; height:100%; box-shadow: none;"></div>
                            <div class="class-exp-text" style="font-size:11px;">${shards}/${SHARDS_TO_UNLOCK}</div>
                        </div>
                    `;

                    // Prefer to insert the shard bar under the description in the right column
                    const insertTarget = card.querySelector('.card-right') || card.querySelector('.class-exp-container');
                    if (insertTarget) {
                        const desc = insertTarget.querySelector('p');
                        if (desc && desc.parentNode === insertTarget) desc.insertAdjacentElement('afterend', shardDiv);
                        else insertTarget.appendChild(shardDiv);
                    } else {
                        btnRow.appendChild(shardDiv);
                    }

                    // If this is the next locked class, also show the direct buy button
                    // NOTE: skip showing the direct-buy unlock on the 'fire' card per UX request
                    if (cn === nextClass && cn !== 'fire') {
                        card.classList.add('unlockable');

                        const unlockBtn = document.createElement('button');
                        unlockBtn.className = 'unlock-class-btn';
                        unlockBtn.textContent = `Buy Unlock (${CLASS_UNLOCK_COST.toLocaleString()} coins)`;
                        unlockBtn.onclick = (e) => { e.stopPropagation(); buyNextClass(cn); };
                        unlockBtn.style.pointerEvents = 'auto';
                        unlockBtn.style.marginTop = '6px';
                        unlockBtn.tabIndex = 0;
                        if (typeof gameState !== 'undefined' && gameState.coins < CLASS_UNLOCK_COST) {
                            unlockBtn.disabled = true;
                            unlockBtn.classList.add('disabled');
                            unlockBtn.title = 'Need ' + CLASS_UNLOCK_COST.toLocaleString() + ' coins';
                        } else {
                            unlockBtn.disabled = false;
                            unlockBtn.classList.remove('disabled');
                            unlockBtn.title = '';
                        }
                        btnRow.appendChild(unlockBtn);
                    } else {
                        card.classList.remove('unlockable');
                    }
                }
            });
            // After updating visuals, reorder class cards so unlocked appear first,
            // then locked classes ordered by shards remaining (fewest shards remaining first).
            try { reorderClassCards(); } catch (e) { /* ignore */ }
        }

        function reorderClassCards() {
            const container = document.querySelector('.class-container');
            if (!container) return;
            const unlocked = classOrder.filter(c => unlockedClasses.includes(c));
            let locked = classOrder.filter(c => !unlockedClasses.includes(c));
            locked.sort((a, b) => {
                const remA = SHARDS_TO_UNLOCK - (classShards[a] || 0);
                const remB = SHARDS_TO_UNLOCK - (classShards[b] || 0);
                if (remA !== remB) return remA - remB;
                return classOrder.indexOf(a) - classOrder.indexOf(b);
            });
            const ordered = unlocked.concat(locked);
            ordered.forEach(cn => {
                const card = container.querySelector(`.class-card[onclick*="selectClass('${cn}')"]`);
                if (card) container.appendChild(card);
            });
        }

        // Check and unlock any class that has reached 100 shards
        function checkShardUnlocks() {
            classOrder.forEach(cn => {
                if (!unlockedClasses.includes(cn) && (classShards[cn] || 0) >= SHARDS_TO_UNLOCK) {
                    unlockedClasses.push(cn);
                    saveUnlockedClasses();
                    console.log('[Shards] Auto-unlocked', cn, 'from shards');
                }
            });
        }

        // Ensure shard UI and ordering are applied once the DOM/layout is ready.
        window.addEventListener('DOMContentLoaded', () => {
            // Advance loading
            LoadingManager.advance('Initializing game state...');
            // Load saved quest state (if any)
            try { loadQuestState(); } catch (e) {}

            // Check for any classes that should be unlocked from shards
            checkShardUnlocks();

            // Miner login quest: award one loggedIn stat on first page load (persisted)
            try {
                const key = 'minerLoginClaimed';
                const rewardedKey = 'minerLoginRewarded';
                if (!localStorage.getItem(key)) {
                    // First-time visit: mark claimed and grant the loggedIn stat (UI will show it completed and player may claim)
                    localStorage.setItem(key, '1');
                    trackQuestProgress('loggedIn', 1);
                } else {
                    // Returning visitor: ensure the stat is visible in the UI (do not auto-award shards)
                    questStats.loggedIn = Math.max(questStats.loggedIn || 0, 1);
                    try { if (typeof minerQuests !== 'undefined' && minerQuests[0]) minerQuests[0].claimable = true; } catch (e) {}
                }
            } catch (e) {}

            // ensure quest UIs reflect loaded state
            try { updateFireQuestUI(); } catch (e) {}
            try { updateMinerQuestUI(); } catch (e) {}

            // small delay to allow class-card restructuring to complete
            setTimeout(() => {
                LoadingManager.advance('Setting up classes...');
                try { updateClassCardLockState(); } catch (e) {}
                try { updateShardProgressList(); } catch (e) {}
                try { reorderClassCards(); } catch (e) {}
                // Populate SVG icons
                try { populateSVGIcons(); } catch (e) {}

                LoadingManager.advance('Loading UI...');

                // Final loading complete after small delay for UI to settle
                setTimeout(() => {
                    LoadingManager.advance('Preparing combat arena...');
                    setTimeout(() => {
                        LoadingManager.complete();
                    }, 200);
                }, 100);
            }, 80);
        });

        // Populate all SVG icon placeholders
        function populateSVGIcons() {
            const iconMap = {
                'eventsFireIcon': getFireSVG('#fff', 18),
                'eventsCloseIcon': getCloseSVG('#fff', 14),
                'eventsTitleIcon': getFireSVG('#ef4444', 28),
                'mainQuestIcon': getTargetSVG('#f97316', 20),
                'questCompleteIcon': getPartySVG('#4ade80', 22),
                'upcomingEventsIcon': getCalendarSVG('#a78bfa', 18),
                'minerEventIcon': getTargetSVG('#8b5cf6', 18),
                'tabGoldIcon': getStarSVG('#1a1a2e', 16),
                'goldSummonIcon': getStarSVG('#ffd700', 18)
            };
            for (const [id, svg] of Object.entries(iconMap)) {
                const el = document.getElementById(id);
                if (el) el.innerHTML = svg;
            }
        }

        // Simple event logging helper (shows messages in Events -> Event Log)
        function addEventLog(msg) {
            try {
                // Keep an in-memory event log, but do NOT render to DOM. Only write to console.
                gameState.eventLog = gameState.eventLog || [];
                const time = (new Date()).toLocaleTimeString();
                const entry = `${time} ${msg}`;
                gameState.eventLog.push(entry);
                if (gameState.eventLog.length > 100) gameState.eventLog.shift();
                // Only log to console (developer-visible). Do not touch DOM.
                try { console.log(entry); } catch (e) {}
            } catch (e) { console.warn('addEventLog error', e); }
        }

        function updateBuyNextClassBtn() {
            const btn = document.getElementById('buyNextClassBtn');
            if (!btn) return;
            const nextClass = getNextLockedClass();
            if (!nextClass) {
                btn.textContent = 'All Classes Unlocked!';
                btn.disabled = true;
                btn.style.display = 'inline-block';
            } else {
                btn.textContent = 'Unlock ' + nextClass.charAt(0).toUpperCase() + nextClass.slice(1) + ' (' + CLASS_UNLOCK_COST.toLocaleString() + ' coins)';
                btn.disabled = gameState.coins < CLASS_UNLOCK_COST;
                btn.style.display = 'inline-block';
            }
        }

        // ---------- Summon screen logic ----------
        const summonColors = {
            electric: 0xffff66, fire: 0xff704d, pierce: 0x8b4513, engineer: 0xffb86b,
            life: 0xff3b3b, summoner: 0x9b5cff, water: 0x4fd1ff, miner: 0xc0c6ff,
            thief: 0x94a3b8, trapper: 0xfbbf24
        };

        let summonCtx = null;

        function showSummonScreen() {
            console.log('[Summon] showSummonScreen called');
            // refresh summon buttons when opening
            if(typeof updateSummonButtons === 'function') updateSummonButtons();
            const s = document.getElementById('summonScreen');
            // Ensure overlay is last in the document so it renders above other stacking contexts
            try {
                if (s && s.parentElement !== document.body) document.body.appendChild(s);
                // also re-append to ensure last child
                document.body.appendChild(s);
            } catch (e) { console.warn('[Summon] reappend overlay failed', e); }
            // Force visible
            s.style.display = 'flex';
            s.style.position = 'fixed';
            s.style.inset = '0';
            s.style.zIndex = '2147483647';
            s.style.background = 'rgba(0,0,0,0.6)';
            s.style.backdropFilter = 'none';
            s.style.pointerEvents = 'auto';
            // keep original inner styles (no debug override)
            try {
                const inner = s.firstElementChild;
                if (inner) {
                    inner.style.position = inner.style.position || 'relative';
                    inner.style.pointerEvents = inner.style.pointerEvents || 'auto';
                }
            } catch (e) { console.warn('[Summon] ensure inner defaults failed', e); }
            // Delay init slightly so container has layout size when renderer is created
            updateShardProgressList();
            updateSummonButtons();
            setTimeout(() => {
                try { initSummonScene(); console.log('[Summon] initSummonScene executed'); } catch (e) { console.error('[Summon] init error', e); }
            }, 60);
        }

        function closeSummonScreen() {
            document.getElementById('summonScreen').style.display = 'none';
            disposeSummonScene();
            document.getElementById('summonResult').textContent = '';
        }

        // ========== EVENTS SCREEN ==========
        function showEventsScreen() {
            const s = document.getElementById('eventsScreen');
            if (s) {
                s.style.display = 'flex';
                updateFireQuestUI();
                try { updateMinerQuestUI(); } catch (e) {}
            }
        }

        function closeEventsScreen() {
            const s = document.getElementById('eventsScreen');
            if (s) s.style.display = 'none';
        }

        function updateFireQuestUI() {
            const listEl = document.getElementById('fireQuestList');
            const countEl = document.getElementById('fireQuestCount');
            const barEl = document.getElementById('fireQuestBar');
            const rewardEl = document.getElementById('fireQuestReward');
            if (!listEl) return;

            const fireAlreadyUnlocked = unlockedClasses.includes('fire');
            let completedCount = 0;
            let html = '';
            fireQuests.forEach(q => {
                const currentVal = questStats[q.stat] || 0;
                const progress = Math.min(currentVal, q.target);
                const pct = Math.min(100, (progress / q.target) * 100);
                const done = progress >= q.target;

                // mark claimable when progress reached, but do not mark completed or award until player claims
                if (done && !q.completed && !q.claimable) {
                    q.claimable = true;
                }
                if (q.completed) completedCount++;

                // Show claim button if completed but not yet rewarded
                html += `<div style="background:rgba(255,255,255,0.05); border-radius:8px; padding:12px; border-left:4px solid ${done ? '#4ade80' : '#ef4444'};">
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px;">
                        <span style="color:#fff; font-weight:600;">${q.title}</span>
                        <div style="display:flex; align-items:center; gap:8px;">
                            <span style="color:${done ? '#4ade80' : '#f97316'}; font-weight:700; font-size:14px;">${done ? getCheckSVG('#4ade80', 14) + ' Completed' : progress + ' / ' + q.target}</span>
                            ${q.claimable && !q.rewardGiven ? `<button onclick="claimFireQuest(${q.id})" style=\"margin-left:8px; padding:6px 8px; border-radius:8px; background:#8b5cf6; color:#fff; border:0; cursor:pointer;\">Claim</button>` : ''}
                        </div>
                    </div>
                    <p style="color:#aaa; margin:0 0 8px 0; font-size:13px;">${q.description}</p>
                    <div style="background:rgba(0,0,0,0.4); border-radius:6px; height:8px; overflow:hidden;">
                        <div style="height:100%; background:${done ? '#4ade80' : 'linear-gradient(90deg,#ef4444,#f97316)'}; width:${pct}%; transition:width 0.3s ease;"></div>
                    </div>
                </div>`;
            });
            listEl.innerHTML = html;

            if (countEl) countEl.textContent = completedCount + ' / 10';
            if (barEl) barEl.style.width = (completedCount * 10) + '%';

            // Milestone: show milestone claim UI at 5 completed (claimed) quests
            const halfEl = document.getElementById('fireQuestHalfReward');
            if (completedCount >= 5 && !fireQuestHalfRewardClaimed) {
                if (halfEl) halfEl.style.display = 'block';
            }

            // All quests complete â€” show final reward banner so player can claim
            if (completedCount >= 10 && !fireQuestRewardClaimed) {
                if (rewardEl) rewardEl.style.display = 'block';
            }
        }

        // Miner quest UI
        function updateMinerQuestUI() {
            const listEl = document.getElementById('minerQuestList');
            if (!listEl) return;
            let html = '';
            let completedCount = 0;
            minerQuests.forEach(q => {
                const currentVal = questStats[q.stat] || 0;
                const progress = Math.min(currentVal, q.target);
                const done = progress >= q.target;
                // mark claimable but do not auto-award â€” require player to claim
                if (done && !q.completed && !q.claimable) {
                    q.claimable = true;
                }
                if (q.completed) completedCount++;
                const statusText = q.completed ? 'Completed' : (progress + ' / ' + q.target);
                html += `<div style="background:rgba(255,255,255,0.03); border-radius:8px; padding:10px 10px 10px 14px; display:flex; justify-content:space-between; align-items:center; border-left:4px solid #8b5cf6;"><div><div style="font-weight:600; color:#fff;">${q.title}</div><div style="color:#aaa; font-size:13px;">${q.description}</div></div><div style="display:flex; align-items:center; gap:8px;"><div style=\"font-weight:700; color:${q.completed ? '#4ade80' : '#f97316'};\">${statusText}</div> ${q.claimable && !q.rewardGiven ? `<button onclick="claimMinerQuest(${q.id})" style=\"margin-left:8px; padding:6px 8px; border-radius:8px; background:#8b5cf6; color:#fff; border:0; cursor:pointer;\">Claim</button>` : ''}</div></div>`;
            });
            listEl.innerHTML = html;
        }

        // Claim handlers for quests
        function claimFireQuest(id) {
            const q = fireQuests.find(x => x.id === id);
            if (!q || q.rewardGiven) return;
            const fireAlreadyUnlocked = unlockedClasses.includes('fire');
            if (fireAlreadyUnlocked) {
                gameState.freeBasicSummons = (gameState.freeBasicSummons || 0) + 1;
                q.rewardGiven = 'summon';
                q.completed = true;
                q.claimable = false;
                try { addEventLog('{events} added 1 free basic summon'); } catch(e){}
            } else {
                classShards['fire'] = (classShards['fire'] || 0) + 20;
                saveClassShards();
                q.rewardGiven = 'shards';
                q.completed = true;
                q.claimable = false;
                try { addEventLog('{events} added 20 fire shards'); } catch(e){}
                if (classShards['fire'] >= SHARDS_TO_UNLOCK && !unlockedClasses.includes('fire')) {
                    unlockedClasses.push('fire');
                    saveUnlockedClasses();
                    updateClassCardLockState();
                }
            }
            try { if (typeof updateShardProgressList === 'function') updateShardProgressList(); } catch(e){}
            try { updateFireQuestUI(); } catch(e){}
            try { updateSummonButtons(); } catch(e){}
            try { saveQuestState(); } catch (e) {}
            try { updateClassCardLockState(); } catch (e) {}
        }

        function claimFireHalf() {
            if (fireQuestHalfRewardClaimed) return;
            fireQuestHalfRewardClaimed = true;
            gameState.freeBasicSummons = (gameState.freeBasicSummons || 0) + 1;
            try { addEventLog('{events} awarded 1 free basic summon (5-quest milestone)'); } catch(e){}
            try { updateSummonButtons(); } catch(e){}
            try { updateFireQuestUI(); } catch(e){}
            try { saveQuestState(); } catch (e) {}
            try { updateClassCardLockState(); } catch (e) {}
        }

        function claimFireFinal() {
            if (fireQuestRewardClaimed) return;
            fireQuestRewardClaimed = true;
            if (!unlockedClasses.includes('fire')) {
                unlockedClasses.push('fire');
                saveUnlockedClasses();
                updateClassCardLockState();
            }
            if (!freeGoldSummonAwarded) {
                freeGoldSummonAwarded = true;
                gameState.freeGoldSummons = (gameState.freeGoldSummons || 0) + 1;
            }
            try { addEventLog('{events} unlocked Fire and awarded 1 free Gold Summon'); } catch(e){}
            try { updateSummonButtons(); } catch(e){}
            try { updateFireQuestUI(); } catch(e){}
            try { saveQuestState(); } catch (e) {}
            try { updateClassCardLockState(); } catch (e) {}
        }

        function claimMinerQuest(id) {
            const q = minerQuests.find(x => x.id === id);
            if (!q || q.rewardGiven) return;
            classShards['miner'] = (classShards['miner'] || 0) + (q.reward || 0);
            saveClassShards();
            q.rewardGiven = 'shards';
            q.completed = true;
            q.claimable = false;
            try { addEventLog(`{events} added ${q.reward || 0} miner shards`); } catch(e){}
            if (classShards['miner'] >= SHARDS_TO_UNLOCK && !unlockedClasses.includes('miner')) {
                unlockedClasses.push('miner');
                saveUnlockedClasses();
                updateClassCardLockState();
            }
            try { if (typeof updateShardProgressList === 'function') updateShardProgressList(); } catch(e) {}
            try { updateMinerQuestUI(); } catch(e) {}
            try { saveQuestState(); } catch (e) {}
            try { updateClassCardLockState(); } catch (e) {}
        }

        // Track quest progress - call after relevant events
        function trackQuestProgress(stat, value) {
            if (stat === 'highestWave') {
                questStats.highestWave = Math.max(questStats.highestWave || 1, value);
            } else {
                questStats[stat] = (questStats[stat] || 0) + value;
            }
            try { updateFireQuestUI(); } catch (e) {}
            try { updateMinerQuestUI(); } catch (e) {}
            try { saveQuestState(); } catch (e) {}
        }

        function updateSummonLockedList() {
            const list = document.getElementById('summonLockedList');
            if (!list) return;
            const remaining = classOrder.filter(c => !unlockedClasses.includes(c));
            list.innerHTML = remaining.length ? remaining.map(c => `<li>${c.charAt(0).toUpperCase()+c.slice(1)}</li>`).join('') : '<li>All unlocked</li>';
        }

        function initSummonScene() {
            if (summonCtx) return; // already initialized
            const container = document.getElementById('summonCanvasContainer');
            if (!container) {
                const err = document.getElementById('summonError');
                if (err) { err.style.display = 'block'; err.textContent = 'Summon scene error: missing container'; }
                console.error('[Summon] init failed: missing container');
                return;
            }

            const width = container.clientWidth;
            const height = container.clientHeight;
            console.log('[Summon] initSummonScene container size', width, height);
            if (width < 20 || height < 20) {
                const err = document.getElementById('summonError');
                if (err) {
                    err.style.display = 'block';
                    err.textContent = 'Summon scene error: container too small (' + width + 'x' + height + ')';
                }
                console.error('[Summon] container too small', width, height);
                return;
            }

            const sceneS = new THREE.Scene();
            sceneS.background = new THREE.Color(0x04101a);
            const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.set(0, 6, 14);
            camera.lookAt(0, 0, 0);

            const rendererS = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            rendererS.setSize(width, height);
            container.innerHTML = '';
            container.appendChild(rendererS.domElement);
            try {
                console.log('[Summon] canvas size after append', rendererS.domElement.clientWidth, rendererS.domElement.clientHeight);
                rendererS.domElement.style.visibility = 'visible';
                // restore clear color to scene background
                if (typeof rendererS.setClearColor === 'function') rendererS.setClearColor(0x04101a, 1);
            } catch (e) { console.warn('[Summon] post-append restore failed', e); }
            // Ensure the canvas fills the container and is visible
            try {
                container.style.position = container.style.position || 'relative';
                rendererS.domElement.style.display = 'block';
                rendererS.domElement.style.width = '100%';
                rendererS.domElement.style.height = '100%';
                rendererS.domElement.style.position = 'relative';
                rendererS.domElement.style.zIndex = '5';
                console.log('[Summon] appended canvas, set styles');
            } catch (e) { console.warn('[Summon] style set failed', e); }

            // Handle container resize to keep renderer in sync
            const resizeObserver = new ResizeObserver(() => {
                try {
                    const w = container.clientWidth || Math.max(1, Math.round(window.innerWidth * 0.5));
                    const h = container.clientHeight || Math.max(1, Math.round(window.innerHeight * 0.4));
                    rendererS.setSize(w, h);
                    if (summonCtx && summonCtx.camera) summonCtx.camera.aspect = w / h;
                    if (summonCtx && summonCtx.camera) summonCtx.camera.updateProjectionMatrix();
                } catch (err) { console.warn('[Summon] resizeObserver failed', err); }
            });
            try { resizeObserver.observe(container); } catch (e) { /* ignore */ }

            const ambient = new THREE.AmbientLight(0xffffff, 0.6);
            sceneS.add(ambient);
            const dir = new THREE.DirectionalLight(0xffffff, 0.6);
            dir.position.set(5, 10, 7);
            sceneS.add(dir);

            // podium
            const podiumGeo = new THREE.BoxGeometry(4, 1, 2.6);
            const podiumMat = new THREE.MeshStandardMaterial({ color: 0x222238, metalness: 0.3, roughness: 0.6 });
            const podium = new THREE.Mesh(podiumGeo, podiumMat);
            podium.position.set(0, -0.5, 0);
            sceneS.add(podium);

            // floor reflection plane
            const planeGeo = new THREE.CircleGeometry(20, 32);
            const planeMat = new THREE.MeshBasicMaterial({ color: 0x030612 });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -1;
            sceneS.add(plane);

            const clock = { prev: performance.now() };

            summonCtx = { scene: sceneS, camera, renderer: rendererS, podium, animating: false, fallingMesh: null, raf: null, clock };

            // no debug test mesh added in production

            function renderLoop() {
                const now = performance.now();
                const dt = (now - summonCtx.clock.prev) / 1000;
                summonCtx.clock.prev = now;

                // simple physics update for falling mesh
                if (summonCtx.animating && summonCtx.fallingMesh) {
                    const fm = summonCtx.fallingMesh;
                    if (!fm.userData.v) fm.userData.v = 0;
                    fm.userData.v -= 9.8 * dt * 4; // gravity multiplier
                    fm.position.y += fm.userData.v * dt;
                    if (fm.position.y <= 0.5) {
                        fm.position.y = 0.5;
                        summonCtx.animating = false;
                        // settle and pop text
                        showSummonNameOverlay(fm.userData.className, fm.userData.shardAmount);
                        // small bounce
                        fm.userData.v = -fm.userData.v * 0.15;
                    }
                }

                summonCtx.renderer.render(summonCtx.scene, summonCtx.camera);
                summonCtx.raf = requestAnimationFrame(renderLoop);
            }
            summonCtx.raf = requestAnimationFrame(renderLoop);
        }

        function disposeSummonScene() {
            if (!summonCtx) return;
            try {
                cancelAnimationFrame(summonCtx.raf);
            } catch (e) {}
            try { summonCtx.renderer.domElement.remove(); } catch (e) {}
            summonCtx = null;
        }

        function showSummonNameOverlay(className, shardAmount) {
            const result = document.getElementById('summonResult');
            if (!result) return;
            const title = className.charAt(0).toUpperCase() + className.slice(1);
            if (typeof shardAmount === 'number') {
                result.innerHTML = getShardSVG(summonColors[className] ? '#' + summonColors[className].toString(16).padStart(6,'0') : '#a78bfa', 20) + ' <strong>+' + shardAmount + '</strong> ' + title + ' Shards!';
            } else {
                result.textContent = title + ' summoned!';
            }
        }

        function doSummon() {
            console.log('[Summon] doSummon called', { coins: gameState && gameState.coins, firstSummonDone, tab: currentSummonTab });
            // Ensure scene exists if possible
            if (!summonCtx) {
                try { initSummonScene(); } catch (e) { console.warn('[Summon] init before summon failed', e); }
            }

            // Check if all classes already unlocked
            const allUnlocked = classOrder.every(c => unlockedClasses.includes(c));
            if (allUnlocked) { alert('All classes unlocked!'); return; }

            let shardAmount = 0;
            let isFree = false;
            const isGold = currentSummonTab === 'gold';

            if (isGold) {
                // Gold summon: first one free, otherwise costs GOLD_SUMMON_COST
                if (!firstSummonDone) {
                    // Free first Gold summon: 75% 50 shards, 25% 100 shards
                    shardAmount = Math.random() < 0.75 ? 50 : 100;
                    isFree = true;
                    firstSummonDone = true;
                    saveFirstSummonDone();
                } else {
                    if (gameState.coins < GOLD_SUMMON_COST) { alert('Not enough coins! Need ' + GOLD_SUMMON_COST.toLocaleString() + ' coins.'); return; }
                    gameState.coins -= GOLD_SUMMON_COST;
                    shardAmount = Math.random() < 0.75 ? 50 : 100;
                }
            } else {
                // Basic summon: costs SHARD_SUMMON_COST, 5-30 shards
                // Check for free basic summons from quest rewards
                if (gameState.freeBasicSummons && gameState.freeBasicSummons > 0) {
                    gameState.freeBasicSummons--;
                    isFree = true;
                } else {
                    if (gameState.coins < SHARD_SUMMON_COST) { alert('Not enough coins! Need ' + SHARD_SUMMON_COST + ' coins.'); return; }
                    gameState.coins -= SHARD_SUMMON_COST;
                }
                shardAmount = Math.floor(Math.random() * 26) + 5;
            }
            updateCoinDisplay();

            // Pick a random class (including locked ones) to receive shards
            const eligibleClasses = classOrder.filter(c => !unlockedClasses.includes(c));
            // If all unlocked, can still summon but shards go to a random class (overflow/bonus)
            const targetClasses = eligibleClasses.length > 0 ? eligibleClasses : classOrder;
            const picked = targetClasses[Math.floor(Math.random() * targetClasses.length)];
            console.log('[Summon] picked', picked, 'shards', shardAmount);

            // Add shards
            classShards[picked] = (classShards[picked] || 0) + shardAmount;
            let didUnlock = false;
            if (classShards[picked] >= SHARDS_TO_UNLOCK && !unlockedClasses.includes(picked)) {
                // Unlock the class!
                unlockedClasses.push(picked);
                saveUnlockedClasses();
                didUnlock = true;
                console.log('[Summon] unlocked via shards', picked);
            }
            saveClassShards();

            // Try to create falling shard mesh if WebGL scene exists
            let usedThree = false;
            try {
                if (summonCtx && summonCtx.scene) {
                    const color = summonColors[picked] || 0xa78bfa;
                    // Create a shard-shaped mesh (octahedron)
                    const geo = new THREE.OctahedronGeometry(1.2, 0);
                    const mat = new THREE.MeshStandardMaterial({ color: color, emissive: color, emissiveIntensity: 0.25, flatShading: true });
                    const shard = new THREE.Mesh(geo, mat);
                    shard.position.set(0, 12, 0);
                    shard.userData = { className: picked, v: 0, shardAmount: shardAmount };
                    summonCtx.scene.add(shard);
                    summonCtx.fallingMesh = shard;
                    summonCtx.animating = true;
                    usedThree = true;
                }
            } catch (e) {
                console.warn('[Summon] three falling mesh failed', e);
                usedThree = false;
            }

            // Fallback: create a simple visible HTML animation if Three.js isn't usable
            if (!usedThree) {
                const container = document.getElementById('summonCanvasContainer');
                if (container) {
                    const prev = container.querySelector('.summon-fallback');
                    if (prev) prev.remove();

                    const fb = document.createElement('div');
                    fb.className = 'summon-fallback';
                    fb.style.cssText = 'position:absolute; left:50%; transform:translateX(-50%); top:-120px; width:80%; max-width:420px; padding:18px; background:linear-gradient(90deg,#a78bfa,#7c3aed); color:#fff; font-weight:900; font-size:20px; border-radius:12px; text-align:center; box-shadow:0 10px 40px rgba(0,0,0,0.5);';
                    fb.innerHTML = getShardSVG('#fff', 28) + ' +' + shardAmount + ' ' + picked.charAt(0).toUpperCase() + picked.slice(1) + ' Shards!';
                    container.appendChild(fb);

                    let top = -120;
                    const target = 120;
                    fb._anim = setInterval(() => {
                        top += 18;
                        fb.style.top = top + 'px';
                        if (top >= target) {
                            clearInterval(fb._anim);
                            setTimeout(() => { fb.remove(); }, 1400);
                        }
                    }, 30);
                }
            }

            // Show result text
            const resultEl = document.getElementById('summonResult');
            if (resultEl) {
                let msg = getShardSVG(summonColors[picked] ? '#' + summonColors[picked].toString(16).padStart(6,'0') : '#a78bfa', 22) + ' <strong>+' + shardAmount + '</strong> ' + picked.charAt(0).toUpperCase() + picked.slice(1) + ' Shards';
                if (didUnlock) msg += '<br><span style="color:#4ade80; font-weight:800;">CLASS UNLOCKED!</span>';
                if (isFree) msg = '<span style="color:#ffd47a;">[First Summon Bonus!]</span> ' + msg;
                resultEl.innerHTML = msg;
            }

            // After animation finishes, update UI
            const poll = setInterval(() => {
                const animating = summonCtx ? !!summonCtx.animating : false;
                if (animating) return;
                clearInterval(poll);
                updateClassCardLockState();
                updateBuyNextClassBtn();
                updateShardProgressList();
                if (typeof updateSummonButtons === 'function') updateSummonButtons();
            }, 200);
        }

            // Fast shard summon without animation for bulk summons
            function fastShardSummonOnce(isGold){
                // Exclude 'fire' from summon pool - fire is unlocked via quests only
                const eligibleClasses = classOrder.filter(c => !unlockedClasses.includes(c) && c !== 'fire');
                const targetClasses = eligibleClasses.length > 0 ? eligibleClasses : classOrder.filter(c => c !== 'fire');
                const picked = targetClasses[Math.floor(Math.random() * targetClasses.length)];
                const shardAmount = isGold ? (Math.random() < 0.75 ? 50 : 100) : (Math.floor(Math.random() * 26) + 5);
                classShards[picked] = (classShards[picked] || 0) + shardAmount;
                let didUnlock = false;
                if (classShards[picked] >= SHARDS_TO_UNLOCK && !unlockedClasses.includes(picked)) {
                    unlockedClasses.push(picked);
                    saveUnlockedClasses();
                    didUnlock = true;
                }
                saveClassShards();
                return { className: picked, shards: shardAmount, unlocked: didUnlock };
            }

            // Multi-summon: aggregates results (no animation)
            function doSummonMultiple(count){
                count = Math.max(1, Math.floor(count));
                const isGold = currentSummonTab === 'gold';
                const cost = isGold ? GOLD_SUMMON_COST : SHARD_SUMMON_COST;
                let coins = gameState.coins || 0;
                const results = [];
                for(let i=0;i<count;i++){
                    // First Gold summon bonus applies only once (on Gold tab)
                    if (isGold && !firstSummonDone && i === 0) {
                        // Exclude 'fire' from summon pool - fire is unlocked via quests only
                        const eligibleClasses = classOrder.filter(c => !unlockedClasses.includes(c) && c !== 'fire');
                        const targetClasses = eligibleClasses.length > 0 ? eligibleClasses : classOrder.filter(c => c !== 'fire');
                        const picked = targetClasses[Math.floor(Math.random() * targetClasses.length)];
                        const freeShards = Math.random() < 0.75 ? 50 : 100;
                        classShards[picked] = (classShards[picked] || 0) + freeShards;
                        let didUnlock = false;
                        if (classShards[picked] >= SHARDS_TO_UNLOCK && !unlockedClasses.includes(picked)) {
                            unlockedClasses.push(picked);
                            saveUnlockedClasses();
                            didUnlock = true;
                        }
                        saveClassShards();
                        firstSummonDone = true;
                        saveFirstSummonDone();
                        results.push({ className: picked, shards: freeShards, unlocked: didUnlock, free: true });
                        continue;
                    }
                    if(coins < cost){
                        results.push({ error: 'Not enough coins' });
                        break;
                    }
                    coins -= cost;
                    results.push(fastShardSummonOnce(isGold));
                }
                gameState.coins = coins;
                // aggregate messages
                const shardTotals = {};
                const unlockedList = [];
                results.forEach(r => {
                    if (r.className) {
                        shardTotals[r.className] = (shardTotals[r.className] || 0) + r.shards;
                        if (r.unlocked) unlockedList.push(r.className);
                    }
                });
                let summary = Object.entries(shardTotals).map(([c, s]) => '+' + s + ' ' + c.charAt(0).toUpperCase() + c.slice(1)).join(', ');
                if (unlockedList.length) summary += '<br><span style="color:#4ade80; font-weight:800;">Unlocked: ' + unlockedList.map(u=>u.charAt(0).toUpperCase()+u.slice(1)).join(', ') + '</span>';
                const el = document.getElementById('summonResult');
                if(el) el.innerHTML = summary || 'No results';
                updateCoinDisplay();
                updateClassCardLockState();
                updateBuyNextClassBtn();
                updateShardProgressList();
                if(typeof updateSummonButtons === 'function') updateSummonButtons();
            }

            // Update summon buttons to show shard cost based on current tab
            function updateSummonButtons(){
                const btn = document.getElementById('doSummonBtn');
                const btn10 = document.getElementById('doSummon10Btn');
                if(!btn) return;
                const coins = gameState.coins || 0;
                const isGold = currentSummonTab === 'gold';
                const cost = isGold ? GOLD_SUMMON_COST : SHARD_SUMMON_COST;
                const color = isGold ? '#ffd700' : '#a78bfa';
                const freeBasic = (gameState.freeBasicSummons || 0);

                if(isGold && !firstSummonDone){
                    btn.innerHTML = getStarSVG('#1a1a2e', 16) + ' First Gold Summon (FREE!)';
                    btn.style.background = 'linear-gradient(90deg,#ffd700,#ffb347)';
                    btn.disabled = false;
                } else if(!isGold && freeBasic > 0){
                    // Free basic summon from quest rewards
                    btn.innerHTML = getShardSVG(color, 18) + ' Summon (FREE! ' + freeBasic + ' left)';
                    btn.style.background = 'linear-gradient(90deg,#4ade80,#22d3ee)';
                    btn.disabled = false;
                } else {
                    const label = isGold ? getStarSVG(color, 16) + ' Gold Summon' : 'Summon';
                    btn.innerHTML = getShardSVG(color, 18) + ' ' + label + ' (' + cost.toLocaleString() + ' coins)';
                    btn.style.background = isGold ? 'linear-gradient(90deg,#ffd700,#ffb347)' : 'linear-gradient(90deg,#ffd47a,#ff80c4)';
                    btn.disabled = coins < cost;
                }
                if(btn10){
                    const cost10 = (isGold && !firstSummonDone) ? cost * 9 : cost * 10;
                    const label10 = isGold ? getStarSVG(color, 16) + ' x10' : 'x10';
                    btn10.innerHTML = getShardSVG(color, 18) + ' ' + label10 + ' (' + cost10.toLocaleString() + ' coins)';
                    btn10.style.background = isGold ? 'linear-gradient(90deg,#ffd700,#ffb347)' : 'linear-gradient(90deg,#ffd47a,#ff80c4)';
                    btn10.disabled = coins < (isGold && !firstSummonDone ? 0 : cost);
                }
            }

            // Update shard progress list in summon UI
            function updateShardProgressList() {
                const container = document.getElementById('shardProgressList');
                if (!container) return;
                let html = '';
                classOrder.forEach(c => {
                    const shards = classShards[c] || 0;
                    const unlocked = unlockedClasses.includes(c);
                    const pct = Math.min(100, Math.round((shards / SHARDS_TO_UNLOCK) * 100));
                    const color = summonColors[c] ? '#' + summonColors[c].toString(16).padStart(6, '0') : '#a78bfa';
                    html += '<div style="margin-bottom:6px; display:flex; align-items:center; gap:8px;">';
                    html += '<span style="color:' + color + '; font-weight:600; font-size:12px; min-width:65px;">' + c.charAt(0).toUpperCase() + c.slice(1) + '</span>';
                    html += '<div style="flex:1; height:6px; background:rgba(255,255,255,0.1); border-radius:3px; overflow:hidden;">';
                    html += '<div style="height:100%; width:' + pct + '%; background:' + (unlocked ? '#4ade80' : color) + '; transition:width 0.3s;"></div>';
                    html += '</div>';
                    if (unlocked) {
                        html += '<span style="color:#4ade80; font-size:10px; font-weight:700; min-width:55px; text-align:right;">UNLOCKED</span>';
                    } else {
                        html += '<span style="color:#888; font-size:10px; min-width:55px; text-align:right;">' + shards + '/' + SHARDS_TO_UNLOCK + '</span>';
                    }
                    html += '</div>';
                });
                container.innerHTML = html;
            }

        // EXP System - Session only (no saving)
        const classExp = {
            electric: { level: 1, exp: 0, maxExp: 100, evolution: 0 },
            fire: { level: 1, exp: 0, maxExp: 100, evolution: 0 },
            pierce: { level: 1, exp: 0, maxExp: 100, evolution: 0 },
            engineer: { level: 1, exp: 0, maxExp: 100, evolution: 0 },
            life: { level: 1, exp: 0, maxExp: 100, evolution: 0 },
            summoner: { level: 1, exp: 0, maxExp: 100, evolution: 0 },
            water: { level: 1, exp: 0, maxExp: 100, evolution: 0 },
            miner: { level: 1, exp: 0, maxExp: 100, evolution: 0 },
            thief: { level: 1, exp: 0, maxExp: 100, evolution: 0 },
            trapper: { level: 1, exp: 0, maxExp: 100, evolution: 0 }
        };
        
        // Update exp displays on load
        function updateExpDisplays() {
            Object.keys(classExp).forEach(className => {
                const data = classExp[className];
                const expPercent = (data.exp / data.maxExp) * 100;
                const evolutionText = data.evolution > 0 ? ` [Evo ${data.evolution}]` : '';
                document.getElementById(`${className}-level`).textContent = `Level ${data.level}${evolutionText}`;
                document.getElementById(`${className}-exp-fill`).style.width = expPercent + '%';
                document.getElementById(`${className}-exp-text`).textContent = `${data.exp} / ${data.maxExp}`;
            });
        }
        updateExpDisplays();
        updateBuyButtons();
        updateClassCardLockState();
        updateBuyNextClassBtn();
        
        // Progression upgrades for each class
        const classUpgrades = {
            electric: [
                { level: 2, buffs: ['Q: -10% cooldown', '+5% movement speed'] },
                { level: 3, buffs: ['E: +2 extra targets', '+10 max HP'] },
                { level: 5, buffs: ['R: +50% chain range', 'Q: -15% cooldown'] },
                { level: 7, buffs: ['+10% movement speed', 'All abilities: -10% cooldown'] },
                { level: 10, buffs: ['R: Unlimited bounces increased speed', '+20 max HP', '+15% movement speed'] },
                { level: 15, buffs: ['EVOLUTION: Q creates chain explosions on each target'] }
            ],
            fire: [
                { level: 2, buffs: ['Q: +20% burn damage', '+5% movement speed'] },
                { level: 3, buffs: ['E: +50% healing', '+10 max HP'] },
                { level: 5, buffs: ['R: +1 fireball', 'Q: +1 range'] },
                { level: 7, buffs: ['+10% movement speed', 'Burn duration +2s'] },
                { level: 10, buffs: ['All fire abilities: +50% damage', '+20 max HP', 'E: -30% cooldown'] },
                { level: 15, buffs: ['EVOLUTION: R fireballs explode in massive AoE'] }
            ],
            pierce: [
                { level: 2, buffs: ['Q: +20% damage', '+5% movement speed'] },
                { level: 3, buffs: ['E: +2 arrows', '+10 max HP'] },
                { level: 5, buffs: ['R: +25% damage', 'Q: -20% cooldown'] },
                { level: 7, buffs: ['+10% movement speed', 'All piercing: +30% damage'] },
                { level: 10, buffs: ['Q: +50% damage', '+20 max HP', 'E: -40% cooldown'] },
                { level: 15, buffs: ['EVOLUTION: E shoots in 360-degree spiral'] }
            ],
            engineer: [
                { level: 2, buffs: ['Q: -15% cooldown', '+5% movement speed'] },
                { level: 3, buffs: ['Turrets: +25% HP', '+10 max HP'] },
                { level: 5, buffs: ['R: +50 ammo', 'E: -20% cooldown'] },
                { level: 7, buffs: ['+10% movement speed', 'Turrets: +50% damage'] },
                { level: 10, buffs: ['R: +100 ammo, +20% fire rate', '+20 max HP', 'Q: Max 2 turrets at once'] },
                { level: 15, buffs: ['EVOLUTION: Q spawns 3 turrets at once'] }
            ],
            life: [
                { level: 2, buffs: ['Q: +25% AoE damage', '+5% movement speed'] },
                { level: 3, buffs: ['E: +50% lifesteal', '+10 max HP'] },
                { level: 5, buffs: ['R: +10 attacks', 'Passive drain: -50%'] },
                { level: 7, buffs: ['+10% movement speed', 'All lifesteal: +25%'] },
                { level: 10, buffs: ['Q: +50 damage', '+30 max HP', 'Passive drain removed'] },
                { level: 15, buffs: ['EVOLUTION: R converts all nearby enemies to allies'] }
            ],
            summoner: [
                { level: 2, buffs: ['Minions: +25% HP', '+5% movement speed'] },
                { level: 3, buffs: ['Q: -25% cooldown', '+10 max HP'] },
                { level: 5, buffs: ['E: +1 minion', 'Minions: +50% damage'] },
                { level: 7, buffs: ['+10% movement speed', 'Minion duration +5s'] },
                { level: 10, buffs: ['R: +50 HP to guardian', '+20 max HP', 'All summons: +100% damage'] },
                { level: 15, buffs: ['EVOLUTION: E spawns ranged archers instead'] }
            ],
            water: [
                { level: 2, buffs: ['Q: +2 damage', '+5% movement speed'] },
                { level: 3, buffs: ['E: +30% knockback', '+10 max HP'] },
                { level: 5, buffs: ['R: +10 damage', 'Q: -20% cooldown'] },
                { level: 7, buffs: ['+10% movement speed', 'All abilities: +2 range'] },
                { level: 10, buffs: ['R: +5s invulnerability', '+20 max HP', 'E: -35% cooldown'] },
                { level: 15, buffs: ['EVOLUTION: E range doubled'] }
            ],
            thief: [
                { level: 2, buffs: ['Q: +3 daggers', '+10% movement speed'] },
                { level: 3, buffs: ['E: +2s invisibility', '+15 max HP'] },
                { level: 5, buffs: ['R: +50% execute threshold', 'Q: -25% cooldown'] },
                { level: 7, buffs: ['+15% movement speed', 'Q: +5 damage per dagger'] },
                { level: 10, buffs: ['E: -40% cooldown', '+25 max HP', 'R: Bomb radius +50%'] },
                { level: 15, buffs: ['EVOLUTION: R chains to 3 additional enemies'] }
            ],
            trapper: [
                { level: 2, buffs: ['Q: +1 bomb capacity', '+10 max HP'] },
                { level: 3, buffs: ['E: +1 barrier capacity', 'Barriers: +3s duration'] },
                { level: 5, buffs: ['R: +15 damage', 'Q: -30% cooldown'] },
                { level: 7, buffs: ['Bombs: +2 radius', 'Barriers: +50% slow'] },
                { level: 10, buffs: ['Q: +2 bomb capacity', '+30 max HP', 'E: -35% cooldown'] },
                { level: 15, buffs: ['EVOLUTION: R creates cluster explosions'] }
            ]
            ,
            miner: [
                { level: 2, buffs: ['Passive: +10% shovel damage', '+5% movement speed'] },
                { level: 3, buffs: ['MINE: +25% damage', '+10 max HP'] },
                { level: 5, buffs: ['DRILL: +3s duration', 'DIG: -20% cooldown'] },
                { level: 7, buffs: ['Passive: +20% shovel speed', 'MINE: +0.5 trigger radius'] },
                { level: 10, buffs: ['DRILL: +50% drill power (visual)', '+25 max HP', 'MINE: -30% cooldown'] },
                { level: 15, buffs: ['EVOLUTION: DIG teleports and plants a mine on arrival'] }
            ]
        };
        
        // View progression window
        function viewProgression(className) {
            const classData = classExp[className];
            const upgrades = classUpgrades[className];
            const title = className.charAt(0).toUpperCase() + className.slice(1);
            
            document.getElementById('progressionTitle').textContent = `${title} Progression`;
            
            let content = '';
            upgrades.forEach(upgrade => {
                // Evolution upgrades (level 15) require reaching level 15 once
                const isEvolution = upgrade.level === 15;
                const isUnlocked = isEvolution ? classData.evolution > 0 : classData.level >= upgrade.level;
                const tierClass = isUnlocked ? 'unlocked' : 'locked';
                const status = isUnlocked ? 'UNLOCKED' : `Requires Level ${upgrade.level}`;
                
                content += `
                    <div class="upgrade-tier ${tierClass}">
                        <h3>Level ${upgrade.level}${isEvolution ? ' - EVOLUTION' : ''} - ${status}</h3>
                        ${upgrade.buffs.map(buff => `<p>â€¢ ${buff}</p>`).join('')}
                    </div>
                `;
            });
            
            document.getElementById('progressionContent').innerHTML = content;
            document.getElementById('progressionWindow').style.display = 'block';
        }
        
        // Close progression window
        function closeProgression() {
            document.getElementById('progressionWindow').style.display = 'none';
        }
        
        // Duplicate gameState declaration removed â€” `gameState` is declared earlier above.

        // Quick trackers for debug of invulnerability/invisibility
        let _prevInvulnerable = gameState.isInvulnerable;
        let _prevInvisible = gameState.isInvisible;

        // Update coin display
        function updateCoinDisplay() {
            document.getElementById('coinAmount').textContent = gameState.coins;
            // update summon tokens display
            const tokenEl = document.getElementById('summonTokenDisplay');
            const tokenCountEl = document.getElementById('summonTokenCount');
            if (tokenEl && tokenCountEl) {
                const n = (gameState && gameState.summonTokens) ? gameState.summonTokens : 0;
                tokenCountEl.textContent = n;
                tokenEl.style.display = n > 0 ? 'inline-block' : 'none';
            }
            // Refresh lock/unlock UI so inline unlock buttons enable/disable correctly
            try { updateClassCardLockState(); } catch (e) {}
        }
        updateCoinDisplay();

        // Buy EXP for class (now per class card)
        function buyExp(className) {
            const data = classExp[className];
            if (!data) return;
            if (data.level >= 15) {
                alert('Class is max level!');
                return;
            }

            // Compute cost to purchase exactly enough EXP for next level
            const expNeeded = Math.max(0, data.maxExp - data.exp);
            // Ratio: 1 EXP : 4 coins => 4 coins per 1 EXP
            const cost = Math.max(4, Math.ceil(expNeeded * 4));
            if (gameState.coins < cost) {
                alert('Not enough coins!');
                return;
            }

            // Deduct coins and add the required EXP to reach next level
            gameState.coins -= cost;
            data.exp += expNeeded;

            // Level up if needed and apply bonuses
            while (data.exp >= data.maxExp && data.level < 15) {
                data.exp -= data.maxExp;
                data.level++;
                if (data.level === 15) {
                    data.evolution++;
                    data.exp = 0;
                } else {
                    data.maxExp = Math.floor(data.maxExp * 1.5);
                }
                applyClassLevelBonuses(className);
            }

            updateExpDisplays();
            updateCoinDisplay();
            updateBuyButtons();
            triggerSave(); // Save after buying EXP
        }
        
        
        // Helper: create a canvas gradient texture
        function createGradientTexture(colorHexA, colorHexB, vertical = true, size = 256) {
            const canvas = document.createElement('canvas');
            canvas.width = canvas.height = size;
            const ctx = canvas.getContext('2d');
            let grad;
            if (vertical) grad = ctx.createLinearGradient(0, 0, 0, size);
            else grad = ctx.createLinearGradient(0, 0, size, 0);
            grad.addColorStop(0, `#${colorHexA.toString(16).padStart(6, '0')}`);
            grad.addColorStop(1, `#${colorHexB.toString(16).padStart(6, '0')}`);
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, size, size);
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            // Use sRGB encoding for correct colors when used as a color map
            try { texture.encoding = THREE.sRGBEncoding; } catch (e) {}
            return texture;
        }

        // Create player (red octahedron with gradient)
        const playerGeometry = new THREE.OctahedronGeometry(0.6, 0);
        // Ensure the geometry has UVs so the gradient `map` appears correctly.
        // We generate simple spherical/linear UVs based on vertex positions.
        try {
            playerGeometry.computeBoundingBox();
            const minY = playerGeometry.boundingBox.min.y;
            const maxY = playerGeometry.boundingBox.max.y;
            const pos = playerGeometry.attributes.position;
            const uv = new Float32Array(pos.count * 2);
            for (let i = 0; i < pos.count; i++) {
                const x = pos.getX(i);
                const y = pos.getY(i);
                const z = pos.getZ(i);
                // u from azimuthal angle, v from normalized height
                const u = 0.5 + (Math.atan2(x, z) / (2 * Math.PI));
                const v = (y - minY) / Math.max(1e-6, (maxY - minY));
                uv[i * 2] = u;
                uv[i * 2 + 1] = v;
            }
            playerGeometry.setAttribute('uv', new THREE.BufferAttribute(uv, 2));
        } catch (e) { console.warn('Failed to generate UVs for player geometry', e); }
        // Base color for original solid color player
        const baseColor = 0xff3b3b;
        // Accent/fallback color used when restoring player gradient on restart
        const accentColor = 0xff6b6b;
        const playerMaterial = new THREE.MeshStandardMaterial({ 
            color: baseColor,
            emissive: baseColor,
            emissiveIntensity: 0.08,
            metalness: 0.5,
            roughness: 0.3
        });
        const player = new THREE.Mesh(playerGeometry, playerMaterial);
        player.userData.rotationSpeed = 0.02;
        // Collision radius for solidity
        player.userData.collisionRadius = 0.9;
        scene.add(player);
        gameState.player = player;
        
        // Add player glow ring
        const glowRing = new THREE.Mesh(
            new THREE.RingGeometry(0.8, 1, 32),
            new THREE.MeshBasicMaterial({ 
                color: 0xff3b3b, 
                transparent: true, 
                opacity: 0.3,
                side: THREE.DoubleSide
            })
        );
        glowRing.position.z = -0.1;
        player.add(glowRing);
        
        // Create arena floor - large enough to cover screen
        const floorGeometry = new THREE.PlaneGeometry(200, 200);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x1a1a2e,
            transparent: true,
            opacity: 0.5
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.position.z = -0.5;
        scene.add(floor);
        
        // Add grid - spans entire screen
        const gridHelper = new THREE.GridHelper(200, 100, 0x333355, 0x222244);
        gridHelper.rotation.x = Math.PI / 2;
        gridHelper.position.z = -0.49;
        scene.add(gridHelper);
        
        // Initialize managers
        const hpManager = new HPManager(player, 100);
        const effectsManager = new EffectsManager(scene);
        const movementManager = new MovementManager(player, 0.15);
        
        // Helper function to check if enemy is visible on screen
        function isEnemyOnScreen(enemy) {
            // Get screen bounds based on orthographic camera
            const screenWidth = window.innerWidth / 40;
            const screenHeight = window.innerHeight / 40;
            
            // Check if enemy is within visible bounds (with small margin)
            return enemy.position.x >= -screenWidth - 2 && 
                   enemy.position.x <= screenWidth + 2 && 
                   enemy.position.y >= -screenHeight - 2 && 
                   enemy.position.y <= screenHeight + 2;
        }

        

        // More strict check: enemy fully on-screen (entire collision radius inside view)
        function isEnemyFullyOnScreen(enemy) {
            if (!enemy || !enemy.userData) return false;
            const radius = (enemy.userData.collisionRadius) ? enemy.userData.collisionRadius : 1;
            const screenWidth = window.innerWidth / 40;
            const screenHeight = window.innerHeight / 40;
            return (enemy.position.x - radius) >= -screenWidth &&
                   (enemy.position.x + radius) <= screenWidth &&
                   (enemy.position.y - radius) >= -screenHeight &&
                   (enemy.position.y + radius) <= screenHeight;
        }

        // Create screen-space HP UI for an enemy (only call when fully on-screen)
        function createEnemyHPUI(enemy) {
            try {
                if (!enemy) return;
                let layer = document.getElementById('enemyHpLayer');
                if (!layer) { layer = document.createElement('div'); layer.id = 'enemyHpLayer'; document.body.appendChild(layer); }
                const hpEl = document.createElement('div');
                hpEl.className = 'enemy-hp';
                const radius = (enemy.userData && enemy.userData.collisionRadius) ? enemy.userData.collisionRadius : 1;
                const fullWidthPx = Math.max(36, Math.round(40 * radius + 40));
                hpEl.style.width = (fullWidthPx) + 'px';
                hpEl.innerHTML = '<div class="bar-bg"><div class="bar-fg"></div></div>';
                layer.appendChild(hpEl);
                enemy.userData.hpUI = { el: hpEl, fullWidth: fullWidthPx, radius };
            } catch (e) { console.warn('Failed to create hp UI', e); }
        }

        // Track last mouse world position for mouse-targeted abilities
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const groundPlane = new THREE.Plane(new THREE.Vector3(0,0,1), 0);
        const lastMouseWorld = new THREE.Vector3();
        // Last clicked world position (set on pointerdown) and visible marker
        let lastClickWorld = null;
        const lastClickMarker = new THREE.Mesh(
            new THREE.RingGeometry(0.4, 0.6, 32),
            new THREE.MeshBasicMaterial({ color: 0xffcc00, side: THREE.DoubleSide })
        );
        lastClickMarker.rotation.x = Math.PI / 2;
        lastClickMarker.position.z = 0.02;
        lastClickMarker.visible = false;
        scene.add(lastClickMarker);

        function setLastClickMarker(pos) {
            if (!pos) return;
            if (!lastClickWorld) lastClickWorld = new THREE.Vector3();
            lastClickWorld.copy(pos);
            lastClickMarker.position.x = pos.x;
            lastClickMarker.position.y = pos.y;
            lastClickMarker.visible = true;
        }

        function clearLastClickMarker() {
            lastClickWorld = null;
            lastClickMarker.visible = false;
        }

        // Track clicks to set the last-click world position
        window.addEventListener('pointerdown', (e) => {
            pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const hit = new THREE.Vector3();
            if (raycaster.ray.intersectPlane(groundPlane, hit)) {
                setLastClickMarker(hit);
            }
        });
        window.addEventListener('mousemove', (e) => {
            pointer.x = (e.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            raycaster.ray.intersectPlane(groundPlane, lastMouseWorld);
        });
        
        // Enemy creation
        function createEnemy(forceBoss = false) {
            // Boss spawning - rare chance, higher on boss waves
            let isBoss = forceBoss || (gameState.currentWave % 5 === 0 && Math.random() < 0.15) || (Math.random() < 0.03);
            // Disallow boss (yellow) before wave 3 and cap to 1 per wave
            if (isBoss) {
                if (gameState.currentWave < 3 || gameState.yellowSpawnedThisWave) {
                    isBoss = false;
                } else {
                    gameState.yellowSpawnedThisWave = true;
                }
            }
            
            // New enemy types for later waves
            const canSpawnInvisible = gameState.currentWave >= 5;
            const canSpawnSpeed = gameState.currentWave >= 3;
            
            // Weighted spawn chances including new enemy types for later waves
            const rand = Math.random();
            let enemyType;
            if (isBoss) {
                enemyType = 'boss';
            } else if (gameState.currentWave >= 4 && rand < 0.06) {
                enemyType = 'shield';
            } else if (gameState.currentWave >= 6 && rand < 0.11) {
                enemyType = 'healer';
            } else if (gameState.currentWave >= 6 && rand < 0.15) {
                enemyType = 'suicide';
            } else if (gameState.currentWave >= 5 && rand < 0.20) {
                enemyType = 'sniper';
            } else if (gameState.currentWave >= 7 && rand < 0.24) {
                enemyType = 'phaser';
            } else if (canSpawnInvisible && rand < 0.32) {
                enemyType = 'invisible';
            } else if (canSpawnSpeed && rand < 0.42) {
                enemyType = 'speed';
            } else if (rand < 0.50) {
                enemyType = 'ranged';
            } else if (rand < 0.65) {
                enemyType = 'tank';
            } else {
                enemyType = 'melee';
            }
            
            let enemyGeometry, enemyMaterial;
            
            // Wave scaling multiplier
            const waveScale = 1 + (gameState.currentWave - 1) * 0.15;
            
            if (enemyType === 'boss') {
                // Boss: Large dodecahedron, glowing yellow, high HP and damage
                enemyGeometry = new THREE.DodecahedronGeometry(1.2, 0);
                enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xfbbf24,
                    emissive: 0xf59e0b,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 1
                });
            } else if (enemyType === 'melee') {
                // Melee: Tetrahedron, green, fast, normal HP
                enemyGeometry = new THREE.TetrahedronGeometry(0.5, 0);
                enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x4ade80,
                    emissive: 0x22ff66,
                    emissiveIntensity: 0.2,
                    transparent: true,
                    opacity: 1
                });
            } else if (enemyType === 'ranged') {
                // Ranged: Octahedron, blue/purple, medium speed, low HP
                enemyGeometry = new THREE.OctahedronGeometry(0.4, 0);
                enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xa855f7,
                    emissive: 0x9333ea,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 1
                });
            } else if (enemyType === 'invisible') {
                // Invisible: Icosahedron, purple, semi-transparent, medium HP
                enemyGeometry = new THREE.IcosahedronGeometry(0.45, 0);
                enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8b5cf6,
                    emissive: 0x7c3aed,
                    emissiveIntensity: 0.4,
                    transparent: true,
                    opacity: 0
                });
            } else if (enemyType === 'speed') {
                // Speed: Cone, orange, very fast, low HP
                enemyGeometry = new THREE.ConeGeometry(0.4, 0.8, 4);
                enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xfb923c,
                    emissive: 0xf97316,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 1
                });
            } else {
                // Tank: Box, red, slow, high HP
                enemyGeometry = new THREE.BoxGeometry(0.7, 0.7, 0.7);
                enemyMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xef4444,
                    emissive: 0xdc2626,
                    emissiveIntensity: 0.3,
                    transparent: true,
                    opacity: 1
                });
            }
            // Additional types: shield, healer, suicide, sniper, phaser
            if (enemyType === 'shield') {
                enemyGeometry = new THREE.OctahedronGeometry(0.6, 0);
                enemyMaterial = new THREE.MeshStandardMaterial({ color: 0x93c5fd, emissive: 0x60a5fa, emissiveIntensity: 0.3 });
            } else if (enemyType === 'healer') {
                enemyGeometry = new THREE.DodecahedronGeometry(0.6, 0);
                enemyMaterial = new THREE.MeshStandardMaterial({ color: 0x34d399, emissive: 0x10b981, emissiveIntensity: 0.3 });
            } else if (enemyType === 'suicide') {
                enemyGeometry = new THREE.ConeGeometry(0.45, 0.9, 6);
                enemyMaterial = new THREE.MeshStandardMaterial({ color: 0xff7b7b, emissive: 0xff3b3b, emissiveIntensity: 0.4 });
            } else if (enemyType === 'sniper') {
                enemyGeometry = new THREE.BoxGeometry(0.6, 0.6, 0.6);
                enemyMaterial = new THREE.MeshStandardMaterial({ color: 0x6ee7b7, emissive: 0x34d399, emissiveIntensity: 0.3 });
            } else if (enemyType === 'phaser') {
                enemyGeometry = new THREE.TorusGeometry(0.5, 0.15, 8, 16);
                enemyMaterial = new THREE.MeshStandardMaterial({ color: 0x60a5fa, emissive: 0x2563eb, emissiveIntensity: 0.4 });
            }
            
            const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            
            // Spawn at random edge - just off-screen so enemies arrive quickly
            const side = Math.floor(Math.random() * 4);
            // Compute view bounds and spawn a bit outside them
            const viewWidth = window.innerWidth / 40;
            const viewHeight = window.innerHeight / 40;
            const spawnOffset = 6; // how far off-screen to spawn
            const spawnDistance = Math.max(viewWidth, viewHeight) + spawnOffset;
            const spawnSpread = Math.max(viewWidth, viewHeight) * 0.8;
            
            switch(side) {
                case 0:
                    enemy.position.set(Math.random() * spawnSpread - spawnSpread/2, spawnDistance, 0);
                    break;
                case 1:
                    enemy.position.set(spawnDistance, Math.random() * spawnSpread - spawnSpread/2, 0);
                    break;
                case 2:
                    enemy.position.set(Math.random() * spawnSpread - spawnSpread/2, -spawnDistance, 0);
                    break;
                case 3:
                    enemy.position.set(-spawnDistance, Math.random() * spawnSpread - spawnSpread/2, 0);
                    break;
            }

            if (gameState.debugAI) {
                console.log(`createEnemy: spawned type=${enemyType} id=${enemy.id} at (${enemy.position.x.toFixed(1)}, ${enemy.position.y.toFixed(1)}) spawnDistance=${spawnDistance}`);
            }
            
            // Set stats based on enemy type
            if (enemyType === 'boss') {
                // Boss HP scales with player's class level
                const playerLevel = selectedClass && classExp[Object.keys(classes).find(key => classes[key] === selectedClass)] 
                    ? classExp[Object.keys(classes).find(key => classes[key] === selectedClass)].level 
                    : 1;
                const levelScale = 1 + (playerLevel - 1) * 0.2;
                const bossHP = Math.floor(200 * waveScale * levelScale);
                
                enemy.userData = {
                    type: 'boss',
                    hp: bossHP,
                    maxHp: bossHP,
                    speed: 0.025,
                    damage: Math.floor(30 * waveScale),
                    attackCooldown: 0,
                    attackInterval: 800,
                    attackRange: 2,
                    rotationSpeed: 0.01,
                    isBoss: true,
                    collisionRadius: 2
                };
            } else if (enemyType === 'melee') {
                enemy.userData = {
                    type: 'melee',
                    hp: Math.floor(30 * waveScale),
                    maxHp: Math.floor(30 * waveScale),
                    speed: 0.03 + (gameState.currentWave * 0.001),
                    damage: Math.floor(10 * waveScale),
                    attackCooldown: 0,
                    attackInterval: 1000,
                    attackRange: 1.5,
                    rotationSpeed: 0.01 + Math.random() * 0.02
                ,collisionRadius: 0.9
                };
            } else if (enemyType === 'ranged') {
                enemy.userData = {
                    type: 'ranged',
                    hp: Math.floor(20 * waveScale),
                    maxHp: Math.floor(20 * waveScale),
                    speed: 0.02 + (gameState.currentWave * 0.0005),
                    damage: Math.floor(8 * waveScale),
                    attackCooldown: 0,
                    attackInterval: 2000,
                    attackRange: 12,
                    rotationSpeed: 0.02 + Math.random() * 0.03
                ,collisionRadius: 0.8
                };
            } else if (enemyType === 'invisible') {
                enemy.userData = {
                    type: 'invisible',
                    hp: Math.floor(25 * waveScale),
                    maxHp: Math.floor(25 * waveScale),
                    speed: 0.025 + (gameState.currentWave * 0.0008),
                    damage: Math.floor(12 * waveScale),
                    attackCooldown: 0,
                    attackInterval: 1200,
                    attackRange: 1.5,
                    rotationSpeed: 0.015 + Math.random() * 0.02,
                    invisFlashTimer: Math.random() * 1000,
                    collisionRadius: 0.8
                };
            } else if (enemyType === 'speed') {
                enemy.userData = {
                    type: 'speed',
                    hp: Math.floor(18 * waveScale),
                    maxHp: Math.floor(18 * waveScale),
                    speed: 0.05 + (gameState.currentWave * 0.0015),
                    damage: Math.floor(8 * waveScale),
                    attackCooldown: 0,
                    attackInterval: 900,
                    attackRange: 1.5,
                    rotationSpeed: 0.03 + Math.random() * 0.03
                ,collisionRadius: 0.7
                };
            } else if (enemyType === 'shield') {
                enemy.userData = { type: 'shield', hp: Math.floor(60 * waveScale), maxHp: Math.floor(60 * waveScale), speed: 0.02, damage: Math.floor(10 * waveScale), attackCooldown: 0, attackInterval: 1200, attackRange: 1.6, rotationSpeed: 0.01, shieldHits: 1, collisionRadius: 0.9 };
            } else if (enemyType === 'healer') {
                enemy.userData = { type: 'healer', hp: Math.floor(50 * waveScale), maxHp: Math.floor(50 * waveScale), speed: 0.015, damage: Math.floor(6 * waveScale), attackCooldown: 0, attackInterval: 1400, attackRange: 1.4, rotationSpeed: 0.01, healAmount: Math.floor(8 * waveScale), healInterval: 3000, lastHeal: 0, collisionRadius: 0.9 };
            } else if (enemyType === 'suicide') {
                enemy.userData = { type: 'suicide', hp: Math.floor(18 * waveScale), maxHp: Math.floor(18 * waveScale), speed: 0.025, damage: Math.floor(30 * waveScale), attackCooldown: 0, attackInterval: 900, attackRange: 1.0, rotationSpeed: 0.02, explodeRange: 3.5, explodeDamage: Math.floor(50 * waveScale), exploded: false, collisionRadius: 0.7 };
            } else if (enemyType === 'sniper') {
                enemy.userData = { type: 'sniper', hp: Math.floor(25 * waveScale), maxHp: Math.floor(25 * waveScale), speed: 0.01, damage: Math.floor(28 * waveScale), attackCooldown: 0, attackInterval: 2200, attackRange: 20, rotationSpeed: 0.005, collisionRadius: 0.8 };
            } else if (enemyType === 'phaser') {
                enemy.userData = { type: 'phaser', hp: Math.floor(45 * waveScale), maxHp: Math.floor(45 * waveScale), speed: 0.02, damage: Math.floor(12 * waveScale), attackCooldown: 0, attackInterval: 1100, attackRange: 1.6, rotationSpeed: 0.02, teleportCooldown: 4000, lastTeleport: 0, collisionRadius: 0.9 };
            } else {
                enemy.userData = { type: 'tank', hp: Math.floor(80 * waveScale), maxHp: Math.floor(80 * waveScale), speed: 0.015 + (gameState.currentWave * 0.0003), damage: Math.floor(20 * waveScale), attackCooldown: 0, attackInterval: 1500, attackRange: 1.5, rotationSpeed: 0.005 + Math.random() * 0.01, collisionRadius: 1.2 };
            }
            
            scene.add(enemy);
            // Do not create HP UI immediately; defer until enemy is fully on-screen
            enemy.userData.hpUI = null;
            // Ensure no lingering claim/target state on newly spawned enemies
            if (!enemy.userData) enemy.userData = {};
            enemy.userData.claimedBy = null;
            enemy.userData.currentTarget = null;
            gameState.enemies.push(enemy);
            if (gameState.debugAI) {
                console.log(`createEnemy: pushed enemy id=${enemy.id} claimedBy=${enemy.userData.claimedBy}`);
            }
        }
        
        // Class definitions
        const classes = {
            electric: {
                name: 'Electric',
                abilities: {
                    zap: {
                        cooldown: 3000,
                        lastUsed: 0,
                        damage: 50,
                        range: 10,
                        chainRange: 6,
                        maxChains: 3,
                        icon: 'ZAP',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            let closest = null;
                            let closestDist = Infinity;
                            
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = player.position.distanceTo(enemy.position);
                                if (dist < closestDist && dist <= this.range) {
                                    closest = enemy;
                                    closestDist = dist;
                                }
                            });
                            
                            if (closest) {
                                effectsManager.createLightningBolt(player.position, closest.position);
                                damageEnemy(closest, this.damage);
                                
                                let hitEnemies = [closest];
                                let currentSource = closest;
                                
                                for (let i = 0; i < this.maxChains; i++) {
                                    let nextTarget = null;
                                    let nextDist = Infinity;
                                    
                                    gameState.enemies.forEach(enemy => {
                                        if (hitEnemies.includes(enemy)) return;
                                        if (!isEnemyOnScreen(enemy)) return;
                                        const dist = currentSource.position.distanceTo(enemy.position);
                                        if (dist < nextDist && dist <= this.chainRange) {
                                            nextTarget = enemy;
                                            nextDist = dist;
                                        }
                                    });
                                    
                                    if (nextTarget) {
                                        setTimeout(() => {
                                            effectsManager.createLightningBolt(currentSource.position, nextTarget.position);
                                            damageEnemy(nextTarget, this.damage * 0.7);
                                            
                                            // Evolution: Create explosion at each chain target
                                            if (classExp.electric.evolution > 0) {
                                                const explosionRange = 4;
                                                effectsManager.createExplosion(nextTarget.position, 0xffff00);
                                                gameState.enemies.forEach(nearbyEnemy => {
                                                    if (nearbyEnemy !== nextTarget) {
                                                        const dist = nextTarget.position.distanceTo(nearbyEnemy.position);
                                                        if (dist <= explosionRange) {
                                                            damageEnemy(nearbyEnemy, this.damage * 0.5);
                                                        }
                                                    }
                                                });
                                            }
                                        }, 100 * (i + 1));
                                        
                                        hitEnemies.push(nextTarget);
                                        currentSource = nextTarget;
                                    } else {
                                        break;
                                    }
                                }
                            }
                            
                            return true;
                        }
                    },
                    lightningStrike: {
                        cooldown: 5000,
                        lastUsed: 0,
                        damage: 100,
                        targets: 3,
                        icon: 'STRIKE',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            if (gameState.enemies.length === 0) return true;
                            
                            // Select random enemies
                            const shuffled = [...gameState.enemies].sort(() => Math.random() - 0.5);
                            const targets = shuffled.slice(0, Math.min(this.targets, gameState.enemies.length));
                            
                            // Strike each target with a delay
                            targets.forEach((enemy, index) => {
                                setTimeout(() => {
                                    const strikePos = enemy.position.clone();
                                    strikePos.z += 10;
                                    effectsManager.createLightningBolt(strikePos, enemy.position);
                                    damageEnemy(enemy, this.damage);
                                }, 200 * index);
                            });
                            
                            return true;
                        }
                    },
                    superZap: {
                        cooldown: 8000,
                        lastUsed: 0,
                        damage: 50,
                        range: 15,
                        chainRange: 12.5,
                        maxChains: 1000,
                        icon: 'SUPER',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            let closest = null;
                            let closestDist = Infinity;
                            
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = player.position.distanceTo(enemy.position);
                                if (dist < closestDist && dist <= this.range) {
                                    closest = enemy;
                                    closestDist = dist;
                                }
                            });
                            
                            if (closest) {
                                effectsManager.createLightningBolt(player.position, closest.position);
                                damageEnemy(closest, this.damage);
                                
                                let hitEnemies = [closest];
                                let currentSource = closest;
                                
                                for (let i = 0; i < this.maxChains; i++) {
                                    let nextTarget = null;
                                    let nextDist = Infinity;
                                    
                                    gameState.enemies.forEach(enemy => {
                                        if (hitEnemies.includes(enemy)) return;
                                        if (!isEnemyOnScreen(enemy)) return;
                                        const dist = currentSource.position.distanceTo(enemy.position);
                                        if (dist < nextDist && dist <= this.chainRange) {
                                            nextTarget = enemy;
                                            nextDist = dist;
                                        }
                                    });
                                    
                                    if (nextTarget) {
                                        const source = currentSource;
                                        const target = nextTarget;
                                        setTimeout(() => {
                                            effectsManager.createLightningBolt(source.position, target.position);
                                            damageEnemy(target, this.damage * 0.6);
                                        }, 100 * (i + 1));
                                        
                                        hitEnemies.push(nextTarget);
                                        currentSource = nextTarget;
                                    } else {
                                        break;
                                    }
                                }
                            }
                            
                            return true;
                        }
                    }
                }
            },
            miner: {
                name: 'Miner',
                passiveMeleeDamage: 22,
                abilities: {
                    dig: {
                        cooldown: 10000,
                        lastUsed: 0,
                        icon: 'DIG',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            this.lastUsed = now;

                            // Teleport player to last clicked world position (buried dig)
                            if (lastClickWorld) {
                                player.position.copy(lastClickWorld);
                                // Clamp to screen bounds
                                const screenWidth = window.innerWidth / 40;
                                const screenHeight = window.innerHeight / 40;
                                player.position.x = Math.max(-screenWidth, Math.min(screenWidth, player.position.x));
                                player.position.y = Math.max(-screenHeight, Math.min(screenHeight, player.position.y));
                                effectsManager.createWave(player.position, 1.5);
                                screenShake(0.6, 180);
                            } else {
                                alert('No target selected. Click on the ground to set the target.');
                                return false;
                            }
                            return true;
                        }
                    },
                    drill: {
                        cooldown: 15000,
                        lastUsed: 0,
                        icon: 'DRILL',
                        duration: 6000,
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            this.lastUsed = now;
                            // Upgrade shovel to drill for a short duration
                            const dur = this.duration || 6000; // use configured duration
                            if (!player.userData) player.userData = {};
                            player.userData.drillUntil = now + dur;
                            effectsManager.createWave(player.position, 2);
                            screenShake(0.9, 220);
                            return true;
                        }
                    },
                    mine: {
                        cooldown: 5000,
                        lastUsed: 0,
                        icon: 'MINE',
                        damage: 90,
                        triggerRadius: 1.0,
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            this.lastUsed = now;

                            // Place a buried mine at the last clicked world position
                            if (!lastClickWorld) {
                                alert('No target selected. Click on the ground to set the target.');
                                return false;
                            }
                            const pos = lastClickWorld.clone();
                            const geom = new THREE.CircleGeometry(0.5, 12);
                            const mat = new THREE.MeshBasicMaterial({ color: 0xffcc00 });
                            const mine = new THREE.Mesh(geom, mat);
                            mine.position.copy(pos);
                            mine.position.z = 0.01;
                            scene.add(mine);
                            const mineObj = { mesh: mine, active: true, triggerRadius: this.triggerRadius || 1.0, damage: this.damage || 90 };
                            gameState.mines.push(mineObj);
                            // subtle bury effect
                            effectsManager.createWave(pos, 1.2);
                            return true;
                        }
                    }
                }
            },
            fire: {
                name: 'Fire',
                abilities: {
                    singe: {
                        cooldown: 1000,
                        lastUsed: 0,
                        damage: 15,
                        burnDamage: 5,
                        burnDuration: 5000,
                        range: 10,
                        icon: 'SINGE',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            let hitCount = 0;
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = player.position.distanceTo(enemy.position);
                                if (dist <= this.range) {
                                    hitCount++;
                                    
                                    // Create fire effect
                                    effectsManager.createWave(enemy.position, 1);
                                    
                                    if (enemy.userData.burning) {
                                        // Deal all burn damage instantly if already burning
                                        const remainingBurn = Math.ceil((enemy.userData.burnEnd - now) / 1000) * this.burnDamage;
                                        damageEnemy(enemy, this.damage + remainingBurn);
                                        enemy.userData.burning = false;
                                    } else {
                                        // Apply initial damage and start burn
                                        damageEnemy(enemy, this.damage);
                                        enemy.userData.burning = true;
                                        enemy.userData.burnEnd = now + this.burnDuration;
                                        enemy.userData.burnDamage = this.burnDamage;
                                        enemy.userData.lastBurnTick = now;
                                    }
                                }
                            });
                            
                            if (hitCount > 0) {
                                screenShake(0.2 + hitCount * 0.05, 120);
                                effectsManager.createWave(player.position, this.range);
                                
                                // Reduce cooldown if hit 3+ enemies
                                if (hitCount >= 3) {
                                    const reduction = this.cooldown * 0.5;
                                    this.lastUsed -= reduction;
                                    reduceCooldownDisplay('ability1', reduction);
                                }
                            }
                            
                            return true;
                        }
                    },
                    healingFire: {
                        cooldown: 5000,
                        lastUsed: 0,
                        damage: 20,
                        healMultiplier: 2,
                        icon: 'HEAL',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            let burnedCount = 0;
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                if (enemy.userData.burning) {
                                    burnedCount++;
                                }
                            });
                            
                            if (burnedCount > 0) {
                                screenShake(0.4 + burnedCount * 0.1, 250);
                                // Heal player
                                hpManager.heal(burnedCount * this.healMultiplier);
                                effectsManager.createWave(player.position, 2);
                                
                                // Damage burned enemies
                                gameState.enemies.forEach(enemy => {
                                    if (!isEnemyOnScreen(enemy)) return;
                                    if (enemy.userData.burning) {
                                        effectsManager.createExplosion(enemy.position, 0xff6600);
                                        damageEnemy(enemy, this.damage);
                                    }
                                });
                            }
                            
                            return true;
                        }
                    },
                    fireballs: {
                        cooldown: 8000,
                        lastUsed: 0,
                        damage: 35,
                        burnDamage: 5,
                        burnDuration: 3000,
                        speed: 0.25,
                        fireballs: 5,
                        icon: 'FIRE',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            // Find three closest enemies to auto-aim at
                            if (gameState.enemies.length === 0) return true;
                            
                            const sortedEnemies = [...gameState.enemies].filter(enemy => isEnemyOnScreen(enemy)).sort((a, b) => {
                                const distA = player.position.distanceTo(a.position);
                                const distB = player.position.distanceTo(b.position);
                                return distA - distB;
                            });
                            
                            const targets = sortedEnemies.slice(0, Math.min(this.fireballs, gameState.enemies.length));
                            screenShake(0.9, 350);
                            const sharedHitCount = { count: 0 };
                            
                            targets.forEach((target, index) => {
                                setTimeout(() => {
                                    const direction = new THREE.Vector3()
                                        .subVectors(target.position, player.position)
                                        .normalize();
                                    
                                    const projectile = effectsManager.createFireball(player.position.clone(), direction, this.speed);
                                    projectile.scale.set(2, 2, 2); // Giant fireball
                                    
                                    Object.assign(projectile.userData, {
                                        damage: this.damage,
                                        burnDamage: this.burnDamage,
                                        burnDuration: this.burnDuration,
                                        lifetime: 5000,
                                        created: Date.now(),
                                        isFireball: true,
                                        abilityRef: this,
                                        abilityId: 'ability3',
                                        hitThreshold: 5,
                                        cooldownReduction: 0.5,
                                        sharedHitCount: sharedHitCount,
                                        isEvolved: classExp.fire.evolution > 0,
                                        explosionRange: 10
                                    });
                                    
                                    gameState.projectiles.push(projectile);
                                }, index * 150);
                            });
                            
                            return true;
                        }
                    }
                }
            },
            pierce: {
                name: 'Pierce',
                abilities: {
                    pierceShot: {
                        cooldown: 2000,
                        lastUsed: 0,
                        damage: 25,
                        maxPierce: 5,
                        speed: 0.4,
                        icon: 'PIERCE',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            if (gameState.enemies.length === 0) return true;
                            
                            const closest = gameState.enemies.reduce((prev, curr) => {
                                const prevDist = player.position.distanceTo(prev.position);
                                const currDist = player.position.distanceTo(curr.position);
                                return currDist < prevDist ? curr : prev;
                            });
                            
                            const direction = new THREE.Vector3()
                                .subVectors(closest.position, player.position)
                                .normalize();
                            
                            screenShake(0.2, 100);
                            
                            const geometry = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
                            const material = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                            const arrow = new THREE.Mesh(geometry, material);
                            arrow.position.copy(player.position);
                            arrow.rotation.z = Math.atan2(direction.y, direction.x) - Math.PI / 2;
                            
                            scene.add(arrow);
                            
                            arrow.userData = {
                                direction: direction,
                                speed: this.speed,
                                damage: this.damage,
                                pierceCount: 0,
                                maxPierce: this.maxPierce,
                                hitEnemies: [],
                                created: now,
                                lifetime: 5000,
                                isPiercing: true,
                                abilityRef: this,
                                abilityId: 'ability1',
                                hitThreshold: 3,
                                cooldownReduction: 0.5
                            };
                            
                            gameState.projectiles.push(arrow);
                            return true;
                        }
                    },
                    multiShot: {
                        cooldown: 4000,
                        lastUsed: 0,
                        damage: 20,
                        speed: 0.50,
                        icon: 'MULTI',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            if (gameState.enemies.length === 0) return true;
                            
                            // Find 5 closest enemies for auto-aim
                            const sortedEnemies = [...gameState.enemies].sort((a, b) => {
                                const distA = player.position.distanceTo(a.position);
                                const distB = player.position.distanceTo(b.position);
                                return distA - distB;
                            });
                            
                            const targets = sortedEnemies.slice(0, Math.min(5, gameState.enemies.length));
                            screenShake(0.4, 180);
                            const sharedHitCount = { count: 0 };
                            
                            // Evolution: Shoot in 360-degree spiral pattern
                            if (classExp.pierce.evolution > 0) {
                                const arrowCount = 16;
                                for (let i = 0; i < arrowCount; i++) {
                                    const angle = (Math.PI * 2 / arrowCount) * i;
                                    const direction = new THREE.Vector3(Math.cos(angle), Math.sin(angle), 0).normalize();
                                    
                                    const geometry = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
                                    const material = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                                    const arrow = new THREE.Mesh(geometry, material);
                                    arrow.position.copy(player.position);
                                    arrow.rotation.z = Math.atan2(direction.y, direction.x) - Math.PI / 2;
                                    
                                    scene.add(arrow);
                                    
                                    arrow.userData = {
                                        direction: direction,
                                        speed: this.speed,
                                        damage: this.damage,
                                        pierceCount: 0,
                                        maxPierce: 3,
                                        hitEnemies: [],
                                        created: now,
                                        lifetime: 5000,
                                        isPiercing: true,
                                        abilityRef: this,
                                        abilityId: 'ability2',
                                        hitThreshold: 8,
                                        cooldownReduction: 0.5,
                                        sharedHitCount: sharedHitCount
                                    };
                                    
                                    gameState.projectiles.push(arrow);
                                }
                                screenShake(0.6, 250);
                                
                                // Evolution: Heal 30 HP after attacking
                                hpManager.heal(30);
                                
                                return true;
                            }
                            
                            targets.forEach((target) => {
                                const direction = new THREE.Vector3()
                                    .subVectors(target.position, player.position)
                                    .normalize();
                                
                                const geometry = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
                                const material = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                                const arrow = new THREE.Mesh(geometry, material);
                                arrow.position.copy(player.position);
                                arrow.rotation.z = Math.atan2(direction.y, direction.x) - Math.PI / 2;
                                
                                scene.add(arrow);
                                
                                arrow.userData = {
                                    direction: direction,
                                    speed: this.speed,
                                    damage: this.damage,
                                    pierceCount: 0,
                                    maxPierce: 3,
                                    hitEnemies: [],
                                    created: now,
                                    lifetime: 5000,
                                    isPiercing: true,
                                    abilityRef: this,
                                    abilityId: 'ability2',
                                    hitThreshold: 8,
                                    cooldownReduction: 0.5,
                                    sharedHitCount: sharedHitCount
                                };
                                
                                gameState.projectiles.push(arrow);
                            });
                            
                            return true;
                        }
                    },
                    arrowStorm: {
                        cooldown: 8000,
                        lastUsed: 0,
                        damage: 15,
                        speed: 0.50,
                        icon: 'STORM',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            if (gameState.enemies.length === 0) return true;
                            
                            // Find 15 closest enemies for auto-aim (or all if fewer)
                            const sortedEnemies = [...gameState.enemies].sort((a, b) => {
                                const distA = player.position.distanceTo(a.position);
                                const distB = player.position.distanceTo(b.position);
                                return distA - distB;
                            });
                            
                            const targets = sortedEnemies.slice(0, Math.min(15, gameState.enemies.length));
                            screenShake(0.8, 350);
                            const sharedHitCount = { count: 0 };
                            
                            targets.forEach((target) => {
                                const direction = new THREE.Vector3()
                                    .subVectors(target.position, player.position)
                                    .normalize();
                                
                                const geometry = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 8);
                                const material = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
                                const arrow = new THREE.Mesh(geometry, material);
                                arrow.position.copy(player.position);
                                arrow.rotation.z = Math.atan2(direction.y, direction.x) - Math.PI / 2;
                                
                                scene.add(arrow);
                                
                                arrow.userData = {
                                    direction: direction,
                                    speed: this.speed,
                                    damage: this.damage,
                                    pierceCount: 0,
                                    maxPierce: 3,
                                    hitEnemies: [],
                                    created: now,
                                    lifetime: 5000,
                                    isPiercing: true,
                                    abilityRef: this,
                                    abilityId: 'ability3',
                                    hitThreshold: 10,
                                    cooldownReduction: 0.5,
                                    sharedHitCount: sharedHitCount
                                };
                                
                                gameState.projectiles.push(arrow);
                            });
                            
                            return true;
                        }
                    }
                }
            },
            engineer: {
                name: 'Engineer',
                abilities: {
                    q: {
                        name: 'Deploy Turret',
                        cooldown: 10000,
                        lastUsed: 0,
                        icon: 'TURRET',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            // Check max turret limit based on level
                            const engineerLevel = classExp.engineer.level;
                            const hasEvolution = classExp.engineer.evolution > 0;
                            const maxTurrets = (hasEvolution ? 3 : (engineerLevel >= 10 ? 2 : 1)) + 3;
                            
                            // Remove oldest turret if at limit
                            if (gameState.turrets.length >= maxTurrets) {
                                const oldestTurret = gameState.turrets.shift();
                                scene.remove(oldestTurret);
                                effectsManager.createExplosion(oldestTurret.position, 0xff6600);
                            }
                            
                            // Create turret at player position
                            const turretGeometry = new THREE.BoxGeometry(1, 1, 1);
                            const turretMaterial = new THREE.MeshPhongMaterial({ 
                                color: 0xffa500,
                                emissive: 0xff8800,
                                emissiveIntensity: 0.3
                            });
                            const turret = new THREE.Mesh(turretGeometry, turretMaterial);
                            turret.position.set(
                                gameState.player.position.x,
                                gameState.player.position.y,
                                0.5
                            );
                            
                            // Add nose to turret
                            const noseGeometry = new THREE.BoxGeometry(0.3, 0.6, 0.3);
                            const noseMaterial = new THREE.MeshPhongMaterial({ 
                                color: 0xff8800,
                                emissive: 0xff6600,
                                emissiveIntensity: 0.5
                            });
                            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
                            nose.position.set(0, 0.5, 0); // Position nose in front
                            turret.add(nose);
                            
                            turret.userData = {
                                isTurret: true,
                                collisionRadius: 0.9,
                                hp: 50,
                                maxHp: 50,
                                damage: 8,
                                range: 12,
                                attackCooldown: 0,
                                attackInterval: 1000,
                                level: 1
                            };
                            
                            scene.add(turret);
                            gameState.turrets.push(turret);
                            
                            screenShake(0.2, 150);
                            effectsManager.createExplosion(turret.position, 0xffa500);
                            
                            return true;
                        }
                    },
                    e: {
                        name: 'Heal Turret',
                        cooldown: 4000,
                        lastUsed: 0,
                        icon: 'HEAL',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            // Find nearest turret
                            let nearestTurret = null;
                            let minDist = Infinity;
                            
                            gameState.turrets.forEach(turret => {
                                if (!isEnemyOnScreen(turret)) return;
                                const dist = gameState.player.position.distanceTo(turret.position);
                                if (dist < minDist) {
                                    minDist = dist;
                                    nearestTurret = turret;
                                }
                            });
                            
                            if (nearestTurret && minDist <= 10) {
                                this.lastUsed = now;
                                
                                // Heal turret
                                nearestTurret.userData.hp = Math.min(
                                    nearestTurret.userData.hp + 30,
                                    nearestTurret.userData.maxHp
                                );
                                
                                // Upgrade if full HP
                                if (nearestTurret.userData.hp === nearestTurret.userData.maxHp && nearestTurret.userData.level < 3) {
                                    nearestTurret.userData.level++;
                                    nearestTurret.userData.damage += 5;
                                    nearestTurret.userData.attackInterval = Math.max(500, nearestTurret.userData.attackInterval - 200);
                                    nearestTurret.scale.set(1 + nearestTurret.userData.level * 0.2, 1 + nearestTurret.userData.level * 0.2, 1 + nearestTurret.userData.level * 0.2);
                                }
                                
                                screenShake(0.15, 100);
                                effectsManager.createExplosion(nearestTurret.position, 0x00ff00);
                                
                                return true;
                            }
                            return false;
                        }
                    },
                    r: {
                        name: 'Machine Gun',
                        cooldown: 15000, // 15 second reload time
                        lastUsed: 0,
                        icon: 'MGUN',
                        execute: function() {
                            const now = Date.now();
                            
                            // Check if currently reloading
                            if (gameState.machineGunAmmo <= 0 && now - this.lastUsed < this.cooldown) {
                                return false; // Still reloading
                            }
                            
                            // Refill ammo if empty and reload cooldown finished
                            if (gameState.machineGunAmmo <= 0 && now - this.lastUsed >= this.cooldown) {
                                gameState.machineGunAmmo = gameState.maxMachineGunAmmo;
                                document.getElementById('ammoCount').textContent = gameState.machineGunAmmo;
                            }
                            
                            // Fire single bullet if ammo available
                            if (gameState.machineGunAmmo > 0) {
                                // Check fire rate
                                if (now - gameState.machineGunLastFired < gameState.machineGunFireRate) {
                                    return false; // Too soon to fire again
                                }
                                
                                gameState.machineGunLastFired = now;
                                
                                // Find nearest enemy
                                let nearestEnemy = null;
                                let minDist = Infinity;
                                
                                gameState.enemies.forEach(enemy => {
                                    if (!isEnemyOnScreen(enemy)) return;
                                    const dist = gameState.player.position.distanceTo(enemy.position);
                                    if (dist < minDist) {
                                        minDist = dist;
                                        nearestEnemy = enemy;
                                    }
                                });
                                
                                // Fire in direction of enemy or forward if no enemy
                                let direction;
                                if (nearestEnemy) {
                                    direction = new THREE.Vector3()
                                        .subVectors(nearestEnemy.position, gameState.player.position)
                                        .normalize();
                                } else {
                                    // Fire in player's facing direction (forward)
                                    direction = new THREE.Vector3(0, 1, 0);
                                }
                                
                                // Add inaccuracy/spread
                                const spread = 0.15; // Adjust for more/less accuracy
                                direction.x += (Math.random() - 0.5) * spread;
                                direction.y += (Math.random() - 0.5) * spread;
                                direction.normalize();
                                
                                const bullet = effectsManager.createFireball(gameState.player.position.clone(), direction, 0.5);
                                bullet.userData = {
                                    direction: direction,
                                    speed: 0.5,
                                    damage: 5,
                                    created: Date.now(),
                                    lifetime: 2000
                                };
                                
                                gameState.projectiles.push(bullet);
                                gameState.machineGunAmmo--;
                                
                                // Update ammo display
                                document.getElementById('ammoCount').textContent = gameState.machineGunAmmo;
                                
                                // Start reload cooldown when ammo depletes
                                if (gameState.machineGunAmmo === 0) {
                                    this.lastUsed = Date.now();
                                    screenShake(0.1, 50);
                                    return 'reload'; // Special return value to trigger cooldown UI
                                }
                                
                                screenShake(0.1, 50);
                                return 'fired'; // Return different value to skip cooldown UI
                            }
                            return false;
                        }
                    }
                }
            },
            life: {
                name: 'Life',
                abilities: {
                    q: {
                        name: 'Kill',
                        cooldown: 2000,
                        lastUsed: 0,
                        icon: 'KILL',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            // Enable invulnerability
                            gameState.isInvulnerable = true;
                            
                            // Find nearest enemy
                            let nearestEnemy = null;
                            let minDist = Infinity;
                            
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = gameState.player.position.distanceTo(enemy.position);
                                if (dist < minDist) {
                                    minDist = dist;
                                    nearestEnemy = enemy;
                                }
                            });
                            
                            if (nearestEnemy) {
                                const damage = 100;
                                const targetPos = nearestEnemy.position.clone();
                                const targetMaxHp = nearestEnemy.userData.maxHp;
                                const targetHpBefore = nearestEnemy.userData.hp;
                                
                                // Deal damage
                                damageEnemy(nearestEnemy, damage);
                                
                                // Check if enemy died
                                if (targetHpBefore <= damage) {
                                    // Gain HP equal to half the target's max health
                                    hpManager.heal(targetMaxHp/2);
                                    
                                    // Teleport to target location with boundary checking
                                    const viewHeight = window.innerHeight / 40;
                                    const viewWidth = window.innerWidth / 40;
                                    const bounds = { 
                                        minX: -viewWidth + 1, 
                                        maxX: viewWidth - 1, 
                                        minY: -viewHeight + 1, 
                                        maxY: viewHeight - 1 
                                    };
                                    
                                    gameState.player.position.x = Math.max(bounds.minX, Math.min(bounds.maxX, targetPos.x));
                                    gameState.player.position.y = Math.max(bounds.minY, Math.min(bounds.maxY, targetPos.y));
                                    
                                    // AoE damage with lifesteal
                                    const aoeRange = 5;
                                    let totalHealed = 0;
                                    
                                    gameState.enemies.forEach(enemy => {
                                        if (!isEnemyOnScreen(enemy)) return;
                                        const dist = targetPos.distanceTo(enemy.position);
                                        if (dist <= aoeRange && enemy.userData.hp > 0) {
                                            const aoeDamage = 10;
                                            damageEnemy(enemy, aoeDamage);
                                            totalHealed += aoeDamage;
                                        }
                                    });
                                    
                                    // Lifesteal from AoE
                                    if (totalHealed > 0) {
                                        const healAmount = Math.floor(totalHealed * 0.6);
                                        hpManager.heal(healAmount);
                                    }
                                    
                                    // Visual effects
                                    effectsManager.createWave(targetPos, aoeRange);
                                    screenShake(0.8, 200);
                                } else {
                                    screenShake(0.3, 150);
                                }
                                
                                // Disable invulnerability after 500ms
                                setTimeout(() => {
                                    gameState.isInvulnerable = false;
                                }, 500);
                                
                                return true;
                            }
                            
                            // Disable invulnerability if no target found
                            gameState.isInvulnerable = false;
                            return false;
                        }
                    },
                    e: {
                        name: 'Life Burst',
                        cooldown: 5000,
                        lastUsed: 0,
                        icon: 'BURST',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            // AoE damage around player
                            const aoeRange = 8;
                            let totalHealed = 0;
                            
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = gameState.player.position.distanceTo(enemy.position);
                                if (dist <= aoeRange) {
                                    const damage = 50;
                                    damageEnemy(enemy, damage);
                                    totalHealed += damage;
                                }
                            });
                            
                            // Create expanding ring effect
                            effectsManager.createWave(gameState.player.position, aoeRange);
                            
                            // Lifesteal 50% of damage dealt
                            if (totalHealed > 0) {
                                const healAmount = Math.floor(totalHealed * 0.5);
                                hpManager.heal(healAmount);
                            }
                            
                            screenShake(0.6, 200);
                            return true;
                        }
                    },
                    r: {
                        name: 'Blood Frenzy',
                        cooldown: 8000,
                        lastUsed: 0,
                        icon: 'FRENZY',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            const blastRange = 25;
                            const blastCount = Math.floor(Math.random() * 11) + 20; // 20-30 blasts
                            const blastRadius = 10;
                            const blastDamage = classExp.life.evolution > 0 ? 30 : 25;
                            
                            // Evolution: Also convert enemies to allies
                            if (classExp.life.evolution > 0) {
                                const conversionRange = 10;
                                const enemiesToConvert = [];
                                gameState.enemies.forEach(enemy => {
                                    if (!isEnemyOnScreen(enemy)) return;
                                    const dist = gameState.player.position.distanceTo(enemy.position);
                                    if (dist <= conversionRange) {
                                        enemiesToConvert.push(enemy);
                                    }
                                });
                                
                                enemiesToConvert.forEach(enemy => {
                                    convertToAlly(enemy);
                                });
                                
                                if (enemiesToConvert.length > 0) {
                                    effectsManager.createWave(gameState.player.position, conversionRange);
                                }
                            }
                            
                            // Rain random blasts within range
                            const duration = 2000;
                            const blastInterval = duration / blastCount;
                            
                            for (let i = 0; i < blastCount; i++) {
                                setTimeout(() => {
                                    // Random position within range around player
                                    const angle = Math.random() * Math.PI * 2;
                                    const distance = Math.random() * blastRange;
                                    const blastPos = new THREE.Vector3(
                                        gameState.player.position.x + Math.cos(angle) * distance,
                                        gameState.player.position.y + Math.sin(angle) * distance,
                                        0
                                    );
                                    
                                    // Create explosion effect
                                    effectsManager.createExplosion(blastPos, 0xff0000);
                                    
                                    // Damage enemies in blast radius
                                    gameState.enemies.forEach(enemy => {
                                        if (!isEnemyOnScreen(enemy)) return;
                                        const dist = blastPos.distanceTo(enemy.position);
                                        if (dist <= blastRadius) {
                                            damageEnemy(enemy, blastDamage);
                                        }
                                    });
                                }, i * blastInterval);
                            }
                            
                            screenShake(0.8, duration);
                            return true;
                        }
                    }
                }
            },
            summoner: {
                name: 'Summoner',
                abilities: {
                    q: {
                        name: 'Attack Command (CMD)',
                        cooldown: 3500,
                        lastUsed: 0,
                        icon: 'CMD',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            this.lastUsed = now;
                            let didAttack = false;
                            if (gameState.allies && gameState.allies.length > 0 && gameState.enemies.length > 0) {
                                gameState.allies.forEach(ally => {
                                    // Prefer the enemy this ally was already targeting
                                    let finalTarget = null;
                                    const current = ally.userData && ally.userData.currentTarget ? ally.userData.currentTarget : null;
                                    if (current && gameState.enemies.includes(current)) {
                                        finalTarget = current;
                                    } else {
                                        // Fallback: nearest enemy to the ally
                                        let nearestEnemy = null;
                                        let minDist = Infinity;
                                        gameState.enemies.forEach(enemy => {
                                            const dist = ally.position.distanceTo(enemy.position);
                                            if (dist < minDist) {
                                                minDist = dist;
                                                nearestEnemy = enemy;
                                            }
                                        });
                                        finalTarget = nearestEnemy;
                                    }

                                    if (finalTarget) {
                                        // Allies now always spawn projectiles for CMD to avoid instant-kill melee
                                        // Weaken CMD damage too
                                        const dmg = ally.userData.isGuardian ? 50 : 20;

                                        // Direction from ally to target
                                        const direction = new THREE.Vector3()
                                            .subVectors(finalTarget.position, ally.position)
                                            .normalize();

                                        // Offset spawn so projectile doesn't immediately collide when spawned inside target
                                        const offsetDist = (ally.userData && ally.userData.collisionRadius ? ally.userData.collisionRadius : 0.6) + 0.25;
                                        const spawnPos = ally.position.clone();
                                        spawnPos.x += direction.x * offsetDist;
                                        spawnPos.y += direction.y * offsetDist;

                                        // Create projectile using existing effect helper for consistency
                                        const projectile = effectsManager.createFireball(spawnPos, direction, 0.35);
                                        projectile.userData = {
                                            direction: direction,
                                            speed: 0.45,
                                            damage: dmg,
                                            created: Date.now(),
                                            lifetime: 3000,
                                            isAllyProjectile: true,
                                            sourceAlly: ally
                                        };
                                        scene.add(projectile);
                                        gameState.projectiles.push(projectile);
                                        didAttack = true;
                                    }
                                });
                                screenShake(0.5, 180);
                            }
                            return didAttack;
                        }
                    },
                    e: {
                        name: 'Summon Squad+',
                        cooldown: 7000,
                        lastUsed: 0,
                        icon: 'SQUAD+',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            this.lastUsed = now;
                            // Summon 4 minions (22s, 60 HP, attackInterval 800ms)
                            const minionGeometry = new THREE.TetrahedronGeometry(0.5, 0);
                            const minionMaterial = new THREE.MeshStandardMaterial({ color: 0x3b82f6, emissive: 0x2563eb, emissiveIntensity: 0.3, transparent: true, opacity: 1 });
                            for (let i = 0; i < 4; i++) {
                                const angle = (Math.PI * 2 / 4) * i;
                                const dist = 2;
                                const minion = new THREE.Mesh(minionGeometry, minionMaterial);
                                minion.position.set(
                                    gameState.player.position.x + Math.cos(angle) * dist,
                                    gameState.player.position.y + Math.sin(angle) * dist,
                                    0
                                );
                                minion.userData = {
                                    isAlly: true,
                                    allyUntil: now + 22000, // 22 seconds
                                    hp: 60,
                                    maxHp: 60,
                                    damage: 10,
                                    speed: 0.06,
                                    attackCooldown: 0,
                                    attackInterval: 800,
                                    rotationSpeed: 0.02,
                                    isMinion: true,
                                    collisionRadius: 0.6
                                };
                                scene.add(minion);
                                // Track minions separately so minion AI runs in updateMinions()
                                if (!gameState.minions) gameState.minions = [];
                                gameState.minions.push(minion);
                                effectsManager.createExplosion(minion.position, 0x3b82f6);
                            }
                            screenShake(0.5, 150);
                            return true;
                        }
                    },
                    r: {
                        name: 'Summon Guardian+',
                        cooldown: 12000,
                        lastUsed: 0,
                        icon: 'GUARD+',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            this.lastUsed = now;
                            // Guardian: 150 HP, attackInterval 600ms
                            const guardianGeometry = new THREE.DodecahedronGeometry(0.7, 0);
                            const guardianMaterial = new THREE.MeshStandardMaterial({ color: 0x2563eb, emissive: 0x3b82f6, emissiveIntensity: 0.5, transparent: true, opacity: 1 });
                            const guardian = new THREE.Mesh(guardianGeometry, guardianMaterial);
                            guardian.position.copy(gameState.player.position);
                            guardian.userData = {
                                isAlly: true,
                                allyUntil: now + 35000, // 35 seconds
                                hp: 150,
                                attackCooldown: 0,
                                attackInterval: 600,
                                rotationSpeed: 0.01,
                                isGuardian: true
                                ,collisionRadius: 1.1
                            };
                            scene.add(guardian);
                            gameState.allies.push(guardian);
                            effectsManager.createExplosion(guardian.position, 0x3b82f6);
                            screenShake(0.8, 220);
                            return true;
                        }
                    }
                }
            },
            water: {
                name: 'Water',
                abilities: {
                    q: {
                        name: 'Water Blast',
                        cooldown: 2000,
                        lastUsed: 0,
                        icon: 'BLAST',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            // Knockback enemies in cone in front of player
                            const range = 8;
                            const knockback = 6;
                            let hit = false;
                            
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = gameState.player.position.distanceTo(enemy.position);
                                if (dist <= range) {
                                    const dx = enemy.position.x - gameState.player.position.x;
                                    const dy = enemy.position.y - gameState.player.position.y;
                                    const len = Math.sqrt(dx * dx + dy * dy);
                                    if (len > 0) {
                                        enemy.position.x += (dx / len) * knockback;
                                        enemy.position.y += (dy / len) * knockback;
                                        // Proximity damage: more damage up close
                                        const proximityDamage = Math.floor(15 * (1 - dist / range));
                                        damageEnemy(enemy, proximityDamage);
                                        hit = true;
                                    }
                                }
                            });
                            
                            if (hit) {
                                screenShake(0.4, 180);
                                effectsManager.createWave(gameState.player.position, range);
                            }
                            return hit;
                        }
                    },
                    e: {
                        name: 'Tidal Wave',
                        cooldown: 5000,
                        lastUsed: 0,
                        icon: 'WAVE',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            // Push all enemies away radially
                            // Evolution: Double range
                            const range = classExp.water.evolution > 0 ? 24 : 12;
                            const knockback = 10;
                            let hit = false;
                            
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = gameState.player.position.distanceTo(enemy.position);
                                if (dist <= range) {
                                    const dx = enemy.position.x - gameState.player.position.x;
                                    const dy = enemy.position.y - gameState.player.position.y;
                                    const len = Math.sqrt(dx * dx + dy * dy);
                                    if (len > 0) {
                                        enemy.position.x += (dx / len) * knockback;
                                        enemy.position.y += (dy / len) * knockback;
                                        // Proximity damage: more damage up close
                                        const proximityDamage = Math.floor(25 * (1 - dist / range));
                                        damageEnemy(enemy, proximityDamage);
                                        hit = true;
                                    }
                                }
                            });
                            
                            if (hit) {
                                screenShake(0.7, 280);
                                effectsManager.createWave(gameState.player.position, range);
                            }
                            return hit;
                        }
                    },
                    r: {
                        name: 'Whirlpool',
                        cooldown: 8000,
                        lastUsed: 0,
                        icon: 'WHIRL',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            const playerPos = gameState.player.position.clone();
                            
                            // Evolution: Create blue ball with repeated suck/knockback cycles
                            if (classExp.water.evolution > 0) {
                                const range = 18;
                                const damage = 25;
                                const duration = 3000;
                                const cycleInterval = 500;
                                const cycles = Math.floor(duration / cycleInterval);
                                
                                // Create blue orb
                                const orbGeometry = new THREE.SphereGeometry(2, 32, 32);
                                const orbMaterial = new THREE.MeshStandardMaterial({ 
                                    color: 0x0080ff,
                                    emissive: 0x0080ff,
                                    emissiveIntensity: 0.8,
                                    transparent: true,
                                    opacity: 0.7
                                });
                                const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                                orb.position.copy(playerPos);
                                scene.add(orb);
                                
                                // Pulsing animation
                                const orbStartTime = Date.now();
                                const orbAnimate = () => {
                                    const elapsed = Date.now() - orbStartTime;
                                    if (elapsed < duration) {
                                        const pulse = Math.sin(elapsed * 0.01) * 0.3 + 1;
                                        orb.scale.set(pulse, pulse, pulse);
                                        orb.rotation.y += 0.05;
                                        requestAnimationFrame(orbAnimate);
                                    } else {
                                        scene.remove(orb);
                                    }
                                };
                                orbAnimate();
                                
                                screenShake(1.2, duration);
                                gameState.isInvulnerable = true;
                                
                                // Repeated suck and knockback cycles
                                for (let i = 0; i < cycles; i++) {
                                    setTimeout(() => {
                                        // Reverse wave animation (collapsing inward)
                                        effectsManager.createReverseWave(playerPos, range);
                                        
                                        // Find enemies in range
                                        const affectedEnemies = [];
                                        gameState.enemies.forEach(enemy => {
                                            if (!isEnemyOnScreen(enemy)) return;
                                            const dist = playerPos.distanceTo(enemy.position);
                                            if (dist <= range) {
                                                affectedEnemies.push(enemy);
                                            }
                                        });
                                        
                                        // Suck phase (pull enemies in and damage on contact)
                                        affectedEnemies.forEach(enemy => {
                                            if (gameState.enemies.includes(enemy)) {
                                                const dx = playerPos.x - enemy.position.x;
                                                const dy = playerPos.y - enemy.position.y;
                                                const len = Math.sqrt(dx * dx + dy * dy);
                                                if (len > 0) {
                                                    enemy.position.x += (dx / len) * 3;
                                                    enemy.position.y += (dy / len) * 3;
                                                    
                                                    // Damage when pulled close to the orb
                                                    const newDist = playerPos.distanceTo(enemy.position);
                                                    if (newDist < 4) {
                                                        damageEnemy(enemy, damage);
                                                    }
                                                }
                                            }
                                        });
                                        
                                        // Knockback phase after 250ms
                                        setTimeout(() => {
                                            affectedEnemies.forEach(enemy => {
                                                if (gameState.enemies.includes(enemy)) {
                                                    const dx = enemy.position.x - playerPos.x;
                                                    const dy = enemy.position.y - playerPos.y;
                                                    const len = Math.sqrt(dx * dx + dy * dy);
                                                    if (len > 0) {
                                                        enemy.position.x += (dx / len) * 5;
                                                        enemy.position.y += (dy / len) * 5;
                                                    }
                                                    damageEnemy(enemy, damage);
                                                }
                                            });
                                        }, 250);
                                    }, i * cycleInterval);
                                }
                                
                                setTimeout(() => {
                                    gameState.isInvulnerable = false;
                                }, duration);
                                
                                return true;
                            }
                            
                            // Normal whirlpool
                            const range = 15;
                            const damage = 30;
                            const pullStrength = 8;
                            let hit = false;
                            
                            const affectedEnemies = [];
                            
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = playerPos.distanceTo(enemy.position);
                                if (dist <= range) {
                                    affectedEnemies.push(enemy);
                                    hit = true;
                                }
                            });
                            
                            if (hit) {
                                screenShake(1.0, 400);
                                gameState.isInvulnerable = true;
                                setTimeout(() => {
                                    gameState.isInvulnerable = false;
                                }, 1200);
                                
                                effectsManager.createWave(playerPos, range);
                                setTimeout(() => {
                                    effectsManager.createWave(playerPos, range * 0.7);
                                }, 200);
                                
                                affectedEnemies.forEach(enemy => {
                                    if (gameState.enemies.includes(enemy)) {
                                        const dx = playerPos.x - enemy.position.x;
                                        const dy = playerPos.y - enemy.position.y;
                                        const len = Math.sqrt(dx * dx + dy * dy);
                                        if (len > 0) {
                                            enemy.position.x += (dx / len) * pullStrength;
                                            enemy.position.y += (dy / len) * pullStrength;
                                        }
                                    }
                                });
                                
                                setTimeout(() => {
                                    affectedEnemies.forEach(enemy => {
                                        if (gameState.enemies.includes(enemy)) {
                                            const dx = enemy.position.x - playerPos.x;
                                            const dy = enemy.position.y - playerPos.y;
                                            const len = Math.sqrt(dx * dx + dy * dy);
                                            if (len > 0) {
                                                enemy.position.x += (dx / len) * pullStrength * 1.5;
                                                enemy.position.y += (dy / len) * pullStrength * 1.5;
                                            }
                                            damageEnemy(enemy, damage);
                                        }
                                    });
                                }, 1000);
                            }
                            
                            return hit;
                        }
                    }
                }
            },
            thief: {
                name: 'Thief',
                abilities: {
                    q: {
                        name: 'Throw Daggers',
                        cooldown: 1500,
                        lastUsed: 0,
                        icon: 'DAGGER',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            const daggerCount = 5;
                            const damage = 15;
                            const speed = 0.6;
                            const spreadAngle = Math.PI / 6;
                            
                            // Find nearest enemy for aim direction
                            let targetDirection = new THREE.Vector3(0, 1, 0);
                            let nearestEnemy = null;
                            let minDist = Infinity;
                            
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = player.position.distanceTo(enemy.position);
                                if (dist < minDist) {
                                    minDist = dist;
                                    nearestEnemy = enemy;
                                }
                            });
                            
                            if (nearestEnemy) {
                                targetDirection.subVectors(nearestEnemy.position, player.position).normalize();
                            }
                            
                            const baseAngle = Math.atan2(targetDirection.y, targetDirection.x);
                            
                            for (let i = 0; i < daggerCount; i++) {
                                const offset = (i - (daggerCount - 1) / 2) * (spreadAngle / daggerCount);
                                const angle = baseAngle + offset;
                                const direction = new THREE.Vector3(Math.cos(angle), Math.sin(angle), 0);
                                
                                const geometry = new THREE.ConeGeometry(0.15, 0.6, 4);
                                const material = new THREE.MeshStandardMaterial({ 
                                    color: 0x888888,
                                    metalness: 0.8,
                                    roughness: 0.2
                                });
                                const dagger = new THREE.Mesh(geometry, material);
                                dagger.position.copy(player.position);
                                dagger.rotation.z = angle - Math.PI / 2;
                                
                                scene.add(dagger);
                                
                                dagger.userData = {
                                    direction: direction,
                                    speed: speed,
                                    damage: damage,
                                    created: now,
                                    lifetime: 3000,
                                    isProjectile: true
                                };
                                
                                gameState.projectiles.push(dagger);
                            }
                            
                            screenShake(0.3, 100);
                            return true;
                        }
                    },
                    e: {
                        name: 'Vanish',
                        cooldown: 6000,
                        lastUsed: 0,
                        icon: 'VANISH',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            const duration = 3000;
                            
                            // Make player semi-transparent and invulnerable
                            player.material.opacity = 0.3;
                            player.material.transparent = true;
                            player.material.needsUpdate = true;
                            gameState.isInvulnerable = true;
                            gameState.isInvisible = true;

                            // Freeze all enemies briefly so Vanish guarantees safety
                            try {
                                const freezeDur = 1000; // ms
                                const freezeUntil = Date.now() + freezeDur;
                                if (gameState.enemies && gameState.enemies.length) {
                                    gameState.enemies.forEach(e => {
                                        if (!e.userData) e.userData = {};
                                        e.userData.frozenUntil = freezeUntil;
                                    });
                                    if (gameState.debugAI) console.log(`Vanish: froze ${gameState.enemies.length} enemies for ${freezeDur}ms`);
                                }
                            } catch (e) {}
                            
                            setTimeout(() => {
                                player.material.opacity = 1;
                                player.material.transparent = false;
                                player.material.needsUpdate = true;
                                gameState.isInvulnerable = false;
                                gameState.isInvisible = false;
                            }, duration);
                            
                            screenShake(0.2, 200);
                            return true;
                        }
                    },
                    r: {
                        name: 'Shadow Strike',
                        cooldown: 10000,
                        lastUsed: 0,
                        icon: 'STRIKE',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            // Find farthest enemy
                            let farthestEnemy = null;
                            let maxDist = 0;
                            
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = player.position.distanceTo(enemy.position);
                                if (dist > maxDist) {
                                    maxDist = dist;
                                    farthestEnemy = enemy;
                                }
                            });
                            
                            if (!farthestEnemy) return false;
                            
                            const targetPos = farthestEnemy.position.clone();
                            const executeThreshold = 50;
                            
                            // Evolution: Chain to multiple enemies
                            if (classExp.thief.evolution > 0) {
                                const chainTargets = [farthestEnemy];
                                const chainRange = 8;
                                
                                // Find 3 more nearby enemies
                                gameState.enemies.forEach(enemy => {
                                    if (!isEnemyOnScreen(enemy)) return;
                                    if (chainTargets.includes(enemy)) return;
                                    if (chainTargets.length >= 4) return;
                                    
                                    const dist = farthestEnemy.position.distanceTo(enemy.position);
                                    if (dist <= chainRange) {
                                        chainTargets.push(enemy);
                                    }
                                });
                                
                                // Dash to each target
                                chainTargets.forEach((target, index) => {
                                    setTimeout(() => {
                                        if (gameState.enemies.includes(target)) {
                                            player.position.copy(target.position);
                                            
                                                // Clamp within screen bounds (leave a small margin)
                                                const screenWidth = window.innerWidth / 40;
                                                const screenHeight = window.innerHeight / 40;
                                                const margin = 2;
                                                player.position.x = Math.max(-(screenWidth - margin), Math.min(screenWidth - margin, player.position.x));
                                                player.position.y = Math.max(-(screenHeight - margin), Math.min(screenHeight - margin, player.position.y));
                                            
                                            // Execute if below threshold
                                            if (target.userData.hp <= executeThreshold) {
                                                target.userData.hp = 0;
                                                damageEnemy(target, 0);
                                            } else {
                                                damageEnemy(target, 100);
                                            }
                                            
                                            // Leave landmine (spawn and arm shortly after)
                                            (function() {
                                                const minePos = target.position.clone();
                                                const geom = new THREE.CircleGeometry(0.5, 12);
                                                const mat = new THREE.MeshBasicMaterial({ color: 0xffcc00 });
                                                const mineMesh = new THREE.Mesh(geom, mat);
                                                mineMesh.position.copy(minePos);
                                                mineMesh.position.z = 0.01;
                                                scene.add(mineMesh);
                                                const mineObj = { mesh: mineMesh, active: false, triggerRadius: 1.5, damage: 60, created: Date.now() };
                                                gameState.mines.push(mineObj);
                                                // Small arming delay so the mine doesn't trigger immediately on landing
                                                setTimeout(() => { try { mineObj.active = true; } catch (e) {} }, 300);
                                                effectsManager.createWave(minePos, 1.2);
                                            })();
                                            
                                            screenShake(0.8, 200);
                                        }
                                    }, index * 300);
                                });
                                
                                return true;
                            }
                            
                            // Normal dash
                            player.position.copy(targetPos);

                            // Clamp within screen bounds (leave a small margin)
                            const screenWidth = window.innerWidth / 40;
                            const screenHeight = window.innerHeight / 40;
                            const margin = 2;
                            player.position.x = Math.max(-(screenWidth - margin), Math.min(screenWidth - margin, player.position.x));
                            player.position.y = Math.max(-(screenHeight - margin), Math.min(screenHeight - margin, player.position.y));
                            
                            // Execute if below threshold
                            if (farthestEnemy.userData.hp <= executeThreshold) {
                                farthestEnemy.userData.hp = 0;
                                damageEnemy(farthestEnemy, 0);
                            } else {
                                damageEnemy(farthestEnemy, 100);
                            }
                            
                            // Leave landmine at target location (arm shortly after)
                            (function() {
                                const minePos = targetPos.clone();
                                const geom = new THREE.CircleGeometry(0.5, 12);
                                const mat = new THREE.MeshBasicMaterial({ color: 0xffcc00 });
                                const mineMesh = new THREE.Mesh(geom, mat);
                                mineMesh.position.copy(minePos);
                                mineMesh.position.z = 0.01;
                                scene.add(mineMesh);
                                const mineObj = { mesh: mineMesh, active: false, triggerRadius: 1.5, damage: 60, created: Date.now() };
                                gameState.mines.push(mineObj);
                                setTimeout(() => { try { mineObj.active = true; } catch (e) {} }, 300);
                                effectsManager.createWave(minePos, 1.2);
                            })();
                            
                            screenShake(1.0, 300);
                            return true;
                        }
                    }
                }
            },
            trapper: {
                name: 'Trapper',
                abilities: {
                    q: {
                        name: 'Place Bomb',
                        cooldown: 2000,
                        lastUsed: 0,
                        icon: 'BOMB',
                        bombs: [],
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            // Create bomb at player position
                            const bombGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                            const bombMaterial = new THREE.MeshStandardMaterial({ 
                                color: 0xff0000,
                                emissive: 0xff0000,
                                emissiveIntensity: 0.5
                            });
                            const bomb = new THREE.Mesh(bombGeometry, bombMaterial);
                            bomb.position.copy(player.position);
                            scene.add(bomb);
                            
                            bomb.userData = {
                                created: now,
                                armed: true
                            };
                            
                            this.bombs.push(bomb);
                            
                            // Bomb explodes when enemy gets close or after 10 seconds
                            const checkBomb = setInterval(() => {
                                if (!bomb.userData.armed || !scene.children.includes(bomb)) {
                                    clearInterval(checkBomb);
                                    return;
                                }
                                
                                // Check for nearby enemies
                                let triggered = false;
                                gameState.enemies.forEach(enemy => {
                                    const dist = bomb.position.distanceTo(enemy.position);
                                    if (dist <= 2) {
                                        triggered = true;
                                    }
                                });
                                
                                if (triggered || Date.now() - bomb.userData.created > 10000) {
                                    bomb.userData.armed = false;
                                    scene.remove(bomb);
                                    const index = this.bombs.indexOf(bomb);
                                    if (index > -1) this.bombs.splice(index, 1);
                                    
                                    // Explosion
                                    effectsManager.createExplosion(bomb.position, 0xff6600);
                                    gameState.enemies.forEach(enemy => {
                                        if (!isEnemyOnScreen(enemy)) return;
                                        const dist = bomb.position.distanceTo(enemy.position);
                                        if (dist <= 6) {
                                            damageEnemy(enemy, 40);
                                        }
                                    });
                                    screenShake(0.6, 200);
                                    clearInterval(checkBomb);
                                }
                            }, 100);
                            
                            return true;
                        }
                    },
                    e: {
                        name: 'Spike Barrier',
                        cooldown: 4000,
                        lastUsed: 0,
                        icon: 'BARRIER',
                        barriers: [],
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            // Create barrier wall
                            const barrierGeometry = new THREE.BoxGeometry(4, 0.5, 0.5);
                            const barrierMaterial = new THREE.MeshStandardMaterial({ 
                                color: 0x8b4513,
                                emissive: 0x654321,
                                emissiveIntensity: 0.3
                            });
                            const barrier = new THREE.Mesh(barrierGeometry, barrierMaterial);
                            barrier.position.copy(player.position);
                            barrier.position.y += 1.5;
                            
                            // Rotate barrier based on player velocity/last movement
                            const lastMove = movementManager.getLastMovement();
                            if (lastMove.x !== 0 || lastMove.y !== 0) {
                                const angle = Math.atan2(lastMove.y, lastMove.x);
                                barrier.rotation.z = angle + Math.PI / 2; // Perpendicular to movement
                            }
                            
                            scene.add(barrier);

                            // Track barrier globally so it can be cleared on restart/play-again
                            try { gameState.barriers = gameState.barriers || []; gameState.barriers.push(barrier); } catch (e) {}
                            
                            barrier.userData = {
                                created: now,
                                active: true,
                                width: 4,
                                height: 0.5
                            };
                            
                            // Remove oldest barrier if we have 3 already
                            if (this.barriers.length >= 3) {
                                const oldestBarrier = this.barriers.shift();
                                scene.remove(oldestBarrier);
                                try {
                                    if (gameState.barriers) {
                                        const i = gameState.barriers.indexOf(oldestBarrier);
                                        if (i > -1) gameState.barriers.splice(i, 1);
                                    }
                                } catch (e) {}
                            }
                            
                            this.barriers.push(barrier);
                            
                            // Barrier damages and slows enemies that touch it
                            const checkBarrier = setInterval(() => {
                                if (!barrier.userData.active) {
                                    scene.remove(barrier);
                                    const index = this.barriers.indexOf(barrier);
                                    if (index > -1) this.barriers.splice(index, 1);
                                    clearInterval(checkBarrier);
                                    return;
                                }
                                
                                gameState.enemies.forEach(enemy => {
                                    const dist = barrier.position.distanceTo(enemy.position);
                                    if (dist <= 2.5) {
                                        damageEnemy(enemy, 5);
                                        // Slow enemy
                                        const originalSpeed = enemy.userData.speed;
                                        enemy.userData.speed = originalSpeed * 0.5;
                                        setTimeout(() => {
                                            if (gameState.enemies.includes(enemy)) {
                                                enemy.userData.speed = originalSpeed;
                                            }
                                        }, 1000);
                                    }
                                });
                            }, 500);
                            
                            return true;
                        }
                    },
                    r: {
                        name: 'C4 Detonation',
                        cooldown: 12000,
                        lastUsed: 0,
                        icon: 'C4',
                        execute: function() {
                            const now = Date.now();
                            if (now - this.lastUsed < this.cooldown) return false;
                            
                            this.lastUsed = now;
                            
                            const c4Pos = player.position.clone();
                            const damage = 80;
                            const range = 12;
                            
                            // Evolution: Cluster explosions
                            if (classExp.trapper.evolution > 0) {
                                // Main explosion
                                effectsManager.createExplosion(c4Pos, 0xff0000);
                                
                                // 8 cluster explosions
                                for (let i = 0; i < 8; i++) {
                                    setTimeout(() => {
                                        const angle = (Math.PI * 2 / 8) * i;
                                        const clusterPos = new THREE.Vector3(
                                            c4Pos.x + Math.cos(angle) * 6,
                                            c4Pos.y + Math.sin(angle) * 6,
                                            0
                                        );
                                        
                                        effectsManager.createExplosion(clusterPos, 0xff6600);
                                        
                                        gameState.enemies.forEach(enemy => {
                                            if (!isEnemyOnScreen(enemy)) return;
                                            const dist = clusterPos.distanceTo(enemy.position);
                                            if (dist <= 5) {
                                                damageEnemy(enemy, damage * 0.6);
                                            }
                                        });
                                    }, i * 100);
                                }
                                
                                screenShake(1.5, 1000);
                                return true;
                            }
                            
                            // Normal C4
                            effectsManager.createExplosion(c4Pos, 0xff0000);
                            
                            gameState.enemies.forEach(enemy => {
                                if (!isEnemyOnScreen(enemy)) return;
                                const dist = c4Pos.distanceTo(enemy.position);
                                if (dist <= range) {
                                    damageEnemy(enemy, damage);
                                }
                            });
                            
                            screenShake(1.2, 400);
                            return true;
                        }
                    }
                }
            }
        };
        // Keep immutable baseline of class ability numbers so level bonuses don't compound
        const classBaseline = JSON.parse(JSON.stringify(classes));

        // Apply level-based bonuses to a class' abilities (called whenever level changes)
        function applyClassLevelBonuses(className) {
            if (!classBaseline[className] || !classExp[className]) return;
            const baseline = classBaseline[className];
            const level = Math.max(1, classExp[className].level);

            const damageFactor = 1 + (level - 1) * 0.05; // +5% damage per level
            const cooldownFactor = Math.max(0.4, 1 - (level - 1) * 0.02); // -2% cooldown per level, cap
            const rangeAdd = (level - 1) * 0.1;

            const targetClass = classes[className];
            if (!targetClass || !targetClass.abilities) return;

            Object.keys(targetClass.abilities).forEach(key => {
                const base = baseline.abilities[key] || {};
                const ability = targetClass.abilities[key];
                if (!ability) return;

                if (base.damage !== undefined) ability.damage = Math.max(1, Math.round(base.damage * damageFactor));
                if (base.cooldown !== undefined) ability.cooldown = Math.max(50, Math.round(base.cooldown * cooldownFactor));
                if (base.range !== undefined) ability.range = base.range + rangeAdd;
                if (base.attackInterval !== undefined) ability.attackInterval = Math.max(50, Math.round(base.attackInterval * cooldownFactor));
                if (base.targets !== undefined) ability.targets = Math.max(1, Math.round(base.targets * (1 + (level - 1) * 0.02)));
                if (base.maxChains !== undefined) ability.maxChains = Math.max(1, Math.round(base.maxChains * (1 + (level - 1) * 0.02)));
                if (base.speed !== undefined) ability.speed = Math.max(0.01, base.speed + (level - 1) * 0.005);
                // Support scaling for duration and triggerRadius where present
                if (base.duration !== undefined) ability.duration = Math.max(200, Math.round(base.duration * (1 + (level - 1) * 0.05)));
                if (base.triggerRadius !== undefined) ability.triggerRadius = Math.max(0.1, base.triggerRadius + (level - 1) * 0.05);
            });

            // Slightly increase player's max HP when their selected class levels up
            if (typeof hpManager !== 'undefined') {
                const baseHp = 100; // baseline player HP
                hpManager.maxHp = baseHp + (level - 1) * 2;
                hpManager.currentHp = Math.min(hpManager.currentHp, hpManager.maxHp);
                hpManager.updateUI();
            }

            // Support passive melee damage scaling for classes that define it (e.g., Miner)
            if (baseline.passiveMeleeDamage !== undefined && typeof player !== 'undefined') {
                if (!player.userData) player.userData = {};
                player.userData.meleeDamage = Math.max(1, Math.round(baseline.passiveMeleeDamage * damageFactor));
            }
        }

        // Update all "Buy" buttons to show cost to reach next level
        function updateBuyButtons() {
            if (typeof classExp === 'undefined') return;
            Object.keys(classExp).forEach(className => {
                const btn = document.querySelector(`.buy-exp-btn[onclick*=\"buyExp('${className}')\"]`);
                if (!btn) return;
                const data = classExp[className];
                if (!data) return;
                if (data.level >= 15) {
                    btn.innerHTML = 'Max Level';
                    btn.disabled = true;
                    return;
                }
                const expNeeded = Math.max(0, data.maxExp - data.exp);
                // Display cost using 4 coins per 1 EXP
                const cost = Math.max(4, Math.ceil(expNeeded * 4));
                btn.innerHTML = `Buy Next Level<br>(${cost} coins)`;
                btn.disabled = false;
            });
        }
        
        // Current class and abilities
        let selectedClass = null;
        let abilities = {};
        
        // Class selection
        function selectClass(className) {
            if (typeof classes === 'undefined' || !classes[className]) {
                console.warn('selectClass: classes not initialized yet');
                return;
            }
            // Check if class is unlocked
            if (!isClassUnlocked(className)) {
                alert('This class is locked! Unlock it first.');
                return;
            }
            // Remove any existing shovel mesh when switching classes
            try {
                if (player && player.userData && player.userData.shovelMesh) {
                    try { player.remove(player.userData.shovelMesh); } catch (e) {}
                    delete player.userData.shovelMesh;
                    delete player.userData.shovelAngle;
                    delete player.userData.shovelRadius;
                    delete player.userData.shovelSpeed;
                }
            } catch (e) {}
            selectedClass = classes[className];
            const classAbilities = Object.values(selectedClass.abilities);
            
            abilities = {
                q: classAbilities[0],
                e: classAbilities[1],
                r: classAbilities[2]
            };
            
            // Update ability icons
            document.querySelector('#ability1 .ability-icon').textContent = classAbilities[0].icon;
            document.querySelector('#ability2 .ability-icon').textContent = classAbilities[1].icon;
            document.querySelector('#ability3 .ability-icon').textContent = classAbilities[2].icon;
            // For Summoner, show full text for icons
            if (className === 'summoner') {
                document.querySelector('#ability1 .ability-icon').textContent = 'CMD';
                document.querySelector('#ability2 .ability-icon').textContent = 'SQUAD';
                document.querySelector('#ability3 .ability-icon').textContent = 'GUARD';
            }
            
            // Class selection visual effect
            effectsManager.createClassEffect(player.position, className);

            // Miner-specific initial state (no passive shovel mesh)
            if (className === 'miner') {
                if (!player.userData) player.userData = {};
                player.userData.meleeDamage = 22; // base shovel damage
                player.userData.meleeInterval = 700; // ms between swings
                player.userData.meleeCooldown = 0;
                player.userData.drillUntil = 0;
                // Remove any old shovel mesh if present
                if (player.userData.shovelMesh) {
                    try { player.remove(player.userData.shovelMesh); } catch (e) {}
                    delete player.userData.shovelMesh;
                }
            }
            
            // Update player color based on class
            const classColors = {
                electric: { base: 0xfff367, emissive: 0xfff700 },
                fire: { base: 0xff5c42, emissive: 0xff2000 },
                pierce: { base: 0xd97706, emissive: 0xbf5f00 },
                engineer: { base: 0xffb347, emissive: 0xff8c00 },
                life: { base: 0xff4d4d, emissive: 0xff1f1f },
                summoner: { base: 0x8b5cf6, emissive: 0x6d28d9 },
                water: { base: 0x38bdf8, emissive: 0x0ea5d8 },
                miner: { base: 0xd97706, emissive: 0xbf5f00 }
            };
            
            if (classColors[className]) {
                try {
                    // Regenerate gradient texture so the player's `map` reflects class colors
                    const newMap = createGradientTexture(classColors[className].base, classColors[className].emissive, true, 256);
                    player.material.map = newMap;
                    player.material.color.setHex(0xffffff);
                    player.material.emissive.setHex(classColors[className].emissive);
                    player.material.emissiveIntensity = 0.08;
                    player.material.needsUpdate = true;
                    // Update glow ring color if present
                    try { if (typeof glowRing !== 'undefined' && glowRing && glowRing.material) glowRing.material.color.setHex(classColors[className].base); } catch (e) {}
                    // Update first child (legacy code used this) and shovel if present
                    if (player.children[0] && player.children[0].material) {
                        player.children[0].material.color.setHex(classColors[className].base);
                    }
                    if (player.userData && player.userData.shovelMesh && player.userData.shovelMesh.material) {
                        player.userData.shovelMesh.material.color.setHex(classColors[className].base);
                    }
                } catch (e) { console.warn('Failed to apply class gradient', e); }
            }
            
            // Hide class selection
            document.getElementById('classSelection').style.display = 'none';

            // Persist this selection so we can restore it on next load (only the class choice)
            try { localStorage.setItem('lastSelectedClass', className); } catch (e) { /* ignore */ }

            // Update mobile button labels (use ability icon/text rather than Q/E/R)
            try {
                const m1 = document.querySelector('#mAbility1 .mobile-ability-label');
                const m2 = document.querySelector('#mAbility2 .mobile-ability-label');
                const m3 = document.querySelector('#mAbility3 .mobile-ability-label');
                if (m1) m1.textContent = (classAbilities[0] && classAbilities[0].icon) ? classAbilities[0].icon : 'Primary';
                if (m2) m2.textContent = (classAbilities[1] && classAbilities[1].icon) ? classAbilities[1].icon : 'Secondary';
                if (m3) m3.textContent = (classAbilities[2] && classAbilities[2].icon) ? classAbilities[2].icon : 'Ultimate';
            } catch (e) { /* ignore */ }
            
            // Life class passive HP drain
            if (className === 'life') {
                setInterval(() => {
                    if (!gameState.isGameOver && selectedClass && selectedClass.name === 'Life') {
                        // Drain 5 HP, but don't drop below 1
                        const newHP = hpManager.currentHp - 5;
                        if (newHP <= 1) {
                            hpManager.currentHp = 1;
                            hpManager.updateUI();
                        } else {
                            hpManager.damage(5);
                        }
                    }
                }, 1000);
            }
            
            // Show ammo counter for Engineer (selection only)
            const ammoCounter = document.getElementById('ammoCounter');
            if (className === 'engineer') {
                ammoCounter.style.display = 'block';
                gameState.machineGunAmmo = gameState.maxMachineGunAmmo;
                document.getElementById('ammoCount').textContent = gameState.machineGunAmmo;
            } else {
                ammoCounter.style.display = 'none';
            }

            // DO NOT enable wave system here; only mark the class as selected and return to home screen.
            // Show the home screen so the player can press PLAY (which will actually start the run).
            document.getElementById('homeScreen').style.display = 'flex';

            // Hide HUD Home button while on the home screen
            const hb = document.getElementById('homeButton');
            if (hb) hb.style.display = 'none';
            // Hide ability UI and mobile controls while on home screen
            try { const ab = document.getElementById('abilities'); if (ab) ab.style.display = 'none'; } catch (e) {}
            try { const mc = document.getElementById('mobileControls'); if (mc) mc.style.display = 'none'; } catch (e) {}
            
            // Initialize wave progress
            document.getElementById('waveProgress').style.width = '0%';
            document.getElementById('waveProgressText').textContent = '0 / 10';
        }
        
        // Old abilities - will be replaced by class selection
        const oldAbilities = {
            lightning: {
                cooldown: 3000,
                lastUsed: 0,
                damage: 50,
                range: 5,
                chainRange: 4,
                maxChains: 3,
                execute: function() {
                    const now = Date.now();
                    if (now - this.lastUsed < this.cooldown) return false;
                    
                    this.lastUsed = now;
                    console.log('Lightning: Searching for enemies, count:', gameState.enemies.length);
                    
                    // Find closest enemy
                    let closest = null;
                    let closestDist = Infinity;
                    
                    gameState.enemies.forEach(enemy => {
                        const dist = player.position.distanceTo(enemy.position);
                        console.log('Enemy at distance:', dist);
                        if (dist < closestDist && dist <= this.range) {
                            closest = enemy;
                            closestDist = dist;
                        }
                    });
                    
                    if (closest) {
                        console.log('Lightning hit enemy at distance:', closestDist);
                        effectsManager.createLightningBolt(player.position, closest.position);
                        damageEnemy(closest, this.damage);
                        
                        // Chain lightning to nearby enemies
                        let hitEnemies = [closest];
                        let currentSource = closest;
                        
                        for (let i = 0; i < this.maxChains; i++) {
                            let nextTarget = null;
                            let nextDist = Infinity;
                            
                            gameState.enemies.forEach(enemy => {
                                if (hitEnemies.includes(enemy)) return;
                                const dist = currentSource.position.distanceTo(enemy.position);
                                if (dist < nextDist && dist <= this.chainRange) {
                                    nextTarget = enemy;
                                    nextDist = dist;
                                }
                            });
                            
                            if (nextTarget) {
                                setTimeout(() => {
                                    effectsManager.createLightningBolt(currentSource.position, nextTarget.position);
                                    damageEnemy(nextTarget, this.damage * 0.7); // Reduced damage for chained hits
                                }, 100 * (i + 1));
                                
                                hitEnemies.push(nextTarget);
                                currentSource = nextTarget;
                            } else {
                                break;
                            }
                        }
                    } else {
                        console.log('No enemy in range (range:', this.range, ')');
                        // Still show effect at player position
                        const targetPos = player.position.clone();
                        targetPos.x += 2;
                        effectsManager.createLightningBolt(player.position, targetPos);
                    }
                    
                    return true;
                }
            },
            fireball: {
                cooldown: 5000,
                lastUsed: 0,
                damage: 40,
                speed: 0.3,
                execute: function() {
                    const now = Date.now();
                    if (now - this.lastUsed < this.cooldown) return false;
                    
                    this.lastUsed = now;
                    console.log('Fireball: Searching for enemies, count:', gameState.enemies.length);
                    
                    // Find closest enemy for targeting
                    let target = null;
                    let closestDist = Infinity;
                    
                    gameState.enemies.forEach(enemy => {
                        const dist = player.position.distanceTo(enemy.position);
                        if (dist < closestDist) {
                            target = enemy;
                            closestDist = dist;
                        }
                    });
                    
                    // Shoot towards target or forward
                    let direction;
                    if (target) {
                        console.log('Fireball targeting enemy');
                        direction = new THREE.Vector3()
                            .subVectors(target.position, player.position)
                            .normalize();
                    } else {
                        console.log('No target, shooting forward');
                        // Shoot in the direction player is facing
                        const angle = player.rotation.z + Math.PI / 2;
                        direction = new THREE.Vector3(Math.cos(angle), Math.sin(angle), 0);
                    }
                    
                    const projectile = effectsManager.createFireball(player.position, direction, this.speed);
                    // Extend userData instead of overwriting to preserve direction and speed
                    Object.assign(projectile.userData, {
                        damage: this.damage,
                        lifetime: 5000,
                        created: Date.now()
                    });
                    gameState.projectiles.push(projectile);
                    
                    return true;
                }
            },
            wave: {
                cooldown: 8000,
                lastUsed: 0,
                damage: 25,
                knockbackForce: 8,
                execute: function() {
                    const now = Date.now();
                    if (now - this.lastUsed < this.cooldown) return false;
                    
                    this.lastUsed = now;
                    console.log('Wave: Knocking back enemies');
                    
                    const waveRange = 8;
                    effectsManager.createWave(player.position, waveRange);
                    
                    gameState.enemies.forEach(enemy => {
                        const dist = player.position.distanceTo(enemy.position);
                        if (dist <= waveRange) {
                            // Calculate knockback direction (away from player)
                            const knockbackDir = new THREE.Vector3()
                                .subVectors(enemy.position, player.position)
                                .normalize();
                            
                            // Apply knockback force (stronger when closer)
                            const knockbackStrength = this.knockbackForce * (1 - dist / waveRange);
                            enemy.position.x += knockbackDir.x * knockbackStrength;
                            enemy.position.y += knockbackDir.y * knockbackStrength;
                            
                            // Keep within arena bounds
                            enemy.position.x = Math.max(-24, Math.min(24, enemy.position.x));
                            enemy.position.y = Math.max(-24, Math.min(24, enemy.position.y));
                            
                            // Still apply damage
                            damageEnemy(enemy, this.damage);
                        }
                    });
                    
                    return true;
                }
            }
        };
        
        // Damage enemy
        function damageEnemy(enemy, damage) {
            // Prevent damage to far off-screen enemies, but allow close-range hits (melee) to apply
            try {
                if (!isEnemyOnScreen(enemy)) {
                    // If enemy is close to the player (melee range), still allow damage
                    if (typeof player !== 'undefined' && enemy.position.distanceTo(player.position) <= 3) {
                        // allow melee/close damage even if off-screen
                    } else {
                        if (gameState.debugAI) console.log(`damageEnemy: skipped damage to off-screen enemy id=${enemy.id}`);
                        return;
                    }
                }
            } catch (e) {}
            // Shield behaviour: absorb or reduce first hit(s)
            try {
                if (enemy.userData && enemy.userData.shieldHits && enemy.userData.shieldHits > 0) {
                    // Reduce incoming damage and consume a shield hit
                    damage = Math.floor(damage * 0.5);
                    enemy.userData.shieldHits -= 1;
                    if (gameState.debugAI) console.log(`damageEnemy: shield absorbed part of dmg for enemy id=${enemy.id}, remaining shieldHits=${enemy.userData.shieldHits}`);
                }
            } catch (e) {}
            enemy.userData.hp -= damage;
            effectsManager.createDamageNumber(enemy.position, damage);
            
            // Hit flash effect
            const originalColor = enemy.material.color.getHex();
            enemy.material.color.setHex(0xffffff);
            setTimeout(() => {
                if (enemy.material) {
                    enemy.material.color.setHex(originalColor);
                }
            }, 50);
            
            if (enemy.userData.hp <= 0) {
                // Death animation
                const deathDuration = 300;
                const startTime = Date.now();
                const startScale = enemy.scale.clone();
                const startY = enemy.position.y;
                
                enemy.userData.dying = true;
                
                const deathAnim = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / deathDuration, 1);
                    
                    if (progress < 1) {
                        // Shrink and fade
                        enemy.scale.set(
                            startScale.x * (1 - progress),
                            startScale.y * (1 - progress),
                            startScale.z * (1 - progress)
                        );
                        enemy.position.y = startY - progress * 2;
                        enemy.material.opacity = 1 - progress;
                        enemy.rotation.x += 0.2;
                        enemy.rotation.y += 0.2;
                        requestAnimationFrame(deathAnim);
                    } else {
                        scene.remove(enemy);
                        // Remove any associated HP UI immediately
                        try {
                            if (enemy.userData && enemy.userData.hpUI && enemy.userData.hpUI.el) {
                                enemy.userData.hpUI.el.remove();
                            }
                        } catch (e) {}
                        const index = gameState.enemies.indexOf(enemy);
                        if (index > -1) gameState.enemies.splice(index, 1);
                                // Award coins to player based on enemy type (scaled by wave)
                                try {
                                    const baseRewards = { melee: 5, ranged: 6, speed: 5, invisible: 8, tank: 15 };
                                    let reward = enemy.userData && enemy.userData.isBoss ? Math.floor(50 + gameState.currentWave * 10) : (baseRewards[enemy.userData.type] || 5);
                                    // Scale a bit with enemy maxHp to reward tougher enemies
                                    if (enemy.userData && enemy.userData.maxHp) {
                                        reward = Math.max(reward, Math.floor(reward * (enemy.userData.maxHp / 40)));
                                    }
                                    gameState.coins = (gameState.coins || 0) + reward;
                                    updateCoinDisplay();
                                    // Track quest progress: coins earned
                                    if (typeof trackQuestProgress === 'function') trackQuestProgress('totalCoinsEarned', reward);
                                    // Show reward popup
                                    if (typeof effectsManager !== 'undefined' && effectsManager.createDamageNumber) {
                                        effectsManager.createDamageNumber(enemy.position, reward);
                                    }
                                } catch (e) {}
                                // Award EXP to the player's selected class based on enemy type
                                try {
                                    const expBase = { melee: 2, ranged: 3, speed: 2, invisible: 4, tank: 8 };
                                    let expGain = enemy.userData && enemy.userData.isBoss ? Math.floor(20 + (gameState.currentWave || 1) * 5) : (expBase[enemy.userData.type] || 2);
                                    // Scale slightly with enemy maxHp
                                    if (enemy.userData && enemy.userData.maxHp) {
                                        expGain = Math.max(expGain, Math.floor(expGain * (enemy.userData.maxHp / 40)));
                                    }
                                    if (gameState.classSelected && typeof selectedClass !== 'undefined' && selectedClass && classExp[selectedClass]) {
                                        const ce = classExp[selectedClass];
                                        ce.exp = (ce.exp || 0) + expGain;
                                        // Level up loop
                                        while (ce.exp >= ce.maxExp && ce.level < 15) {
                                            ce.exp -= ce.maxExp;
                                            ce.level++;
                                            if (ce.level === 15) {
                                                ce.evolution = (ce.evolution || 0) + 1;
                                            }
                                            // increase next level cap modestly
                                            ce.maxExp = Math.min(1000, Math.floor(ce.maxExp * 1.15));
                                        }
                                        // Update displays
                                        try { updateExpDisplays(); } catch (e) {}
                                        try { updateBuyButtons(); } catch (e) {}
                                        // Visual feedback for EXP gain
                                        try { if (typeof effectsManager !== 'undefined' && effectsManager.createDamageNumber) effectsManager.createDamageNumber(enemy.position, '+' + expGain + ' EXP'); } catch (e) {}
                                    }
                                } catch (e) {}
                                // Clear any claims this enemy held on targets
                        try {
                            const claimerId = enemy.id;
                            if (gameState.allies) {
                                gameState.allies.forEach(a => {
                                    if (a.userData && a.userData.claimedBy === claimerId) a.userData.claimedBy = null;
                                });
                            }
                            if (gameState.turrets) {
                                gameState.turrets.forEach(t => {
                                    if (t.userData && t.userData.claimedBy === claimerId) t.userData.claimedBy = null;
                                });
                            }
                            if (gameState.player && gameState.player.userData && gameState.player.userData.claimedBy === claimerId) {
                                gameState.player.userData.claimedBy = null;
                            }
                        } catch (e) {
                            // ignore
                        }
                    }
                };
                
                deathAnim();
                
                // Enemy killed
                
                // Track quest progress: kills and boss kills
                if (typeof trackQuestProgress === 'function') {
                    trackQuestProgress('totalKills', 1);
                    if (enemy.userData && enemy.userData.isBoss) {
                        trackQuestProgress('bossKills', 1);
                    }
                }
                
                // Update wave progress
                if (gameState.classSelected) {
                    gameState.enemiesKilledThisWave++;
                    const progressPercent = Math.min(100, (gameState.enemiesKilledThisWave / gameState.enemiesPerWave) * 100);
                    document.getElementById('waveProgress').style.width = progressPercent + '%';
                    document.getElementById('waveProgressText').textContent = gameState.enemiesKilledThisWave + ' / ' + gameState.enemiesPerWave;
                }
                
                const deathColor = enemy.userData.isBoss ? 0xfbbf24 : 0x4ade80;
                effectsManager.createDeathExplosion(enemy.position, deathColor);
            }
        }

        // Resolve simple circle-based collisions between player, allies, enemies, and turrets
        function resolveEntityCollisions() {
            const entities = [];
            if (gameState.player) entities.push(gameState.player);
            if (gameState.allies && gameState.allies.length) entities.push(...gameState.allies);
            if (gameState.enemies && gameState.enemies.length) entities.push(...gameState.enemies);
            if (gameState.turrets && gameState.turrets.length) entities.push(...gameState.turrets);

            for (let i = 0; i < entities.length; i++) {
                for (let j = i + 1; j < entities.length; j++) {
                    const a = entities[i];
                    const b = entities[j];
                    if (!a.position || !b.position) continue;

                    const rA = (a.userData && a.userData.collisionRadius) ? a.userData.collisionRadius : 0.8;
                    const rB = (b.userData && b.userData.collisionRadius) ? b.userData.collisionRadius : 0.8;

                    const dx = a.position.x - b.position.x;
                    const dy = a.position.y - b.position.y;
                    let dist = Math.sqrt(dx * dx + dy * dy);
                    const minDist = rA + rB;

                    if (dist < 0.001) dist = 0.001;

                    if (dist < minDist) {
                        const overlap = minDist - dist;
                        const nx = dx / dist;
                        const ny = dy / dist;
                        const aImmovable = a.userData && a.userData.isTurret;
                        const bImmovable = b.userData && b.userData.isTurret;
                        const aIsPlayer = (gameState.player === a);
                        const bIsPlayer = (gameState.player === b);
                        const aIsEnemy = gameState.enemies && gameState.enemies.includes(a);
                        const bIsEnemy = gameState.enemies && gameState.enemies.includes(b);

                        if (aImmovable && bImmovable) continue;

                        // Prevent enemies from pushing the player: if one side is player and the other an enemy,
                        // only move the enemy, never the player.
                        if (aIsPlayer && bIsEnemy) {
                            // move enemy b away from player a
                            b.position.x -= nx * overlap;
                            b.position.y -= ny * overlap;
                        } else if (bIsPlayer && aIsEnemy) {
                            a.position.x += nx * overlap;
                            a.position.y += ny * overlap;
                        } else if (aImmovable) {
                            b.position.x -= nx * overlap;
                            b.position.y -= ny * overlap;
                        } else if (bImmovable) {
                            a.position.x += nx * overlap;
                            a.position.y += ny * overlap;
                        } else {
                            a.position.x += nx * (overlap * 0.5);
                            a.position.y += ny * (overlap * 0.5);
                            b.position.x -= nx * (overlap * 0.5);
                            b.position.y -= ny * (overlap * 0.5);
                        }
                    }
                }
            }
        }

        // Update and trigger mines
        function updateMines(deltaTime) {
            if (!gameState.mines || gameState.mines.length === 0) return;
            for (let i = gameState.mines.length - 1; i >= 0; i--) {
                const mine = gameState.mines[i];
                if (!mine || !mine.active) continue;
                // Check enemies stepping on mine
                let triggered = false;
                gameState.enemies.forEach(enemy => {
                    if (!enemy) return;
                    const dist = enemy.position.distanceTo(mine.mesh.position);
                    if (dist <= mine.triggerRadius) triggered = true;
                });
                if (triggered) {
                    // Explode
                    const pos = mine.mesh.position.clone();
                    effectsManager.createExplosion(pos, 0xffcc00);
                    const explosionRange = 3.5;
                    gameState.enemies.forEach(enemy => {
                        const d = enemy.position.distanceTo(pos);
                        if (d <= explosionRange) {
                            damageEnemy(enemy, mine.damage);
                        }
                    });
                    // Remove mine
                    try { scene.remove(mine.mesh); } catch (e) {}
                    gameState.mines.splice(i, 1);
                }
            }
        }

        // When an ally dies, remove it from the game
        function handleAllyDown(ally) {
            try {
                // Remove HP UI if exists
                if (ally.userData && ally.userData.hpUI && ally.userData.hpUI.el) {
                    ally.userData.hpUI.el.remove();
                }
                // Death explosion effect
                effectsManager.createExplosion(ally.position, 0x3b82f6);
                // Remove from scene
                scene.remove(ally);
                // Remove from allies array
                const allyIndex = gameState.allies.indexOf(ally);
                if (allyIndex > -1) gameState.allies.splice(allyIndex, 1);
                // Also check minions array
                if (gameState.minions) {
                    const minionIndex = gameState.minions.indexOf(ally);
                    if (minionIndex > -1) gameState.minions.splice(minionIndex, 1);
                }
            } catch (e) {
                // ignore
            }
        }
        
        // Create screen-space HP UI for an ally
        function createAllyHPUI(ally) {
            try {
                if (!ally) return;
                let layer = document.getElementById('allyHpLayer');
                if (!layer) { layer = document.createElement('div'); layer.id = 'allyHpLayer'; document.body.appendChild(layer); }
                const hpEl = document.createElement('div');
                hpEl.className = 'ally-hp';
                const radius = (ally.userData && ally.userData.collisionRadius) ? ally.userData.collisionRadius : 0.8;
                const fullWidthPx = Math.max(30, Math.round(30 * radius + 30));
                hpEl.style.width = (fullWidthPx) + 'px';
                hpEl.innerHTML = '<div class="bar-bg"><div class="bar-fg"></div></div>';
                layer.appendChild(hpEl);
                ally.userData.hpUI = { el: hpEl, fullWidth: fullWidthPx, radius };
            } catch (e) { console.warn('Failed to create ally hp UI', e); }
        }
        
        // Screen shake effect
        let cameraShake = { intensity: 0, duration: 0, startTime: 0 };
        
        function screenShake(intensity, duration) {
            cameraShake = {
                intensity: intensity,
                duration: duration,
                startTime: Date.now()
            };
        }
        
        function updateCameraShake() {
            if (cameraShake.intensity > 0) {
                const elapsed = Date.now() - cameraShake.startTime;
                if (elapsed < cameraShake.duration) {
                    const progress = elapsed / cameraShake.duration;
                    const currentIntensity = cameraShake.intensity * (1 - progress);
                    camera.position.x = (Math.random() - 0.5) * currentIntensity;
                    camera.position.y = (Math.random() - 0.5) * currentIntensity;
                } else {
                    camera.position.x = 0;
                    camera.position.y = 0;
                    cameraShake.intensity = 0;
                }
            }
        }
        
        // Input handling
        const keys = { q: false, e: false, r: false };
        
        window.addEventListener('keydown', (e) => {
            const key = e.key.toLowerCase();
            
            if (gameState.isGameOver) return;
            
            if (key === 'q' && abilities.q) {
                if (abilities.q.execute()) {
                    updateAbilityCooldown('ability1', abilities.q.cooldown);
                    document.getElementById('ability1').style.transform = 'scale(0.9)';
                    setTimeout(() => {
                        document.getElementById('ability1').style.transform = 'scale(1)';
                    }, 100);
                }
            } else if (key === 'e' && abilities.e) {
                if (abilities.e.execute()) {
                    updateAbilityCooldown('ability2', abilities.e.cooldown);
                    document.getElementById('ability2').style.transform = 'scale(0.9)';
                    setTimeout(() => {
                        document.getElementById('ability2').style.transform = 'scale(1)';
                    }, 100);
                }
            } else if (key === 'r' && abilities.r) {
                // Engineer uses hold-down mechanic, others use single press
                if (selectedClass && selectedClass.name === 'Engineer') {
                    if (!keys.r) {
                        keys.r = true;
                    }
                } else {
                    // Single press for other classes
                    const result = abilities.r.execute();
                    if (result === 'reload') {
                        updateAbilityCooldown('ability3', abilities.r.cooldown);
                    } else if (result || result === true) {
                        updateAbilityCooldown('ability3', abilities.r.cooldown);
                        document.getElementById('ability3').style.transform = 'scale(0.9)';
                        setTimeout(() => {
                            document.getElementById('ability3').style.transform = 'scale(1)';
                        }, 100);
                    }
                }
            }
        });
        
        window.addEventListener('keyup', (e) => {
            const key = e.key.toLowerCase();
            if (key === 'r') {
                keys.r = false;
            }
        });
        
        // Convert enemy to ally
        function convertToAlly(enemy) {
            if (!gameState.allies) {
                gameState.allies = [];
            }
            
            // Remove from enemies array
            const index = gameState.enemies.indexOf(enemy);
            if (index > -1) {
                gameState.enemies.splice(index, 1);
                
                // Count as killed for wave progress
                gameState.enemiesKilledThisWave++;
                const progressPercent = Math.min(100, (gameState.enemiesKilledThisWave / gameState.enemiesPerWave) * 100);
                document.getElementById('waveProgress').style.width = progressPercent + '%';
                document.getElementById('waveProgressText').textContent = gameState.enemiesKilledThisWave + ' / ' + gameState.enemiesPerWave;
            }
            
            // Change color to blue
            enemy.material.color.setHex(0x3b82f6);
            
            // Set ally data
            enemy.userData.isAlly = true;
            enemy.userData.allyUntil = Date.now() + 15000; // 15 second duration
            enemy.userData.hp = 50; // Give allies HP
            enemy.userData.maxHp = 50; // Set max HP for HP bar
            enemy.userData.attackCooldown = 0;
            enemy.userData.attackInterval = 1000; // Attack once per second
            enemy.userData.rotationSpeed = 0.02;
            
            // Add to allies array
            gameState.allies.push(enemy);
        }
        
        // Ability UI updates
        const cooldownIntervals = {};
        
        function updateAbilityCooldown(abilityId, cooldownTime) {
            const abilityEl = document.getElementById(abilityId);
            const overlay = abilityEl.querySelector('.cooldown-overlay');
            const text = abilityEl.querySelector('.cooldown-text');
            
            abilityEl.classList.add('disabled');
            overlay.style.height = '100%';
            // ensure mobile button overlay/text show immediately when cooldown starts
            try {
                const mobileMap = { 'ability1': 'mAbility1', 'ability2': 'mAbility2', 'ability3': 'mAbility3' };
                const mid0 = mobileMap[abilityId];
                if (mid0) {
                    const mbtn0 = document.getElementById(mid0);
                    if (mbtn0) {
                        const mOverlay0 = mbtn0.querySelector('.mobile-cooldown-overlay');
                        const mText0 = mbtn0.querySelector('.mobile-cooldown-text');
                        if (mOverlay0) mOverlay0.style.height = '100%';
                        if (mText0) mText0.textContent = Math.ceil(cooldownTime / 1000) || '';
                        mbtn0.classList.add('disabled');
                    }
                }
            } catch (e) { /* ignore */ }
            
            const startTime = Date.now();
            const interval = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const remaining = Math.max(0, cooldownTime - elapsed);
                const percentage = (remaining / cooldownTime) * 100;

                overlay.style.height = percentage + '%';
                text.textContent = Math.ceil(remaining / 1000);

                // Also update mobile button if present
                try {
                    const mobileMap = { 'ability1': 'mAbility1', 'ability2': 'mAbility2', 'ability3': 'mAbility3' };
                    const mid = mobileMap[abilityId];
                    if (mid) {
                        const mbtn = document.getElementById(mid);
                        if (mbtn) {
                            const mOverlay = mbtn.querySelector('.mobile-cooldown-overlay');
                            const mText = mbtn.querySelector('.mobile-cooldown-text');
                            if (mOverlay) mOverlay.style.height = percentage + '%';
                            if (mText) mText.textContent = '';
                            if (remaining <= 0) {
                                if (mOverlay) mOverlay.style.height = '0%';
                                if (mText) mText.textContent = '';
                                mbtn.classList.remove('disabled');
                            }
                        }
                    }
                } catch (e) { /* ignore */ }

                if (remaining <= 0) {
                    clearInterval(interval);
                    delete cooldownIntervals[abilityId];
                    abilityEl.classList.remove('disabled');
                    text.textContent = '';
                }
            }, 100);

            cooldownIntervals[abilityId] = { interval, startTime, totalCooldown: cooldownTime };
        }
        
        function reduceCooldownDisplay(abilityId, reductionAmount) {
            const cooldownData = cooldownIntervals[abilityId];
            if (!cooldownData) return;
            
            // Restart the cooldown with reduced time
            clearInterval(cooldownData.interval);
            const elapsed = Date.now() - cooldownData.startTime;
            const newCooldown = Math.max(0, cooldownData.totalCooldown - elapsed - reductionAmount);
            
            const abilityEl = document.getElementById(abilityId);
            const overlay = abilityEl.querySelector('.cooldown-overlay');
            const text = abilityEl.querySelector('.cooldown-text');
            
            if (newCooldown <= 0) {
                delete cooldownIntervals[abilityId];
                abilityEl.classList.remove('disabled');
                text.textContent = '';
                overlay.style.height = '0%';
                return;
            }
            
            const newStartTime = Date.now();
            const interval = setInterval(() => {
                const elapsed = Date.now() - newStartTime;
                const remaining = Math.max(0, newCooldown - elapsed);
                const percentage = (remaining / newCooldown) * 100;
                
                overlay.style.height = percentage + '%';
                text.textContent = Math.ceil(remaining / 1000);
                
                if (remaining <= 0) {
                    clearInterval(interval);
                    delete cooldownIntervals[abilityId];
                    abilityEl.classList.remove('disabled');
                    text.textContent = '';
                }
            }, 100);
            
            cooldownIntervals[abilityId] = { interval, startTime: newStartTime, totalCooldown: newCooldown };
        }
        
        // Update projectiles
        function updateProjectiles(deltaTime) {
            const now = Date.now();
            // Miner passive projectiles: shovels and drills
            // Move and handle collision for these
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const proj = gameState.projectiles[i];
                if (proj.userData.isShovel || proj.userData.isDrill) {
                    // Move forward
                    proj.position.x += proj.userData.velocity.x;
                    proj.position.y += proj.userData.velocity.y;
                    // Optional: spin shovel for effect
                    if (proj.userData.isShovel) proj.rotation.z += 0.35;
                    // Lifetime: 1.5s for shovel, 2.2s for drill
                    const maxLifetime = proj.userData.isDrill ? 2200 : 1500;
                    if (!proj.userData.created) proj.userData.created = Date.now();
                    if (now - proj.userData.created > maxLifetime) {
                        scene.remove(proj);
                        gameState.projectiles.splice(i, 1);
                        continue;
                    }
                    // Collision with enemies
                    let hit = false;
                    const hitRadius = proj.userData.isDrill ? 1.0 : 0.7;
                    let pierce = proj.userData.pierce || 1;
                    if (!proj.userData.hitEnemies) proj.userData.hitEnemies = [];
                    for (const enemy of gameState.enemies) {
                        if (proj.userData.hitEnemies.includes(enemy)) continue;
                        if (proj.position.distanceTo(enemy.position) < hitRadius) {
                            damageEnemy(enemy, proj.userData.damage);
                            proj.userData.hitEnemies.push(enemy);
                            pierce--;
                            effectsManager.createExplosion(enemy.position, proj.userData.isDrill ? 0xd1b000 : 0xffe066);
                            if (pierce <= 0) {
                                hit = true;
                                break;
                            }
                        }
                    }
                    if (hit) {
                        scene.remove(proj);
                        gameState.projectiles.splice(i, 1);
                        continue;
                    }
                }
            }
            
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const proj = gameState.projectiles[i];
                
                // Handle arcing projectiles (arrow storm)
                if (proj.userData.isArcing) {
                    proj.userData.travelTime += deltaTime;
                    const progress = Math.min(proj.userData.travelTime / 1000, 1);
                    
                    // Interpolate position
                    proj.position.x = proj.userData.startPos.x + (proj.userData.targetPos.x - proj.userData.startPos.x) * progress;
                    proj.position.y = proj.userData.startPos.y + (proj.userData.targetPos.y - proj.userData.startPos.y) * progress;
                    proj.position.z = Math.sin(progress * Math.PI) * proj.userData.arcHeight;
                    
                    // Check collision during arc (for piercing arrows)
                    if (proj.userData.isPiercing) {
                        const hitRadius = 0.8;
                        gameState.enemies.forEach(enemy => {
                            if (!proj.userData.hitEnemies.includes(enemy) && 
                                proj.position.distanceTo(enemy.position) < hitRadius) {
                                // Do 30 damage after first hit to incentivize lining up shots
                                const damage = proj.userData.pierceCount > 0 ? 30 : proj.userData.damage;
                                damageEnemy(enemy, damage);
                                proj.userData.hitEnemies.push(enemy);
                                proj.userData.pierceCount++;
                                effectsManager.createExplosion(enemy.position, 0x8b4513);
                            }
                        });
                    }
                    
                    // Remove if reached end of arc
                    if (progress >= 1) {
                        scene.remove(proj);
                        gameState.projectiles.splice(i, 1);
                        continue;
                    }
                } else {
                    // Move projectile normally only if direction and speed are defined
                    if (proj.userData.direction && typeof proj.userData.speed === 'number') {
                        proj.position.x += proj.userData.direction.x * proj.userData.speed;
                        proj.position.y += proj.userData.direction.y * proj.userData.speed;
                    }
                    // Add trail effect for fireballs and arrows
                    if (Math.random() < 0.3) {
                        if (proj.userData.isFireball) {
                            effectsManager.createProjectileTrail(proj.position, 0xff6600);
                        } else if (proj.userData.isPiercing) {
                            effectsManager.createProjectileTrail(proj.position, 0x8b4513);
                        }
                    }
                }
                
                // Check collision with enemies or player
                let hit = false;
                
                // Check if enemy projectile hits barriers
                if (proj.userData.isEnemyProjectile && abilities.e && abilities.e.barriers) {
                    abilities.e.barriers.forEach(barrier => {
                        if (barrier.userData.active) {
                            const dist = barrier.position.distanceTo(proj.position);
                            if (dist <= 2.5) {
                                hit = true;
                            }
                        }
                    });
                }
                
                // Handle enemy projectiles hitting player/allies
                if (proj.userData.isEnemyProjectile && !hit) {
                    const hitRadius = 0.5;
                    
                    if (proj.userData.targetIsAlly) {
                        // Check collision with the specific targeted ally (if still exists)
                        if (proj.userData.target && (gameState.allies.includes(proj.userData.target) || (gameState.minions && gameState.minions.includes(proj.userData.target)))) {
                            const dist = proj.position.distanceTo(proj.userData.target.position);
                            if (dist < hitRadius) {
                                proj.userData.target.userData.hp -= proj.userData.damage;
                                effectsManager.createDamageNumber(proj.userData.target.position, proj.userData.damage);
                                if (proj.userData.target.userData.hp <= 0) {
                                    handleAllyDown(proj.userData.target);
                                }
                                hit = true;
                            }
                        } else {
                            hit = true; // Target no longer exists
                        }
                    }

                    // If not already hit, check collision with any nearby ally/minion (covers stray projectiles)
                    if (!hit) {
                        const allyList = [];
                        if (gameState.allies && gameState.allies.length) allyList.push(...gameState.allies);
                        if (gameState.minions && gameState.minions.length) allyList.push(...gameState.minions);
                        for (const a of allyList) {
                            if (!a || !a.position || !a.userData) continue;
                            const d = proj.position.distanceTo(a.position);
                            if (d < hitRadius) {
                                a.userData.hp = (a.userData.hp != null) ? a.userData.hp - proj.userData.damage : ( (a.userData.maxHp || 50) - proj.userData.damage );
                                try { effectsManager.createDamageNumber(a.position, proj.userData.damage); } catch (e) {}
                                if (a.userData.hp <= 0) handleAllyDown(a);
                                hit = true;
                                break;
                            }
                        }
                    }

                    // If still not hit, check collision with player as fallback
                    if (!hit) {
                        const dist = proj.position.distanceTo(gameState.player.position);
                        if (dist < hitRadius) {
                            if (!gameState.isInvulnerable) {
                                hpManager.damage(proj.userData.damage);
                                gameState.lastDamageTime = Date.now();
                                if (hpManager.isDead()) {
                                    gameOver();
                                }
                                if (gameState.debugAI) console.log(`updateProjectiles: projectile hit player dmg=${proj.userData.damage} playerHp=${hpManager.currentHp}`);
                            } else {
                                if (gameState.debugAI) console.log(`updateProjectiles: projectile blocked by invulnerability dmg=${proj.userData.damage} invulnerable=${gameState.isInvulnerable} invisible=${gameState.isInvisible}`);
                            }
                            hit = true;
                        }
                    }
                } else if (proj.userData.isFireball) {
                    // Fireballs have larger trigger radius and always do AoE
                    const triggerRadius = 3;
                    const aoeRadius = 5;
                    
                    gameState.enemies.forEach(enemy => {
                        if (proj.position.distanceTo(enemy.position) < triggerRadius) {
                            hit = true;
                        }
                    });
                    
                    if (hit) {
                        // Evolution: Massive AoE explosion
                        const finalRadius = proj.userData.isEvolved ? proj.userData.explosionRange : aoeRadius;
                        effectsManager.createWave(proj.position, finalRadius);
                        effectsManager.createExplosion(proj.position, 0xff6600);
                        if (proj.userData.isEvolved) {
                            // Extra visual effects for evolved
                            setTimeout(() => effectsManager.createWave(proj.position, finalRadius * 0.7), 100);
                            setTimeout(() => effectsManager.createExplosion(proj.position, 0xffaa00), 150);
                        }
                        
                        let aoeHitCount = 0;
                        gameState.enemies.forEach(enemy => {
                            const dist = proj.position.distanceTo(enemy.position);
                            if (dist <= finalRadius) {
                                damageEnemy(enemy, proj.userData.damage);
                                aoeHitCount++;
                                
                                // Apply burn
                                enemy.userData.burning = true;
                                enemy.userData.burnEnd = now + proj.userData.burnDuration;
                                enemy.userData.burnDamage = proj.userData.burnDamage;
                                enemy.userData.lastBurnTick = now;
                            }
                        });
                        
                        // Track shared hit count for multi-fireball ability
                        if (proj.userData.sharedHitCount) {
                            proj.userData.sharedHitCount.count += aoeHitCount;
                            if (proj.userData.sharedHitCount.count >= proj.userData.hitThreshold && proj.userData.abilityRef) {
                                const reduction = proj.userData.abilityRef.cooldown * proj.userData.cooldownReduction;
                                proj.userData.abilityRef.lastUsed -= reduction;
                                reduceCooldownDisplay(proj.userData.abilityId, reduction);
                                proj.userData.sharedHitCount.count = -999; // Prevent multiple triggers
                            }
                        }
                    }
                } else if (proj.userData.isPiercing) {
                    // Piercing arrow logic
                    const hitRadius = 0.8;
                    gameState.enemies.forEach(enemy => {
                        if (!proj.userData.hitEnemies.includes(enemy) && 
                            proj.position.distanceTo(enemy.position) < hitRadius) {
                            // Do 30 damage after first hit to incentivize lining up shots
                            const damage = proj.userData.pierceCount > 0 ? 30 : proj.userData.damage;
                            damageEnemy(enemy, damage);
                            proj.userData.hitEnemies.push(enemy);
                            proj.userData.pierceCount++;
                            effectsManager.createExplosion(enemy.position, 0x8b4513);
                            
                            // Track shared hit count for multi-projectile abilities
                            if (proj.userData.sharedHitCount) {
                                proj.userData.sharedHitCount.count++;
                                if (proj.userData.sharedHitCount.count >= proj.userData.hitThreshold && proj.userData.abilityRef) {
                                    const reduction = proj.userData.abilityRef.cooldown * proj.userData.cooldownReduction;
                                    proj.userData.abilityRef.lastUsed -= reduction;
                                    reduceCooldownDisplay(proj.userData.abilityId, reduction);
                                    proj.userData.sharedHitCount.count = -999; // Prevent multiple triggers
                                }
                            } else if (proj.userData.pierceCount >= proj.userData.hitThreshold && proj.userData.abilityRef) {
                                // Single projectile abilities
                                const reduction = proj.userData.abilityRef.cooldown * proj.userData.cooldownReduction;
                                proj.userData.abilityRef.lastUsed -= reduction;
                                reduceCooldownDisplay(proj.userData.abilityId, reduction);
                                proj.userData.hitThreshold = 999; // Prevent multiple triggers
                            }
                            
                            // Pierce arrows never stop from hitting enemies
                            // (infinite pierce)
                        }
                    });
                } else if (proj.userData.isAllyProjectile) {
                    // Ally projectile hitting enemies
                    const hitRadius = 0.8;
                    gameState.enemies.forEach(enemy => {
                        if (proj.position.distanceTo(enemy.position) < hitRadius) {
                            damageEnemy(enemy, proj.userData.damage);
                            effectsManager.createExplosion(enemy.position, 0x10b981);
                            hit = true;
                        }
                    });
                } else {
                    // Regular single-target projectile damage
                    const hitRadius = 0.8;
                    gameState.enemies.forEach(enemy => {
                        if (proj.position.distanceTo(enemy.position) < hitRadius) {
                            damageEnemy(enemy, proj.userData.damage);
                            hit = true;
                        }
                    });
                }
                
                // Remove if hit or expired
                if (hit || now - proj.userData.created > proj.userData.lifetime) {
                    scene.remove(proj);
                    gameState.projectiles.splice(i, 1);
                }
            }
        }
        
        // Update turrets
        function updateTurrets(deltaTime) {
            const now = Date.now();
            
            for (let i = gameState.turrets.length - 1; i >= 0; i--) {
                const turret = gameState.turrets[i];
                
                // Check if turret destroyed
                if (turret.userData.hp <= 0) {
                    effectsManager.createDeathExplosion(turret.position, 0xffa500);
                    scene.remove(turret);
                    gameState.turrets.splice(i, 1);
                    continue;
                }
                
                // Find nearest enemy
                let nearestEnemy = null;
                let nearestDist = Infinity;
                
                gameState.enemies.forEach(enemy => {
                    if (!isEnemyOnScreen(enemy)) return;
                    const dist = turret.position.distanceTo(enemy.position);
                    if (dist < nearestDist && dist <= turret.userData.range) {
                        nearestDist = dist;
                        nearestEnemy = enemy;
                    }
                });
                
                if (nearestEnemy) {
                    // Rotate turret to face enemy
                    const angle = Math.atan2(
                        nearestEnemy.position.x - turret.position.x,
                        nearestEnemy.position.y - turret.position.y
                    );
                    turret.rotation.z = -angle;
                    
                    // Shoot at enemy
                    if (now - turret.userData.attackCooldown > turret.userData.attackInterval) {
                        turret.userData.attackCooldown = now;
                        
                        const direction = new THREE.Vector3()
                            .subVectors(nearestEnemy.position, turret.position)
                            .normalize();
                        
                        const bullet = effectsManager.createFireball(turret.position.clone(), direction, 0.3);
                        bullet.userData = {
                            direction: direction,
                            speed: 0.3,
                            damage: turret.userData.damage,
                            created: now,
                            lifetime: 3000
                        };
                        
                        gameState.projectiles.push(bullet);
                    }
                }
            }
        }
        
        // Update minions
        function updateMinions(deltaTime) {
            const now = Date.now();
            
            for (let i = gameState.minions.length - 1; i >= 0; i--) {
                const minion = gameState.minions[i];
                
                // Check if minion expired
                if (now > minion.userData.expiresAt) {
                    effectsManager.createDeathExplosion(minion.position, minion.userData.isCube ? 0xfbbf24 : 0x9333ea);
                    scene.remove(minion);
                    gameState.minions.splice(i, 1);
                    continue;
                }

                // Ensure HP UI exists for minions (so players can see minion health)
                try {
                    if (!minion.userData.hpUI || !minion.userData.hpUI.el) {
                        createAllyHPUI(minion);
                    }
                    // Update minion HP UI immediately
                    const ui = minion.userData.hpUI;
                    if (ui && ui.el) {
                        const fg = ui.el.querySelector('.bar-fg');
                        if (fg) {
                            const hp = (minion.userData.hp != null) ? minion.userData.hp : (minion.userData.maxHp || 0);
                            const maxHp = (minion.userData.maxHp != null) ? minion.userData.maxHp : hp;
                            const ratio = maxHp > 0 ? Math.max(0, Math.min(1, hp / maxHp)) : 0;
                            fg.style.width = Math.round(ratio * 100) + '%';
                            if (ratio > 0.5) fg.style.background = 'linear-gradient(90deg,#3b82f6,#2563eb)';
                            else if (ratio > 0.25) fg.style.background = 'linear-gradient(90deg,#f59e0b,#d97706)';
                            else fg.style.background = 'linear-gradient(90deg,#ef4444,#dc2626)';
                        }
                    }
                } catch (e) {}

                // If minion HP drops to 0, don't remove â€” stun and persist as an ally-like downed unit
                if (minion.userData.hp <= 0) {
                    handleAllyDown(minion);
                    continue;
                }
                
                // Find nearest enemy
                let nearestEnemy = null;
                let nearestDist = Infinity;
                
                gameState.enemies.forEach(enemy => {
                    if (!isEnemyOnScreen(enemy)) return;
                    const dist = minion.position.distanceTo(enemy.position);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = enemy;
                    }
                });
                
                if (nearestEnemy) {
                    // Move toward enemy
                    const direction = new THREE.Vector3()
                        .subVectors(nearestEnemy.position, minion.position)
                        .normalize();
                    
                    minion.position.x += direction.x * minion.userData.speed;
                    minion.position.z += direction.z * minion.userData.speed;
                    
                    // Rotate minion
                    if (minion.userData.isCube) {
                        minion.rotation.x += 0.02;
                        minion.rotation.y += 0.02;
                    } else {
                        minion.rotation.y += 0.05;
                    }
                    
                    // Attack if close enough
                    if (nearestDist < 1.5 && now - minion.userData.attackCooldown > minion.userData.attackInterval) {
                        minion.userData.attackCooldown = now;
                        damageEnemy(nearestEnemy, minion.userData.damage);
                        effectsManager.createExplosion(nearestEnemy.position, minion.userData.isCube ? 0xfbbf24 : 0x9333ea);
                    }
                }
            }
        }
        
        // Update allies
        function updateAllies(deltaTime) {
            const now = Date.now();
            
            // Clean up expired allies and update active ones
            for (let i = gameState.allies.length - 1; i >= 0; i--) {
                const ally = gameState.allies[i];
                
                // Check if ally expired
                if (now > ally.userData.allyUntil) {
                    // Kill the ally when duration expires
                    handleAllyDown(ally);
                    continue;
                }
                
                // Find nearest enemy for ally to attack
                let nearestEnemy = null;
                let nearestDist = Infinity;
                
                gameState.enemies.forEach(enemy => {
                    if (!isEnemyOnScreen(enemy)) return;
                    const dist = ally.position.distanceTo(enemy.position);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = enemy;
                    }
                });
                
                if (nearestEnemy) {
                    // Record current target for this ally (used by CMD)
                    ally.userData.currentTarget = nearestEnemy;

                    // Move toward enemy (or keep distance if ranged)
                    const direction = new THREE.Vector3()
                        .subVectors(nearestEnemy.position, ally.position)
                        .normalize();
                    
                    const isRanged = ally.userData.isRanged;
                    const preferredRange = isRanged ? 8 : 1.5;
                    
                    if (nearestDist > preferredRange + 1) {
                        ally.position.x += direction.x * 0.04;
                        ally.position.y += direction.y * 0.04;
                    } else if (isRanged && nearestDist < preferredRange - 1) {
                        // Back away if too close for ranged
                        ally.position.x -= direction.x * 0.02;
                        ally.position.y -= direction.y * 0.02;
                    }
                    
                    // Rotate ally
                    const rotSpeed = ally.userData.rotationSpeed || 0.02;
                    ally.rotation.x += rotSpeed;
                    ally.rotation.y += rotSpeed * 1.5;
                    
                    // Attack based on type
                    if (now - ally.userData.attackCooldown > ally.userData.attackInterval) {
                        const attackRange = isRanged ? 12 : 1.5;
                        if (nearestDist < attackRange) {
                            ally.userData.attackCooldown = now;
                            // Weaken allies: lower damage outputs
                            const damage = ally.userData.isGuardian ? 18 : (isRanged ? 10 : 10);
                            
                            if (isRanged) {
                                // Shoot projectile
                                const projectile = effectsManager.createFireball(ally.position.clone(), direction, 0.3);
                                projectile.userData = {
                                    direction: direction,
                                    speed: 0.3,
                                    damage: damage,
                                    created: now,
                                    lifetime: 3000,
                                    isAllyProjectile: true
                                };
                                gameState.projectiles.push(projectile);
                            } else {
                                // Melee attack
                                damageEnemy(nearestEnemy, damage);
                                effectsManager.createExplosion(nearestEnemy.position, 0x3b82f6);
                            }
                        }
                    }
                }
                else {
                    ally.userData.currentTarget = null;
                }
            }
        }

        // Player melee for Miner passive and drill buff
        function updatePlayerMelee(deltaTime) {
            if (!selectedClass || selectedClass.name !== 'Miner') return;
            const now = Date.now();
            if (!player.userData) player.userData = {};
            const meleeInterval = player.userData.meleeInterval || 700;
            const baseDamage = player.userData.meleeDamage || 20;
            const drillActive = player.userData.drillUntil && now < player.userData.drillUntil;
            const damage = drillActive ? Math.max(baseDamage * 4, 80) : baseDamage;

            if (now - (player.userData.meleeCooldown || 0) < meleeInterval) return;

            // Find nearest enemy within melee range
            let nearest = null;
            let nd = Infinity;
            gameState.enemies.forEach(enemy => {
                const d = player.position.distanceTo(enemy.position);
                if (d < 1.6 && d < nd) {
                    nd = d; nearest = enemy;
                }
            });

            if (nearest) {
                player.userData.meleeCooldown = now;
                // Hit effect
                effectsManager.createDamageNumber(nearest.position, damage);
                console.log(`Player melee hit enemy id=${nearest.id} dmg=${damage}`);
                damageEnemy(nearest, damage);
                // small shove
                const knock = new THREE.Vector3().subVectors(nearest.position, player.position).normalize().multiplyScalar(0.6);
                nearest.position.add(knock);
                screenShake(0.15, 80);
            }
        }
        
        // Update enemies
        function updateEnemies(deltaTime) {
            const now = Date.now();
            
            // Clear any stale claimedBy references on player (if the claiming enemy no longer exists)
            try {
                if (gameState.player && gameState.player.userData && gameState.player.userData.claimedBy) {
                    const claimerId = gameState.player.userData.claimedBy;
                    const exists = gameState.enemies.some(e => e.id === claimerId);
                    if (!exists) {
                        gameState.player.userData.claimedBy = null;
                        gameState.player.userData.claimedAt = null;
                    } else {
                        // Also clear overly long or distant claims to prevent a single distant enemy
                        try {
                            const claimer = gameState.enemies.find(e => e.id === claimerId);
                            const maxClaimDistance = Math.max(window.innerWidth, window.innerHeight) / 8; // heuristic
                            const claimAge = gameState.player.userData.claimedAt ? (Date.now() - gameState.player.userData.claimedAt) : Infinity;
                            if (!claimer || (claimer && gameState.player.position.distanceTo(claimer.position) > maxClaimDistance) || claimAge > 7000) {
                                gameState.player.userData.claimedBy = null;
                                gameState.player.userData.claimedAt = null;
                            }
                        } catch (e) {}
                    }
                }
            } catch (e) {}
            // Also clear stale claims on allies, minions, and turrets
            try {
                const maxClaimDistance = Math.max(window.innerWidth, window.innerHeight) / 8;
                if (gameState.allies) gameState.allies.forEach(a => {
                    if (a.userData && a.userData.claimedBy) {
                        const claimer = gameState.enemies.find(e => e.id === a.userData.claimedBy);
                        const claimAge = a.userData.claimedAt ? (Date.now() - a.userData.claimedAt) : Infinity;
                        if (!claimer || (claimer && a.position.distanceTo(claimer.position) > maxClaimDistance) || claimAge > 7000) {
                            a.userData.claimedBy = null; a.userData.claimedAt = null;
                        }
                    }
                });
                if (gameState.minions) gameState.minions.forEach(m => {
                    if (m.userData && m.userData.claimedBy) {
                        const claimer = gameState.enemies.find(e => e.id === m.userData.claimedBy);
                        const claimAge = m.userData.claimedAt ? (Date.now() - m.userData.claimedAt) : Infinity;
                        if (!claimer || (claimer && m.position.distanceTo(claimer.position) > maxClaimDistance) || claimAge > 7000) {
                            m.userData.claimedBy = null; m.userData.claimedAt = null;
                        }
                    }
                });
                if (gameState.turrets) gameState.turrets.forEach(t => {
                    if (t.userData && t.userData.claimedBy) {
                        const claimer = gameState.enemies.find(e => e.id === t.userData.claimedBy);
                        const claimAge = t.userData.claimedAt ? (Date.now() - t.userData.claimedAt) : Infinity;
                        if (!claimer || (claimer && t.position.distanceTo(claimer.position) > maxClaimDistance) || claimAge > 7000) {
                            t.userData.claimedBy = null; t.userData.claimedAt = null;
                        }
                    }
                });
            } catch (e) {}

            gameState.enemies.forEach(enemy => {
                // Process burn damage over time
                if (enemy.userData.burning) {
                    if (now > enemy.userData.burnEnd) {
                        enemy.userData.burning = false;
                    } else {
                        // Apply burn damage every second
                        if (now - enemy.userData.lastBurnTick >= 1000) {
                            enemy.userData.lastBurnTick = now;
                            damageEnemy(enemy, enemy.userData.burnDamage);
                            effectsManager.createDamageNumber(enemy.position, enemy.userData.burnDamage);
                        }
                        
                        // Visual burn effect
                        if (Math.random() < 0.1) {
                            const originalColor = enemy.userData.type === 'ranged' ? 0xa855f7 : 
                                                   enemy.userData.type === 'tank' ? 0xef4444 : 0x4ade80;
                            enemy.material.color.setHex(0xff6600);
                            setTimeout(() => {
                                if (enemy.material) {
                                    enemy.material.color.setHex(originalColor);
                                }
                            }, 100);
                        }
                    }
                }
                
                // Check if this enemy is frozen by an ability. If frozen, we'll skip movement
                // but still allow attack logic to run so melee enemies can hit if in range.
                let isFrozen = false;
                if (enemy.userData && enemy.userData.frozenUntil && now < enemy.userData.frozenUntil) {
                    isFrozen = true;
                    if (gameState.debugAI) console.log(`updateEnemies: enemy id=${enemy.id} frozen until ${enemy.userData.frozenUntil} (now ${now})`);
                }
                
                // Enemies should always know where the player is (player is always a valid target).
                // We do not use `claimedBy` for the player so many enemies can target the player simultaneously.
                const canSeePlayer = !!gameState.player;
                let canSeeAlly = false;
                let closestVisibleAlly = null;
                let closestAllyDist = Infinity;

                // Consider both persistent allies and temporary minions as valid ally targets
                const allyCandidates = [];
                if (gameState.allies && gameState.allies.length > 0) allyCandidates.push(...gameState.allies);
                if (gameState.minions && gameState.minions.length > 0) allyCandidates.push(...gameState.minions);

                allyCandidates.forEach(ally => {
                    if (!isEnemyOnScreen(ally)) return;
                    // Skip allies already claimed by another enemy
                    if (ally.userData && ally.userData.claimedBy && ally.userData.claimedBy !== enemy.id) return;
                    canSeeAlly = true;
                    const allyDist = enemy.position.distanceTo(ally.position);
                    if (allyDist < closestAllyDist) {
                        closestVisibleAlly = ally;
                        closestAllyDist = allyDist;
                    }
                });
                
                // Check for turrets
                let canSeeTurret = false;
                let closestVisibleTurret = null;
                let closestTurretDist = Infinity;
                
                if (gameState.turrets && gameState.turrets.length > 0) {
                    gameState.turrets.forEach(turret => {
                        // Skip turrets claimed by others
                        if (turret.userData && turret.userData.claimedBy && turret.userData.claimedBy !== enemy.id) return;
                        const turretDist = enemy.position.distanceTo(turret.position);
                        if (turretDist < closestTurretDist) {
                            closestVisibleTurret = turret;
                            closestTurretDist = turretDist;
                            canSeeTurret = true;
                        }
                    });
                }
                
                // Choose target: nearest turret, ally, or player
                let target = gameState.player;
                let targetIsAlly = false;
                let targetIsTurret = false;
                let hasTarget = canSeePlayer;
                
                if (canSeeAlly) {
                    const playerDist = enemy.position.distanceTo(gameState.player.position);
                    if (closestVisibleAlly && closestAllyDist < playerDist) {
                        target = closestVisibleAlly;
                        targetIsAlly = true;
                        hasTarget = true;
                    }
                }
                
                // Prioritize turrets if they're closest
                if (canSeeTurret && closestTurretDist < 15) {
                    const currentTargetDist = enemy.position.distanceTo(target.position);
                    if (closestTurretDist < currentTargetDist) {
                        target = closestVisibleTurret;
                        targetIsTurret = true;
                        targetIsAlly = false;
                        hasTarget = true;
                    }
                }
                
                let direction;

                if (hasTarget) {
                    // Move toward visible target
                    direction = new THREE.Vector3()
                        .subVectors(target.position, enemy.position)
                        .normalize();

                    // Release previous claim if switching targets (don't clear player's claimed state because player isn't claimed)
                    const prevTarget = enemy.userData && enemy.userData.currentTarget ? enemy.userData.currentTarget : null;
                    if (prevTarget && prevTarget !== gameState.player && prevTarget.userData && prevTarget.userData.claimedBy === enemy.id && prevTarget !== target) {
                        prevTarget.userData.claimedBy = null;
                        prevTarget.userData.claimedAt = null;
                    }

                    // Claim this target for this enemy if possible (don't claim the player)
                    if (target && target.userData && target !== gameState.player) {
                        if (!target.userData.claimedBy || target.userData.claimedBy === enemy.id) {
                            target.userData.claimedBy = enemy.id;
                            target.userData.claimedAt = Date.now();
                        }
                    }

                    // Record current target on enemy
                    if (!enemy.userData) enemy.userData = {};
                    enemy.userData.currentTarget = target;
                } else {
                    // Release any previous target claim when losing sight (don't modify player)
                    const prevTarget = enemy.userData && enemy.userData.currentTarget ? enemy.userData.currentTarget : null;
                    if (prevTarget && prevTarget !== gameState.player && prevTarget.userData && prevTarget.userData.claimedBy === enemy.id) {
                        prevTarget.userData.claimedBy = null;
                        prevTarget.userData.claimedAt = null;
                    }
                    if (enemy.userData) enemy.userData.currentTarget = null;

                    // No wandering: move toward arena center so enemies enter the play area predictably
                    const center = new THREE.Vector3(0, 0, 0);
                    direction = new THREE.Vector3().subVectors(center, enemy.position).normalize();
                    if (gameState.debugAI) console.log(`updateEnemies: enemy id=${enemy.id} no-target -> moving to center from (${enemy.position.x.toFixed(1)},${enemy.position.y.toFixed(1)}) claimedBy=${enemy.userData && enemy.userData.claimedBy}`);
                }
                
                // Check for barrier collisions before moving
                const newX = enemy.position.x + direction.x * enemy.userData.speed;
                const newY = enemy.position.y + direction.y * enemy.userData.speed;
                const newPos = new THREE.Vector3(newX, newY, 0);
                
                let blockedByBarrier = false;
                let closestBarrier = null;
                let closestBarrierDist = Infinity;
                
                if (abilities.e && abilities.e.barriers) {
                    abilities.e.barriers.forEach(barrier => {
                        if (barrier.userData.active) {
                            const dist = barrier.position.distanceTo(newPos);
                            if (dist <= 2.5) {
                                blockedByBarrier = true;
                                if (dist < closestBarrierDist) {
                                    closestBarrier = barrier;
                                    closestBarrierDist = dist;
                                }
                            }
                        }
                    });
                }
                
                if (!isFrozen) {
                    if (blockedByBarrier && closestBarrier) {
                    // Move perpendicular to barrier to navigate around it
                    const toBarrier = new THREE.Vector3()
                        .subVectors(closestBarrier.position, enemy.position)
                        .normalize();
                    
                    // Try moving perpendicular (90 degrees)
                    const perp1 = new THREE.Vector3(-toBarrier.y, toBarrier.x, 0);
                    const perp2 = new THREE.Vector3(toBarrier.y, -toBarrier.x, 0);
                    
                    // Choose perpendicular direction that's closer to target
                    let perpDirection;
                    if (hasTarget) {
                        const toTarget = new THREE.Vector3()
                            .subVectors(target.position, enemy.position)
                            .normalize();
                        const dot1 = perp1.dot(toTarget);
                        const dot2 = perp2.dot(toTarget);
                        perpDirection = dot1 > dot2 ? perp1 : perp2;
                    } else {
                        perpDirection = Math.random() > 0.5 ? perp1 : perp2;
                    }
                    
                        enemy.position.x += perpDirection.x * enemy.userData.speed;
                        enemy.position.y += perpDirection.y * enemy.userData.speed;
                    } else if (!blockedByBarrier) {
                        enemy.position.x = newX;
                        enemy.position.y = newY;
                    }
                } else {
                    // Enemy is frozen: skip movement but keep position for attack checks
                    if (gameState.debugAI) {
                        // Log occasionally to avoid spamming
                        if (now % 1000 < 50) console.log(`updateEnemies: skipping movement for frozen enemy id=${enemy.id}`);
                    }
                }
                
                // Rotate enemy
                if (!enemy.userData.dying) {
                    enemy.rotation.x += enemy.userData.rotationSpeed;
                    enemy.rotation.y += enemy.userData.rotationSpeed * 1.5;
                }
                
                // Flash invisible enemies between 0% and 50% opacity
                if (enemy.userData.type === 'invisible' && !enemy.userData.dying) {
                    enemy.userData.invisFlashTimer += deltaTime;
                    // Flash every 800ms
                    const flashCycle = enemy.userData.invisFlashTimer % 800;
                    if (flashCycle < 400) {
                        // Fade from 0 to 0.5
                        enemy.material.opacity = (flashCycle / 400) * 0.5;
                    } else {
                        // Fade from 0.5 to 0
                        enemy.material.opacity = ((800 - flashCycle) / 400) * 0.5;
                    }
                }
                
                // Attack based on type and range
                const dist = enemy.position.distanceTo(target.position);
                const attackRange = enemy.userData.attackRange || 1.5;

                // Throttled debug for melee/tank types to trace why attacks may not fire
                try {
                    if (enemy.userData && (enemy.userData.type === 'melee' || enemy.userData.type === 'tank')) {
                        const last = enemy.userData._lastDbg || 0;
                        if (now - last > 1000) {
                            enemy.userData._lastDbg = now;
                            const dbg = `ENEMYDBG id=${enemy.id} type=${enemy.userData.type} pos=(${enemy.position.x.toFixed(2)},${enemy.position.y.toFixed(2)}) distToPlayer=${dist.toFixed(2)} attackCooldown=${enemy.userData.attackCooldown} attackInterval=${enemy.userData.attackInterval}`;
                        }
                    }
                } catch (e) {}

                // Special behaviors for new enemy types
                try {
                    // Suicide enemies explode on contact
                    if (enemy.userData.type === 'suicide' && !enemy.userData.exploded && dist <= 1.2) {
                        enemy.userData.exploded = true;
                        const pos = enemy.position.clone();
                        effectsManager.createExplosion(pos, 0xff0000);
                        const range = enemy.userData.explodeRange || 3.5;
                        const dmg = enemy.userData.explodeDamage || 50;
                        // Damage player if in range
                        if (gameState.player && pos.distanceTo(gameState.player.position) <= range && !gameState.isInvulnerable) {
                            hpManager.damage(dmg);
                            gameState.lastDamageTime = Date.now();
                            if (hpManager.isDead()) gameOver();
                        }
                        // Kill self
                        damageEnemy(enemy, enemy.userData.hp);
                        return;
                    }

                    // Healer: periodic heal nearby enemies
                    if (enemy.userData.type === 'healer') {
                        const last = enemy.userData.lastHeal || 0;
                        if (Date.now() - last >= (enemy.userData.healInterval || 3000)) {
                            enemy.userData.lastHeal = Date.now();
                            const healRange = 4;
                            gameState.enemies.forEach(other => {
                                if (other && other.userData && other.userData.hp > 0) {
                                    const d = other.position.distanceTo(enemy.position);
                                    if (d <= healRange && other.userData.hp < other.userData.maxHp) {
                                        other.userData.hp = Math.min(other.userData.maxHp, other.userData.hp + (enemy.userData.healAmount || 8));
                                        effectsManager.createDamageNumber(other.position, -(enemy.userData.healAmount || 8));
                                    }
                                }
                            });
                        }
                    }

                    // Phaser: teleport toward player occasionally
                    if (enemy.userData.type === 'phaser' && gameState.player) {
                        const nowTime = Date.now();
                        if (!enemy.userData.lastTeleport) enemy.userData.lastTeleport = 0;
                        if (nowTime - enemy.userData.lastTeleport >= (enemy.userData.teleportCooldown || 4000) && dist > 5) {
                            enemy.userData.lastTeleport = nowTime;
                            // Teleport near player with small offset
                            const angle = Math.random() * Math.PI * 2;
                            const offset = 2 + Math.random() * 1.5;
                            const nx = gameState.player.position.x + Math.cos(angle) * offset;
                            const ny = gameState.player.position.y + Math.sin(angle) * offset;
                            enemy.position.x = Math.max(-window.innerWidth/40+1, Math.min(window.innerWidth/40-1, nx));
                            enemy.position.y = Math.max(-window.innerHeight/40+1, Math.min(window.innerHeight/40-1, ny));
                            if (gameState.debugAI) console.log(`phaser: teleported enemy id=${enemy.id} near player to (${enemy.position.x.toFixed(1)},${enemy.position.y.toFixed(1)})`);
                        }
                    }
                } catch (e) {}
                
                if (enemy.userData.type === 'ranged' || enemy.userData.type === 'sniper') {
                    // Ranged enemies stop at range and shoot
                    if (dist <= attackRange && dist > 3 && now - enemy.userData.attackCooldown > enemy.userData.attackInterval) {
                        enemy.userData.attackCooldown = now;
                        
                        // Create projectile
                        const projGeometry = new THREE.SphereGeometry(0.2, 8, 8);
                        const projMaterial = new THREE.MeshBasicMaterial({ color: 0xa855f7 });
                        const projectile = new THREE.Mesh(projGeometry, projMaterial);
                        projectile.position.copy(enemy.position);
                        
                        const direction = new THREE.Vector3()
                            .subVectors(target.position, enemy.position)
                            .normalize();
                        
                        projectile.userData = {
                            direction: direction,
                            speed: 0.15,
                            damage: enemy.userData.damage,
                            created: now,
                            lifetime: 5000,
                            isEnemyProjectile: true,
                            targetIsAlly: targetIsAlly,
                            target: target
                        };
                        
                        scene.add(projectile);
                        gameState.projectiles.push(projectile);
                    }
                } else if (now - (enemy.userData.attackCooldown || 0) > (enemy.userData.attackInterval || 800)) {
                    // Determine an effective melee hit range that accounts for player collision radius
                    const playerRadius = (gameState.player && gameState.player.userData && gameState.player.userData.collisionRadius) ? gameState.player.userData.collisionRadius : 0.9;
                    const effectiveMeleeRange = attackRange + playerRadius;
                    if (dist <= effectiveMeleeRange) {
                        // Perform attack and set cooldown
                        enemy.userData.attackCooldown = now;

                        if (targetIsTurret) {
                            target.userData.hp -= enemy.userData.damage;
                            effectsManager.createDamageNumber(target.position, enemy.userData.damage);
                            if (target.userData.hp <= 0) {
                                scene.remove(target);
                                const turretIndex = gameState.turrets.indexOf(target);
                                if (turretIndex > -1) gameState.turrets.splice(turretIndex, 1);
                                effectsManager.createExplosion(target.position, 0xffa500);
                            }
                        } else if (targetIsAlly) {
                            target.userData.hp -= enemy.userData.damage;
                            effectsManager.createDamageNumber(target.position, enemy.userData.damage);
                            if (target.userData.hp <= 0) handleAllyDown(target);
                        } else {
                            // Damage player (respect invulnerability)
                            if (!gameState.isInvulnerable) {
                                // Show damage number at player
                                try { effectsManager.createDamageNumber(gameState.player.position, enemy.userData.damage); } catch (e) {}
                                hpManager.damage(enemy.userData.damage);
                                gameState.lastDamageTime = Date.now();
                                if (hpManager.isDead()) gameOver();
                                if (gameState.debugAI) console.log(`updateEnemies: enemy id=${enemy.id} hit player dmg=${enemy.userData.damage} playerHp=${hpManager.currentHp}`);
                            } else {
                                if (gameState.debugAI) console.log(`updateEnemies: enemy id=${enemy.id} tried to damage player (${enemy.userData.damage}) but invulnerable`);
                            }
                        }
                    }
                }
            });
        }
        
        // Game over
        function gameOver() {
            gameState.isGameOver = true;
            gameState.highestWaveReached = Math.max(gameState.highestWaveReached, gameState.currentWave);
            
            // Award EXP based on progression (wave reached + kills)
            if (selectedClass) {
                const className = Object.keys(classes).find(key => classes[key] === selectedClass);
                if (className && classExp[className]) {
                    const expGained = (gameState.currentWave - 1) * 20 + gameState.killCount * 2;
                    classExp[className].exp += expGained;
                    
                    // Level up if needed
                    while (classExp[className].exp >= classExp[className].maxExp && classExp[className].level < 15) {
                        classExp[className].exp -= classExp[className].maxExp;
                            classExp[className].level++;
                        
                        // Evolution at level 15 - max out at 15 and increase evolution tier
                        if (classExp[className].level === 15) {
                            classExp[className].evolution++;
                            classExp[className].exp = 0; // Clear excess exp
                        } else {
                            classExp[className].maxExp = Math.floor(classExp[className].maxExp * 1.5);
                        }
                            // Apply bonuses for this level change
                            applyClassLevelBonuses(className);
                    }
                    
                    updateExpDisplays();
                    // If at max level (15), convert any leftover EXP into coins at 1:2 rate
                    if (classExp[className].level >= 15 && classExp[className].exp > 0) {
                        const overflow = classExp[className].exp;
                        const coinsFromExp = Math.floor(overflow * 2);
                        gameState.coins = (gameState.coins || 0) + coinsFromExp;
                        classExp[className].exp = 0;
                        if (typeof updateCoinDisplay === 'function') updateCoinDisplay();
                        if (typeof showToast === 'function') showToast(`Converted ${overflow} EXP to ${coinsFromExp} coins`);
                    }
                }
            }
            
            document.getElementById('finalScore').textContent = `Wave: ${gameState.currentWave}`;
            // Show EXP and coin gains summary
            try {
                const className = selectedClass ? Object.keys(classes).find(key => classes[key] === selectedClass) : null;
                let expGained = 0;
                let coinsGained = 0;
                if (className && classExp[className]) {
                    expGained = (gameState.currentWave - 1) * 20 + gameState.killCount * 2;
                    if (classExp[className].level >= 15) {
                        coinsGained = Math.floor((expGained) * 2);
                        // note: conversion already applied in leveling code above if needed
                    }
                }
                const gainsEl = document.getElementById('gameOverGains');
                if (gainsEl) {
                    let txt = '';
                    if (expGained) txt += `EXP Gained: ${expGained}`;
                    if (coinsGained) txt += (txt ? ' â€” ' : '') + `Coins: ${coinsGained}`;
                    gainsEl.textContent = txt;
                }
            } catch (e) {}
            document.getElementById('gameOver').style.display = 'block';
            triggerImmediateSave(); // Save progress after game over
        }
        
        // Restart game
        function restartGame() {
            // If player hits Home during an active run, award EXP as if the run ended
            if (!gameState.isGameOver && selectedClass) {
                try {
                    const className = Object.keys(classes).find(key => classes[key] === selectedClass);
                    if (className && classExp[className]) {
                        const expGained = (gameState.currentWave - 1) * 20 + (gameState.killCount || 0) * 2;
                        classExp[className].exp += expGained;

                        // Level up if needed
                        while (classExp[className].exp >= classExp[className].maxExp && classExp[className].level < 15) {
                            classExp[className].exp -= classExp[className].maxExp;
                            classExp[className].level++;
                            if (classExp[className].level === 15) {
                                classExp[className].evolution++;
                                classExp[className].exp = 0;
                            } else {
                                classExp[className].maxExp = Math.floor(classExp[className].maxExp * 1.5);
                            }
                            applyClassLevelBonuses(className);
                        }

                        updateExpDisplays();
                        // If at max level (15), convert any leftover EXP into coins at 1:2 rate
                        if (classExp[className].level >= 15 && classExp[className].exp > 0) {
                            const overflow = classExp[className].exp;
                            const coinsFromExp = Math.floor(overflow * 2);
                            gameState.coins = (gameState.coins || 0) + coinsFromExp;
                            classExp[className].exp = 0;
                            if (typeof updateCoinDisplay === 'function') updateCoinDisplay();
                            if (typeof showToast === 'function') showToast(`Converted ${overflow} EXP to ${coinsFromExp} coins`);
                        }
                        updateBuyButtons();
                    }
                } catch (e) { console.warn('Error awarding EXP on Home', e); }
            }
            // Clear all entities
            gameState.enemies.forEach(enemy => scene.remove(enemy));
            gameState.projectiles.forEach(proj => scene.remove(proj));
            gameState.allies.forEach(ally => scene.remove(ally));
            gameState.turrets.forEach(turret => scene.remove(turret));
            gameState.minions.forEach(minion => scene.remove(minion));
            
            // Reset game state
            gameState.enemies = [];
            gameState.projectiles = [];
            gameState.allies = [];
            gameState.turrets = [];
            gameState.minions = [];
            gameState.killCount = 0;
            gameState.isGameOver = false;
            gameState.spawnTimer = 0;
            gameState.isInvulnerable = false;
            gameState.isInvisible = false;
            gameState.machineGunAmmo = 0;
            gameState.machineGunLastFired = 0;
            gameState.currentWave = 1;
            gameState.enemiesThisWave = 0;
            gameState.enemiesPerWave = 10;
            gameState.waveInProgress = false;
            gameState.classSelected = false;
            gameState.enemiesKilledThisWave = 0;
            
            // Reset player
            hpManager.currentHp = hpManager.maxHp;
            hpManager.updateUI();
            player.position.set(0, 0, 0);
            try {
                // Restore the gradient texture map on restart instead of forcing a flat color
                const defaultMap = createGradientTexture(baseColor, accentColor, true, 256);
                if (defaultMap) defaultMap.encoding = THREE.sRGBEncoding;
                player.material.map = defaultMap;
                player.material.color.setHex(0xffffff);
                player.material.emissive.setHex(baseColor);
                player.material.emissiveIntensity = 0.08;
                player.material.needsUpdate = true;
            } catch (e) { console.warn('Failed to restore player gradient on restart', e); }
            
            // Reset UI
            document.getElementById('waveCount').textContent = '1';
            document.getElementById('waveProgress').style.width = '0%';
            document.getElementById('waveProgressText').textContent = '0 / 10';
            document.getElementById('gameOver').style.display = 'none';
            
            // Clear ability cooldowns
            ['ability1', 'ability2', 'ability3'].forEach(id => {
                const abilityEl = document.getElementById(id);
                abilityEl.classList.remove('disabled');
                abilityEl.querySelector('.cooldown-overlay').style.height = '0%';
                abilityEl.querySelector('.cooldown-text').textContent = '';
            });
            // Also clear mobile ability overlays if present
            try {
                ['mAbility1','mAbility2','mAbility3'].forEach(mid => {
                    const mb = document.getElementById(mid);
                    if (!mb) return;
                    const mo = mb.querySelector('.mobile-cooldown-overlay');
                    const mt = mb.querySelector('.mobile-cooldown-text');
                    if (mo) mo.style.height = '0%';
                    if (mt) mt.textContent = '';
                });
            } catch (e) {}
            
            // Clear cooldown intervals
            Object.keys(cooldownIntervals).forEach(key => {
                clearInterval(cooldownIntervals[key].interval);
                delete cooldownIntervals[key];
            });
            
            // Reset selected class
            selectedClass = null;
            abilities = {};

            // Show home screen instead of class selection
            document.getElementById('classSelection').style.display = 'none';
            document.getElementById('homeScreen').style.display = 'flex';

            // Hide HUD when returning to home
            try { const hudEl = document.getElementById('hud'); if (hudEl) hudEl.style.display = 'none'; } catch (e) {}

            // Hide HUD Home button while on the home screen
            const hb = document.getElementById('homeButton');
            if (hb) hb.style.display = 'none';
            // Hide ability UI and mobile controls when returning to home
            try { const ab = document.getElementById('abilities'); if (ab) ab.style.display = 'none'; } catch (e) {}
            try { const mc = document.getElementById('mobileControls'); if (mc) mc.style.display = 'none'; } catch (e) {}
            // Remove any remaining enemy HP UI elements immediately
            try {
                const layer = document.getElementById('enemyHpLayer');
                if (layer) {
                    layer.remove();
                }
            } catch (e) {}
            // Remove any remaining ally HP UI elements
            try {
                const allyLayer = document.getElementById('allyHpLayer');
                if (allyLayer) {
                    allyLayer.remove();
                }
            } catch (e) {}
            // Remove any barriers created by abilities
            try {
                if (gameState.barriers && gameState.barriers.length) {
                    gameState.barriers.forEach(b => { try { scene.remove(b); } catch (e) {} });
                    gameState.barriers = [];
                }
            } catch (e) {}
            triggerImmediateSave(); // Save progress when returning home
        }

            // Download offline version of the game
            function downloadOfflineVersion() {
                const htmlContent = document.documentElement.outerHTML;
                const blob = new Blob(['<!DOCTYPE html>\n' + htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'TBD_Offline.html';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            function showClassSelection() {
                document.getElementById('homeScreen').style.display = 'none';
                document.getElementById('classSelection').style.display = 'flex';

                // Hide HUD Home button while showing class selection
                const hb = document.getElementById('homeButton');
                if (hb) hb.style.display = 'none';
                // Hide HUD while browsing classes
                try { const hudEl = document.getElementById('hud'); if (hudEl) hudEl.style.display = 'none'; } catch (e) {}
                // Hide ability UI and mobile controls while in menus to avoid layout/stacking issues
                try { const ab = document.getElementById('abilities'); if (ab) ab.style.display = 'none'; } catch (e) {}
                try { const mc = document.getElementById('mobileControls'); if (mc) mc.style.display = 'none'; } catch (e) {}
                    // Clear any lingering invisibility/claims while in menus (only if gameState exists)
                    if (typeof gameState !== 'undefined') {
                        try {
                            gameState.isInvisible = false;
                            if (gameState.player && gameState.player.userData) gameState.player.userData.claimedBy = null;
                            if (gameState.allies) gameState.allies.forEach(a => { if (a.userData) a.userData.claimedBy = null; });
                            if (gameState.turrets) gameState.turrets.forEach(t => { if (t.userData) t.userData.claimedBy = null; });
                        } catch (e) {}
                    }
            }

                // Play again (restart run immediately, keep selected class)
                function playAgain() {
                    try {
                        // Remove entities
                        gameState.enemies.forEach(e => scene.remove(e));
                        gameState.projectiles.forEach(p => scene.remove(p));
                        gameState.allies.forEach(a => scene.remove(a));
                        gameState.turrets.forEach(t => scene.remove(t));
                        gameState.minions.forEach(m => scene.remove(m));
                        // Clear barriers
                        try { if (gameState.barriers) { gameState.barriers.forEach(b=>scene.remove(b)); gameState.barriers = []; } } catch(e){}

                        // Reset arrays and counters but keep selectedClass and abilities intact
                        gameState.enemies = [];
                        gameState.projectiles = [];
                        gameState.allies = [];
                        gameState.turrets = [];
                        gameState.minions = [];
                        gameState.killCount = 0;
                        gameState.isGameOver = false;
                        gameState.spawnTimer = 0;
                        gameState.isInvulnerable = false;
                        gameState.isInvisible = false;
                        gameState.machineGunAmmo = 0;
                        gameState.machineGunLastFired = 0;
                        gameState.currentWave = 1;
                        gameState.enemiesThisWave = 0;
                        gameState.enemiesPerWave = 10;
                        gameState.waveInProgress = false;
                        gameState.enemiesKilledThisWave = 0;

                        // Reset player HP and UI
                        try { hpManager.currentHp = hpManager.maxHp; hpManager.updateUI(); } catch(e){}
                        try { player.position.set(0,0,0); } catch(e){}

                        // Reset UI
                        try { document.getElementById('waveCount').textContent = '1'; } catch(e){}
                        try { document.getElementById('waveProgress').style.width = '0%'; document.getElementById('waveProgressText').textContent = '0 / 10'; } catch(e){}
                        try { document.getElementById('gameOver').style.display = 'none'; } catch(e){}

                        // Clear cooldown overlays
                        ['ability1','ability2','ability3'].forEach(id => {
                            try {
                                const abilityEl = document.getElementById(id);
                                if (abilityEl) { abilityEl.classList.remove('disabled'); abilityEl.querySelector('.cooldown-overlay').style.height = '0%'; abilityEl.querySelector('.cooldown-text').textContent = ''; }
                            } catch(e){}
                        });

                        // Clear mobile cooldown overlays
                        try {
                            ['mAbility1','mAbility2','mAbility3'].forEach(mid => {
                                const mb = document.getElementById(mid);
                                if (!mb) return;
                                const mo = mb.querySelector('.mobile-cooldown-overlay');
                                const mt = mb.querySelector('.mobile-cooldown-text');
                                if (mo) mo.style.height = '0%';
                                if (mt) mt.textContent = '';
                            });
                        } catch(e){}

                        // Clear cooldown intervals
                        try { Object.keys(cooldownIntervals).forEach(key => { clearInterval(cooldownIntervals[key].interval); delete cooldownIntervals[key]; }); } catch(e){}

                        // Start a fresh run (will select class if needed)
                        try { startGame(); } catch(e){}
                    } catch (e) { console.warn('playAgain error', e); }
                }

            function startGame() {
                // If a run is already active, just hide UI. Otherwise start a run.
                if (gameState.classSelected) {
                    document.getElementById('homeScreen').style.display = 'none';
                    document.getElementById('classSelection').style.display = 'none';
                    const hb = document.getElementById('homeButton');
                    if (hb) hb.style.display = 'inline-block';
                    return;
                }

                // If no class has been chosen in this session, try to restore last selection,
                // otherwise default to Electric and select it.
                if (!selectedClass) {
                    let restored = null;
                    try { restored = localStorage.getItem('lastSelectedClass'); } catch (e) { restored = null; }
                    if (restored && typeof classes !== 'undefined' && classes[restored] && isClassUnlocked(restored)) {
                        selectClass(restored);
                    } else {
                        selectClass('electric');
                    }
                }

                // Clear invisibility and any lingering claims so enemies can detect targets immediately
                gameState.isInvisible = false;
                try {
                    if (gameState.player && gameState.player.userData) gameState.player.userData.claimedBy = null;
                    if (gameState.allies) gameState.allies.forEach(a => { if (a.userData) a.userData.claimedBy = null; });
                    if (gameState.turrets) gameState.turrets.forEach(t => { if (t.userData) t.userData.claimedBy = null; });
                } catch (e) {}

                // At this point a class is chosen (either previously or just defaulted).
                // Hide menus and actually enable the wave system to begin the run.
                document.getElementById('homeScreen').style.display = 'none';
                document.getElementById('classSelection').style.display = 'none';
                gameState.classSelected = true;

                // Track a played game for miner quest
                try { trackQuestProgress('gamesPlayed', 1); } catch (e) {}

                // Show HUD when the game actually starts
                const hudEl = document.getElementById('hud');
                if (hudEl) hudEl.style.display = 'block';
                // Show abilities and mobile controls for gameplay
                // Keep the legacy bottom-center ability bar hidden; mobile buttons are the visible indicators
                try { const ab = document.getElementById('abilities'); if (ab) ab.style.display = 'none'; } catch (e) {}
                try { const mc = document.getElementById('mobileControls'); if (mc) mc.style.display = 'flex'; } catch (e) {}

                // Show HUD Home button when in-game
                const hb2 = document.getElementById('homeButton');
                if (hb2) hb2.style.display = 'inline-block';
            }
        
        // Animation loop
        function animate() {
            const now = Date.now();
            // Miner passive: throw shovels or shoot drill
            if (selectedClass && selectedClass.name === 'Miner' && !gameState.isGameOver) {
                if (!player.userData.lastMinerPassive) player.userData.lastMinerPassive = 0;
                const minerLevel = (classExp.miner && classExp.miner.level) ? classExp.miner.level : 1;
                // Fire rate: faster with level (base 1800ms, min 600ms)
                const passiveInterval = Math.max(600, 1800 - (minerLevel - 1) * 80);
                if (now - player.userData.lastMinerPassive > passiveInterval) {
                    player.userData.lastMinerPassive = now;
                    // Alternate: every 4th shot is a drill, others are shovels
                    if (!player.userData.minerPassiveCount) player.userData.minerPassiveCount = 0;
                    player.userData.minerPassiveCount++;
                    // Find nearest enemy for auto-aim
                    let target = null;
                    let minDist = Infinity;
                    for (const enemy of gameState.enemies) {
                        if (!isEnemyOnScreen(enemy)) continue;
                        const dist = player.position.distanceTo(enemy.position);
                        if (dist < minDist) {
                            minDist = dist;
                            target = enemy;
                        }
                    }
                    // If no enemies, fire forward
                    let aimDir;
                    if (target) {
                        aimDir = target.position.clone().sub(player.position).setZ(0).normalize();
                    } else {
                        aimDir = new THREE.Vector3(0, 1, 0).applyQuaternion(player.quaternion);
                    }
                    if (player.userData.minerPassiveCount % 4 === 0) {
                        // Shoot drill: fast, piercing, high damage
                        const drillGeom = new THREE.CylinderGeometry(0.13, 0.13, 1.2, 8);
                        const drillMat = new THREE.MeshStandardMaterial({ color: 0xd1b000, metalness: 0.6, roughness: 0.3 });
                        const drill = new THREE.Mesh(drillGeom, drillMat);
                        drill.position.copy(player.position);
                        drill.position.z += 0.2;
                        drill.rotation.x = Math.PI / 2;
                        drill.userData = {
                            velocity: aimDir.clone().multiplyScalar(0.55 + 0.02 * minerLevel),
                            damage: 32 + 4 * minerLevel,
                            pierce: 2 + Math.floor(minerLevel / 5),
                            owner: 'player',
                            isDrill: true,
                            createdAt: now
                        };
                        scene.add(drill);
                        gameState.projectiles.push(drill);
                    } else {
                        // Throw shovel: moderate speed, moderate damage
                        const shovelGeom = new THREE.BoxGeometry(0.5, 0.12, 0.08);
                        const shovelMat = new THREE.MeshStandardMaterial({ color: 0xd1b000, metalness: 0.3, roughness: 0.4 });
                        const shovel = new THREE.Mesh(shovelGeom, shovelMat);
                        shovel.position.copy(player.position);
                        shovel.position.z += 0.18;
                        shovel.userData = {
                            velocity: aimDir.clone().multiplyScalar(0.38 + 0.01 * minerLevel),
                            damage: 18 + 2 * minerLevel,
                            pierce: 1,
                            owner: 'player',
                            isShovel: true,
                            createdAt: now
                        };
                        scene.add(shovel);
                        gameState.projectiles.push(shovel);
                    }
                }
            }
            requestAnimationFrame(animate);
            
            if (gameState.isGameOver) {
                renderer.render(scene, camera);
                return;
            }
            
            const deltaTime = now - gameState.lastTime;
            gameState.lastTime = now;
            
            // Auto-fire machine gun when R is held
            if (keys.r && abilities.r && selectedClass && selectedClass.name === 'Engineer') {
                const result = abilities.r.execute();
                if (result === 'reload') {
                    updateAbilityCooldown('ability3', abilities.r.cooldown);
                }
                if (result) {
                    document.getElementById('ability3').style.transform = 'scale(0.9)';
                    setTimeout(() => {
                        document.getElementById('ability3').style.transform = 'scale(1)';
                    }, 100);
                }
            }
            
            // Check if wave is completed FIRST (killed enough enemies)
            if (gameState.classSelected && gameState.enemiesKilledThisWave >= gameState.enemiesPerWave) {
                console.log(`Wave ${gameState.currentWave} COMPLETED! Killed ${gameState.enemiesKilledThisWave}/${gameState.enemiesPerWave} enemies. Advancing to Wave ${gameState.currentWave + 1}`);
                gameState.currentWave++;
                // Track quest progress: highest wave reached
                if (typeof trackQuestProgress === 'function') trackQuestProgress('highestWave', gameState.currentWave);
                gameState.enemiesKilledThisWave = 0;
                gameState.waveInProgress = false; // End current wave
                document.getElementById('waveCount').textContent = gameState.currentWave;
                // Reset boss coin reward for new wave
                gameState.bossCoinAwardedThisWave = false;

                // Clear any lingering target claims from previous wave
                try {
                    if (gameState.player && gameState.player.userData) gameState.player.userData.claimedBy = null;
                    if (gameState.allies) gameState.allies.forEach(a => { if (a.userData) a.userData.claimedBy = null; });
                    if (gameState.turrets) gameState.turrets.forEach(t => { if (t.userData) t.userData.claimedBy = null; });
                } catch (e) {
                    // ignore
                }
            }
            
            // Wave-based spawning (only if class selected and ready for new wave)
            if (gameState.classSelected && !gameState.waveInProgress && gameState.enemiesKilledThisWave === 0) {
                // Start new wave
                gameState.waveInProgress = true;
                gameState.enemiesThisWave = 0;
                gameState.enemiesPerWave = 10 * gameState.currentWave; // 10 * wave number
                document.getElementById('waveProgress').style.width = '0%';
                document.getElementById('waveProgressText').textContent = '0 / ' + gameState.enemiesPerWave;
                
                // Reset boss coin reward for new wave
                gameState.bossCoinAwardedThisWave = false;

                // Spawn wave message
                console.log(`Wave ${gameState.currentWave} STARTING! Need to kill ${gameState.enemiesPerWave} enemies.`);
                // Reset yellow (boss) spawn flag each wave
                gameState.yellowSpawnedThisWave = false;
            }
            
            // Spawn enemies for current wave
            if (gameState.waveInProgress && gameState.enemiesThisWave < gameState.enemiesPerWave) {
                gameState.spawnTimer += deltaTime;
                const spawnRate = Math.max(500, 2000 - (gameState.currentWave * 100));
                
                if (gameState.spawnTimer >= spawnRate) {
                    gameState.spawnTimer = 0;
                    createEnemy();
                    gameState.enemiesThisWave++;
                    
                    // End wave spawning
                    if (gameState.enemiesThisWave >= gameState.enemiesPerWave) {
                        gameState.waveInProgress = false;
                    }
                }
            }
            
            // Update systems
            movementManager.update();
            updateProjectiles(deltaTime);
            updateTurrets(deltaTime);
            updateMinions(deltaTime);
            updateAllies(deltaTime);
            updatePlayerMelee(deltaTime);
            updateEnemies(deltaTime);
            updateMines(deltaTime);
            // Ensure entities behave as solids after movement
            resolveEntityCollisions();
            effectsManager.update();
            updateCameraShake();
            
            // Passive healing (all classes except Life, after 3 seconds without damage)
            if (selectedClass && selectedClass.name !== 'Life' && !gameState.isGameOver) {
                const timeSinceLastDamage = now - gameState.lastDamageTime;
                const timeSinceLastHeal = now - gameState.lastHealTime;
                
                // Heal 1 HP every 2 seconds after 3 seconds of not taking damage
                if (timeSinceLastDamage >= 3000 && timeSinceLastHeal >= 2000) {
                    if (hpManager.currentHp < hpManager.maxHp) {
                        hpManager.heal(1);
                        gameState.lastHealTime = now;
                    }
                }
            }
            
            // Player idle animation
            player.rotation.y += player.userData.rotationSpeed;
            const time = Date.now() * 0.001;
            player.position.z = Math.sin(time * 2) * 0.1;
            
            // Animate player glow ring
            if (player.children[0]) {
                player.children[0].rotation.z += 0.03;
                player.children[0].material.opacity = 0.3 + Math.sin(time * 3) * 0.1;
            }

            // Update enemy HP UI (screen-space DOM)
            try {
                if (Array.isArray(gameState.enemies)) {
                    for (const enemy of gameState.enemies) {
                        if (!enemy || !enemy.userData) continue;
                        // remove UI if enemy removed from scene
                        if (!enemy.parent) {
                            if (enemy.userData.hpUI && enemy.userData.hpUI.el) {
                                try { enemy.userData.hpUI.el.remove(); } catch (e) {}
                                delete enemy.userData.hpUI;
                            }
                            continue;
                        }
                        // If enemy is an invisible type, do not show an HP bar (prevents giveaway)
                        if (enemy.userData && enemy.userData.type === 'invisible') {
                            if (enemy.userData.hpUI && enemy.userData.hpUI.el) {
                                try { enemy.userData.hpUI.el.style.display = 'none'; } catch (e) {}
                            }
                            continue;
                        }
                        // If no HP UI yet, create it only when the enemy is fully on-screen
                        if (!enemy.userData.hpUI || !enemy.userData.hpUI.el) {
                            if (isEnemyFullyOnScreen(enemy)) {
                                createEnemyHPUI(enemy);
                            } else {
                                continue;
                            }
                        }
                        const ui = enemy.userData.hpUI;
                        if (!ui || !ui.el) continue;
                        const fg = ui.el.querySelector('.bar-fg');
                        if (!fg) continue;
                        const hp = (enemy.userData.hp != null) ? enemy.userData.hp : (enemy.userData.maxHp || 0);
                        const maxHp = (enemy.userData.maxHp != null) ? enemy.userData.maxHp : hp;
                        const ratio = maxHp > 0 ? Math.max(0, Math.min(1, hp / maxHp)) : 0;
                        // project world pos to screen
                        const pos = enemy.position.clone();
                        pos.project(camera);
                        const sx = (pos.x + 1) / 2 * window.innerWidth;
                        const sy = (-pos.y + 1) / 2 * window.innerHeight;
                        // vertical offset above enemy head (further reduced multiplier and clamp)
                        let yOffset = Math.round((ui.radius || 1) * 10 + 2);
                        yOffset = Math.max(8, Math.min(32, yOffset));
                        // clamp to screen so hud isn't accidentally covered
                        let leftPx = Math.round(sx);
                        let topPx = Math.round(sy - yOffset);
                        leftPx = Math.max(8, Math.min(window.innerWidth - 8, leftPx));
                        topPx = Math.max(8, Math.min(window.innerHeight - 8, topPx));
                        ui.el.style.left = leftPx + 'px';
                        ui.el.style.top = topPx + 'px';
                        // update foreground width
                        fg.style.width = Math.round(ratio * 100) + '%';
                        // color change
                        if (ratio > 0.6) fg.style.background = 'linear-gradient(90deg,#4ade80,#22c55e)';
                        else if (ratio > 0.3) fg.style.background = 'linear-gradient(90deg,#fbbf24,#f59e0b)';
                        else fg.style.background = 'linear-gradient(90deg,#ff3b3b,#dc2626)';
                    }
                }
            } catch (e) {}

            // Update ally HP UI (screen-space DOM)
            try {
                if (Array.isArray(gameState.allies)) {
                    for (const ally of gameState.allies) {
                        if (!ally || !ally.userData) continue;
                        // remove UI if ally removed from scene
                        if (!ally.parent) {
                            if (ally.userData.hpUI && ally.userData.hpUI.el) {
                                try { ally.userData.hpUI.el.remove(); } catch (e) {}
                                delete ally.userData.hpUI;
                            }
                            continue;
                        }
                        // If no HP UI yet, create it
                        if (!ally.userData.hpUI || !ally.userData.hpUI.el) {
                            createAllyHPUI(ally);
                        }
                        const ui = ally.userData.hpUI;
                        if (!ui || !ui.el) continue;
                        const fg = ui.el.querySelector('.bar-fg');
                        if (!fg) continue;
                        const hp = (ally.userData.hp != null) ? ally.userData.hp : 50;
                        const maxHp = (ally.userData.maxHp != null) ? ally.userData.maxHp : 50;
                        const ratio = maxHp > 0 ? Math.max(0, Math.min(1, hp / maxHp)) : 0;
                        // project world pos to screen
                        const pos = ally.position.clone();
                        pos.project(camera);
                        const sx = (pos.x + 1) / 2 * window.innerWidth;
                        const sy = (-pos.y + 1) / 2 * window.innerHeight;
                        let yOffset = Math.round((ui.radius || 0.8) * 10 + 2);
                        yOffset = Math.max(8, Math.min(24, yOffset));
                        let leftPx = Math.round(sx);
                        let topPx = Math.round(sy - yOffset);
                        leftPx = Math.max(8, Math.min(window.innerWidth - 8, leftPx));
                        topPx = Math.max(8, Math.min(window.innerHeight - 8, topPx));
                        ui.el.style.left = leftPx + 'px';
                        ui.el.style.top = topPx + 'px';
                        fg.style.width = Math.round(ratio * 100) + '%';
                        // Blue color for allies
                        if (ratio > 0.5) fg.style.background = 'linear-gradient(90deg,#3b82f6,#2563eb)';
                        else if (ratio > 0.25) fg.style.background = 'linear-gradient(90deg,#f59e0b,#d97706)';
                        else fg.style.background = 'linear-gradient(90deg,#ef4444,#dc2626)';
                    }
                }
            } catch (e) {}

            // Miner shovel passive spin (if present)
            try {
                if (player.userData && player.userData.shovelMesh) {
                    const shovel = player.userData.shovelMesh;
                    const baseRadius = player.userData.shovelRadius || 1.2;
                    // If drill is active, make shovel larger and faster
                    const nowMs = Date.now();
                    const drillActive = player.userData.drillUntil && nowMs < player.userData.drillUntil;
                    const targetRadius = drillActive ? baseRadius * 1.6 : baseRadius;
                    const targetScale = drillActive ? 1.6 : 1.0;
                    const speedFactor = player.userData.shovelSpeed || 0.16;
                    // Smoothly approach target radius and scale
                    player.userData.shovelRadius = player.userData.shovelRadius + (targetRadius - player.userData.shovelRadius) * 0.08;
                    shovel.scale.x += (targetScale - shovel.scale.x) * 0.12;
                    shovel.scale.y = shovel.scale.x;
                    shovel.scale.z = shovel.scale.x;
                    // Advance angle based on deltaTime-ish feel
                    const angleInc = speedFactor * (deltaTime / 16);
                    player.userData.shovelAngle = (player.userData.shovelAngle || 0) + angleInc;
                    const a = player.userData.shovelAngle;
                    shovel.position.x = Math.cos(a) * player.userData.shovelRadius;
                    shovel.position.y = Math.sin(a) * player.userData.shovelRadius;
                    shovel.position.z = 0.12 + (drillActive ? 0.06 : 0);
                    shovel.rotation.z = a + Math.PI / 6;
                }
            } catch (e) {}
            
            renderer.render(scene, camera);
            try {
                if (gameState.debugAI) {
                    if (_prevInvulnerable !== gameState.isInvulnerable) {
                        console.log(`gameState.isInvulnerable changed: ${_prevInvulnerable} -> ${gameState.isInvulnerable}`);
                        _prevInvulnerable = gameState.isInvulnerable;
                    }
                    if (_prevInvisible !== gameState.isInvisible) {
                        console.log(`gameState.isInvisible changed: ${_prevInvisible} -> ${gameState.isInvisible}`);
                        _prevInvisible = gameState.isInvisible;
                    }
                }
            } catch (e) {}
        }
        
        // Window resize
        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = window.innerWidth / -40;
            camera.right = window.innerWidth / 40;
            camera.top = window.innerHeight / 40;
            camera.bottom = window.innerHeight / -40;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            movementManager.updateBounds();
        });
        
        // Enemies will spawn after class selection
        // Initial spawn is handled in selectClass() function
        
        // Animation loop interval placeholder
        
        // Start
        animate();
        
        // Developer Console Commands
        window.devGiveExp = function(amount = 1000) {
            if (!selectedClass) {
                console.log('No class selected!');
                return;
            }
            const className = Object.keys(classes).find(key => classes[key] === selectedClass);
            if (className && classExp[className]) {
                classExp[className].exp += amount;
                while (classExp[className].exp >= classExp[className].maxExp && classExp[className].level < 15) {
                    classExp[className].exp -= classExp[className].maxExp;
                    classExp[className].level++;
                    if (classExp[className].level === 15) {
                        classExp[className].evolution++;
                        classExp[className].exp = 0; // Clear excess exp
                    } else {
                        classExp[className].maxExp = Math.floor(classExp[className].maxExp * 1.5);
                    }
                    applyClassLevelBonuses(className);
                }
                updateExpDisplays();
                updateBuyButtons();
                console.log(`Added ${amount} exp to ${className}. Now Level ${classExp[className].level} Evolution ${classExp[className].evolution}`);
                // If at max level (15), convert any leftover EXP into coins at 1:2 rate
                if (classExp[className].level >= 15 && classExp[className].exp > 0) {
                    const overflow = classExp[className].exp;
                    const coinsFromExp = Math.floor(overflow * 2);
                    gameState.coins = (gameState.coins || 0) + coinsFromExp;
                    classExp[className].exp = 0;
                    if (typeof updateCoinDisplay === 'function') updateCoinDisplay();
                    console.log(`Converted ${overflow} EXP to ${coinsFromExp} coins (devGiveExp)`);
                }
            }
        };
        
        window.devSetLevel = function(level) {
            if (!selectedClass) {
                console.log('No class selected!');
                return;
            }
            const className = Object.keys(classes).find(key => classes[key] === selectedClass);
            if (className && classExp[className]) {
                classExp[className].level = Math.max(1, Math.min(15, level));
                classExp[className].exp = 0;
                applyClassLevelBonuses(className);
                updateExpDisplays();
                updateBuyButtons();
                console.log(`Set ${className} to level ${classExp[className].level}`);
            }
        };
        
        window.devEvolve = function() {
            if (!selectedClass) {
                console.log('No class selected!');
                return;
            }
            const className = Object.keys(classes).find(key => classes[key] === selectedClass);
            if (className && classExp[className]) {
                classExp[className].evolution++;
                classExp[className].level = 15;
                classExp[className].exp = 0;
                updateExpDisplays();
                console.log(`${className} evolved! Evolution tier ${classExp[className].evolution}`);
            }
        };
        
        window.devKillAll = function() {
            const count = gameState.enemies.length;
            gameState.enemies.forEach(enemy => {
                scene.remove(enemy);
            });
            gameState.enemies = [];
            gameState.enemiesKilledThisWave += count;
            console.log(`Killed ${count} enemies`);
        };
        
        window.devSpawnEnemies = function(count = 10) {
            for (let i = 0; i < count; i++) {
                createEnemy();
            }
            console.log(`Spawned ${count} enemies`);
        };
        
        window.devSetWave = function(wave) {
            gameState.currentWave = Math.max(1, wave);
            gameState.enemiesKilledThisWave = 0;
            gameState.waveInProgress = false;
            document.getElementById('waveCount').textContent = gameState.currentWave;
            console.log(`Set wave to ${gameState.currentWave}`);
        };

        window.devToggleAI = function(val) {
            if (typeof val === 'undefined') gameState.debugAI = !gameState.debugAI;
            else gameState.debugAI = !!val;
            console.log('gameState.debugAI =', gameState.debugAI);
        };
        
        window.devGodMode = function() {
            gameState.isInvulnerable = !gameState.isInvulnerable;
            console.log(`God mode: ${gameState.isInvulnerable ? 'ON' : 'OFF'}`);
        };
        
        window.devMaxHP = function() {
            hpManager.heal(9999);
            console.log('HP restored to max');
        };
        
        window.devResetCooldowns = function() {
            if (abilities.q) abilities.q.lastUsed = 0;
            if (abilities.e) abilities.e.lastUsed = 0;
            if (abilities.r) abilities.r.lastUsed = 0;
            console.log('All cooldowns reset');
        };
        
        window.devShowState = function() {
            const className = selectedClass ? Object.keys(classes).find(key => classes[key] === selectedClass) : 'None';
            console.log('=== GAME STATE ===');
            console.log('Class:', className);
            if (className && classExp[className]) {
                console.log(`Level: ${classExp[className].level} | Evolution: ${classExp[className].evolution}`);
                console.log(`Exp: ${classExp[className].exp}/${classExp[className].maxExp}`);
            }
            console.log(`HP: ${hpManager ? hpManager.getHP() + '/' + hpManager.getMaxHP() : 'N/A'}`);
            console.log(`Wave: ${gameState.currentWave}`);
            console.log(`Enemies: ${gameState.enemies.length}`);
            console.log(`Killed this wave: ${gameState.enemiesKilledThisWave}/${gameState.enemiesPerWave}`);
            console.log(`Total kills: ${gameState.killCount}`);
            console.log(`God mode: ${gameState.isInvulnerable ? 'ON' : 'OFF'}`);
            console.log(`Allies: ${gameState.allies.length}`);
            console.log(`Turrets: ${gameState.turrets.length}`);
            console.log('==================');
        };
        
        window.devHelp = function() {
            console.log('=== DEVELOPER COMMANDS ===');
            console.log('devGiveExp(amount) - Add exp to current class (default: 1000)');
            console.log('devSetLevel(level) - Set current class level (1-14)');
            console.log('devEvolve() - Force evolve current class');
            console.log('devKillAll() - Kill all enemies');
            console.log('devSpawnEnemies(count) - Spawn enemies (default: 10)');
            console.log('devSetWave(wave) - Jump to specific wave');
            console.log('devGodMode() - Toggle invulnerability');
            console.log('devMaxHP() - Restore HP to max');
            console.log('devResetCooldowns() - Reset all ability cooldowns');
            console.log('devShowState() - Display current game state');
            console.log('devHelp() - Show this help message');
            console.log('==========================');
        };
        
        console.log('%c[DEV] Developer commands loaded! Type devHelp() for list of commands.', 'color: #00ff00; font-weight: bold;');
    </script>
</body>
<script>
(function(){
    function initLogout() {
        const btn = document.getElementById('logoutBtn');
        if (!btn) return;
        const apiBase = (typeof API_BASE !== 'undefined' && API_BASE) ? API_BASE : (window.API_BASE || '');
        btn.style.display = 'block';
        btn.addEventListener('click', function(){
            const base = apiBase.replace(/\/$/, '');
            const url = base ? base + '/logout' : '/logout';
            window.location.href = url;
        });
    }
    if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', initLogout);
    else initLogout();
})();
</script>
</html>